<!DOCTYPE html>
<html lang="en">
  <head>
    <title>ES2016到ES2023新特性</title>
    <meta charset="utf-8">
    <meta name="description" content="This is a page">
    <meta name="keywords" content="page, sample">
    <meta name="author" content="None">
    <link rel="icon" sizes="any" mask href="../assets/images/ico4.svg" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <link rel="stylesheet" href="../assets/css/articles.css">
</head>
<body>
  <!--<div class="article__wrapper_left">
    <div class="article__wrapper_left-mulu">目录</div>
    <ul class="articles__list"><li class="">
          <a href="/articles/05.html">
            抽象工厂模式
          </a>
        </li><li class="">
          <a href="/articles/06.html">
            建造者模式
          </a>
        </li><li class="">
          <a href="/articles/07.html">
            10种JavaScript快乐写法
          </a>
        </li><li class="">
          <a href="/articles/08.html">
            真正理解Promise
          </a>
        </li><li class="">
          <a href="/articles/09.html">
            50个JS高级知识点
          </a>
        </li><li class="">
          <a href="/articles/10.html">
            ES6到ES12常用新特性
          </a>
        </li><li class="">
          <a href="/articles/100.html">
            Set 和 WeakSet 的用法和区别
          </a>
        </li><li class="">
          <a href="/articles/101.html">
            获取上传进度的几种方式
          </a>
        </li><li class="">
          <a href="/articles/102.html">
            使用音频和视频
          </a>
        </li><li class="">
          <a href="/articles/103.html">
            History API 与单页应用
          </a>
        </li></ul>
  </div>-->
  <div class="article__wrapper_sidebar">
    <a href="/" target="_blank"><svg t="1714001835347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4298" width="48" height="48"><path d="M147.904 304.128l301.866667-179.541333a128 128 0 0 1 131.712 0.512l295.466666 178.88A128 128 0 0 1 938.666667 413.482667V810.666667a128 128 0 0 1-128 128H213.333333a128 128 0 0 1-128-128V414.144a128 128 0 0 1 62.570667-110.016z m43.626667 73.344A42.666667 42.666667 0 0 0 170.666667 414.144V810.666667a42.666667 42.666667 0 0 0 42.666666 42.666666h597.333334a42.666667 42.666667 0 0 0 42.666666-42.666666V413.482667a42.666667 42.666667 0 0 0-20.565333-36.501334l-295.466667-178.88a42.666667 42.666667 0 0 0-43.925333-0.170666l-301.866667 179.541333z" fill="#8a919f" p-id="4299"></path><path d="M405.333333 469.333333h213.333334a42.666667 42.666667 0 1 1 0 85.333334H405.333333a42.666667 42.666667 0 1 1 0-85.333334z m0 85.333334a42.666667 42.666667 0 1 0 0-85.333334h213.333334a42.666667 42.666667 0 1 0 0 85.333334H405.333333z" fill="#8a919f" p-id="4300"></path></svg></a>
    <a href="/tools/" target="_blank"><svg t="1714002003458" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6911" width="48" height="48"><path d="M817.87 556.31h-63.58v-66.24A42.27 42.27 0 0 0 712 447.8h-84.81a42.27 42.27 0 0 0-42.27 42.27v66.24H436.57v-66.24a42.27 42.27 0 0 0-42.27-42.27h-84.83a42.27 42.27 0 0 0-42.27 42.27v66.24h-61.83A22.39 22.39 0 0 0 183 578.7a22.39 22.39 0 0 0 22.39 22.39h61.81v65.55a42.27 42.27 0 0 0 42.27 42.27h84.83a42.27 42.27 0 0 0 42.27-42.27v-65.55h148.36v65.55a42.27 42.27 0 0 0 42.27 42.27H712a42.27 42.27 0 0 0 42.27-42.27v-65.55h63.58a22.39 22.39 0 0 0 22.39-22.39 22.39 22.39 0 0 0-22.37-22.39z m-438.64 95.26h-54.69V505.14h54.69z m317.72 0h-54.69V505.14H697z" p-id="6912" fill="#8a919f"></path><path d="M823 202.58h-90.81v-63.09a71.88 71.88 0 0 0-71.88-71.88H363.19a71.88 71.88 0 0 0-71.88 71.88v63.08h-90.12A137.17 137.17 0 0 0 64 339.75v479a137.17 137.17 0 0 0 137.19 137.14H823a137.17 137.17 0 0 0 137.19-137.17v-479A137.17 137.17 0 0 0 823 202.58z m-474.36-54.1A23.52 23.52 0 0 1 372.17 125h279.16a23.52 23.52 0 0 1 23.52 23.52v54.1h-326.2z m554.23 673.31a76.76 76.76 0 0 1-76.76 76.76h-628a76.76 76.76 0 0 1-76.76-76.76V336.67a76.76 76.76 0 0 1 76.76-76.76h628a76.76 76.76 0 0 1 76.76 76.76z" p-id="6913" fill="#8a919f"></path></svg></a>
  </div>
  <div class="article__wrapper">
    <div class="article__wrapper__main">
      <div class="article__wrapper_header">
        <h1>ES2016到ES2023新特性</h1>
        <span class="articles__home_time">2023/08/27 · YinHao</span>
      </div>
      <h3>ES2016</h3>
<ul>
<li>Array.prototype.includes()</li>
</ul>
<blockquote>
<p>这个方法用于检查数组是否包含特定元素，如果包含则返回 true，否则返回 false</p>
</blockquote>
<pre><code class="language-js">// 我有一个水果篮子
const fruitBasket = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;grape&quot;];
// 我要检查篮子里是否有橙子
const hasOrange = fruitBasket.includes(&quot;orange&quot;);
console.log(hasOrange); // 输出: true
// 我还想知道篮子里是否有葡萄
const hasGrape = fruitBasket.includes(&quot;grape&quot;);
console.log(hasGrape); // 输出: true
// 现在我要检查篮子里是否有西瓜
const hasWatermelon = fruitBasket.includes(&quot;watermelon&quot;);
console.log(hasWatermelon); // 输出: false
</code></pre>
<ul>
<li>求幂运算符</li>
</ul>
<p>求幂运算符： 这是一个新的算术运算符，用于计算一个数的幂</p>
<pre><code class="language-js">// 我要计算 2 的 3 次幂
const result = 2 ** 3;
console.log(result); // 输出: 8
</code></pre>
<h3>ES2017</h3>
<ul>
<li>Object.values / Object.entries</li>
</ul>
<pre><code class="language-js">const person = {
  name: &quot;Alice&quot;,
  age: 25,
  city: &quot;New York&quot;,
};
const values = Object.values(person); // 得到：['Alice', 25, 'New York']
const entries = Object.entries(person); // 得到：[['name', 'Alice'], ['age', 25], ['city', 'New York']]
</code></pre>
<ul>
<li>字符串补全</li>
</ul>
<p>字符串补全是一种操作，可以在一个字符串的末尾添加一些额外的字符，使得字符串的长度达到特定的目标长度。</p>
<pre><code class="language-js">console.log(&quot;a&quot;.padStart(5, &quot;1&quot;)); // 1111a
console.log(&quot;a&quot;.padEnd(5, &quot;2&quot;)); // a2222
</code></pre>
<ul>
<li>Async/await</li>
</ul>
<p>Async/await 是 JavaScript 中处理异步操作的一种方式，它使得在代码中处理异步任务更加直观和易读。</p>
<pre><code class="language-js">function simulateFetchingData() {
  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      resolve(&quot;Data fetched&quot;);
    }, 1000);
  });
}

async function fetchData() {
  console.log(&quot;Fetching data...&quot;);
  const data = await simulateFetchingData();
  console.log(data); // 输出: 'Data fetched'
}

fetchData(); // 会在一秒后输出: 'Data fetched'
</code></pre>
<ul>
<li>Object.getOwnPropertyDescriptors()</li>
</ul>
<p>用于获取一个对象的所有属性的详细信息，包括属性的特性（例如可写、可枚举、可配置）以及属性的值。</p>
<pre><code class="language-js">const item = {
  name: &quot;Widget&quot;,
  color: &quot;Blue&quot;,
};
const descriptors = Object.getOwnPropertyDescriptors(item);
console.log(descriptors);
</code></pre>
<ul>
<li>参数列表支持尾逗号</li>
</ul>
<p>函数参数列表最后一个参数后面允许有一个逗号，这在以后添加更多参数时更方便。</p>
<pre><code class="language-js">function inviteFriends(friend1, friend2, friend3) {
  console.log(&quot;Inviting:&quot;, friend1, friend2, friend3);
}
inviteFriends(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;); // 输出: Inviting: Alice Bob Charlie
</code></pre>
<h3>ES2018</h3>
<ul>
<li>for-await-of 异步迭代</li>
</ul>
<p>异步迭代在 Node.js 中用的会多些，使用  for-await-of  遍历异步数据。例如使用 MongoDB 查询数据返回值默认为一个游标对象，避免了一次性把数据读入应用内存</p>
<p>想象你有一组需要分步完成的任务，比如读取多个文件，这些任务都是异步的。for-await-of 就像是一个一个完成这些任务，等一个任务完成后再进行下一个。</p>
<ul>
<li>Promise.finally</li>
</ul>
<p>Promise.finally 是在 Promise 结束（不管是成功还是失败）后，无论如何都会执行的代码块。</p>
<pre><code class="language-js">const fetchData = new Promise((resolve, reject) =&gt; {
  // 模拟异步操作
  setTimeout(() =&gt; {
    resolve(&quot;Data fetched&quot;);
  }, 1000);
});

fetchData
  .then((data) =&gt; console.log(data))
  .catch((error) =&gt; console.error(error))
  .finally(() =&gt; console.log(&quot;Promise finished&quot;));
</code></pre>
<ul>
<li>Rest / Spread 属性</li>
</ul>
<p>这些属性让你可以更方便地处理函数参数和对象数组的拷贝。</p>
<p>想象你要组织一场聚会，需要把朋友们的名字一个一个列出来。Rest 属性就像是把这些名字都捡起来放进一个列表，而 Spread 属性就像是把这个列表里的名字一个一个散落出来。</p>
<pre><code class="language-js">// Rest 属性
function inviteFriends(host, ...guests) {
  console.log(`${host}邀请了${guests.join(&quot;, &quot;)}参加聚会`);
}
inviteFriends(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;);
// Spread 属性
const oldFriends = [&quot;John&quot;, &quot;Jane&quot;];
const newFriends = [&quot;Mike&quot;, &quot;Emily&quot;];
const allFriends = [...oldFriends, ...newFriends];
console.log(allFriends); // 输出: ['John', 'Jane', 'Mike', 'Emily']
</code></pre>
<h3>ES2019</h3>
<ul>
<li>可选的 catch 参数</li>
</ul>
<p>允许在 <code>catch</code> 块中省略异常参数，使得在不需要异常信息时代码更简洁。</p>
<pre><code class="language-js">try {
  // 一些可能会发生问题的代码
} catch {
  // 不需要异常参数
  console.log(&quot;出错了&quot;);
}
</code></pre>
<ul>
<li>Symbol.prototype.description</li>
</ul>
<p>这是一个新的方法，用于返回 Symbol 的可读描述，方便开发者理解 Symbol 的用途。</p>
<p>想象你有很多特殊的印章，每个印章代表不同的事情。description 就像是告诉你每个印章代表的是什么，让你能更好地理解这些印章。</p>
<pre><code class="language-js">const mySymbol = Symbol(&quot;这是一个特殊的标记&quot;);
console.log(mySymbol.description); // 输出: '这是一个特殊的标记'
</code></pre>
<ul>
<li>函数的 toString() 方法</li>
</ul>
<p>一个函数对象的方法，用于将函数的源代码转化成字符串。</p>
<pre><code class="language-js">function sayHello() {
  console.log(&quot;Hello!&quot;);
}
const functionString = sayHello.toString();
console.log(functionString); // 输出函数的源代码字符串
</code></pre>
<ul>
<li>Object.fromEntries()</li>
</ul>
<p>一个用于将键值对列表转换成对象的方法。</p>
<p>想象你有一些标签和对应的价值，现在你想把它们整理成一个清单。Object.fromEntries() 就像是帮你把这些标签和价值整理成一个清单。</p>
<pre><code class="language-js">const entries = [
  [&quot;name&quot;, &quot;Alice&quot;],
  [&quot;age&quot;, 30],
];
const person = Object.fromEntries(entries);
console.log(person); // 输出: { name: 'Alice', age: 30 }
</code></pre>
<ul>
<li>消除前后空格</li>
</ul>
<p>一种字符串处理方法，用于去除字符串开头和结尾的空格。</p>
<pre><code class="language-js">const messyText = &quot;   这里有很多空格   &quot;;
const cleanText = messyText.trim();
console.log(cleanText); // 输出: '这里有很多空格'
</code></pre>
<ul>
<li>数组 flat()、flatMap()</li>
</ul>
<p>数组的两个方法，用于将多维数组拉平为一维数组，以及在拉平的同时对数组元素进行操作。Infinity 是 flat 对数组深度展开，flatMap 则只能展开一层。</p>
<p>想象你有一些叠在一起的盒子，里面还有更小的盒子。flat() 就像是把所有的盒子都打开，把里面的东西拿出来放在一起。而 flatMap() 就像是在拿出东西的同时，还可以对它们做些处理。</p>
<pre><code class="language-js">const nestedArray = [1, [2, [3, [4]]]];
const flattenedArray = nestedArray.flat();
console.log(flattenedArray); // 输出: [1, 2, [3, [4]]]
const flattened = nestedArray.flat(Infinity);
console.log(flattenedArray); // 输出: [1, 2, 3, 4]
const doubledArray = nestedArray.flatMap((value) =&gt; value * 2);
console.log(doubledArray); // 输出: [2, 4, 6, [4]]
</code></pre>
<h3>ES2020</h3>
<ul>
<li>MatchAll 匹配所有</li>
</ul>
<p>字符串的新方法，可以通过正则表达式来查找字符串中的所有匹配项。</p>
<p>想象你有一篇文章，想找出所有包含某个特定单词的地方。matchAll 就像是帮你在文章中找到所有这样的地方</p>
<pre><code class="language-js">const text = &quot;Hello world, hello universe&quot;;
const regex = /hello/gi;
for (const match of text.matchAll(regex)) {
  console.log(match);
}
</code></pre>
<ul>
<li>模块新特性</li>
</ul>
<p>import 动态导入 动态导入意思是当你需要该模块时才会进行加载，返回的是一个 Promise​ 对象。只有在 ES Modules 模块规范下才支持。</p>
<pre><code class="language-js">// index-a.mjs
export default {
  hello() {
    console.log(`hello JavaScript`);
  },
};
// index-b.mjs
import(&quot;./index-a.mjs&quot;).then(module {
  module.default.hello(); // hello JavaScript
});
</code></pre>
<p>import.meta​ 指当前模块的元数据。一个广泛支持的属性是 import.meta.url，以字符串形式输出当前模块的文件路径。</p>
<ul>
<li>Promise.allSettled</li>
</ul>
<p>这是 Promise 的一个新方法，可以等待多个 Promise 都完成（无论成功还是失败）后再继续。</p>
<pre><code class="language-js">const promises = [Promise.resolve(&quot;Success!&quot;), Promise.reject(&quot;Error!&quot;)];
Promise.allSettled(promises).then((results) =&gt; console.log(results));
</code></pre>
<ul>
<li>全局对象</li>
</ul>
<p>JavaScript 可以运行在不同的环境，浏览器为 window、Node.js 为 global。为了能够统一全局环境变量，引入了 globalThis。</p>
<pre><code class="language-js">window === globalThis; // 浏览器环境
global === globalThis; // Node.js 环境
</code></pre>
<ul>
<li>for-in 机制</li>
</ul>
<p>这是对 <code>for-in</code> 循环的更新，用于更好地遍历对象的可枚举属性。 想象你要看一个箱子里有什么东西，但有些东西可能隐藏得很深。<code>for-in</code> 机制就像是帮你把箱子里所有东西都拿出来看一遍。</p>
<pre><code class="language-js">const obj = { a: 1, b: 2, c: 3 };
for (const key in obj) {
  console.log(key, obj[key]);
}
</code></pre>
<ul>
<li>可选链</li>
</ul>
<p>这是一个新的语法，用于在访问对象的属性时，避免因为属性不存在而导致错误。</p>
<pre><code class="language-js">const person = {
  name: &quot;Alice&quot;,
  contact: {
    phone: &quot;123-456-7890&quot;,
  },
};
const phoneNumber = person?.contact?.phone;
console.log(phoneNumber); // 输出: '123-456-7890'
</code></pre>
<ul>
<li>空值合并</li>
</ul>
<p>这是一种新的语法，用于给变量赋值时，如果变量的值为 null 或 undefined，就使用默认值。</p>
<p>想象你要吃冰淇淋，但是不知道哪种口味有，所以你要确保有一种口味可以选。空值合并就像是在选择口味时，如果没有你喜欢的，就选择默认的口味。</p>
<pre><code class="language-js">const favoriteIceCream = null;
const iceCreamChoice = favoriteIceCream ?? &quot;Vanilla&quot;;
console.log(iceCreamChoice); // 输出: 'Vanilla'
</code></pre>
<h3>ES2021</h3>
<ul>
<li>String.prototype.replaceAll</li>
</ul>
<p>字符串的一个新方法，用于替换所有匹配的子字符串。</p>
<p>想象你在纸上写了一句话，但是有一些词你想换成其他词。replaceAll 就像是帮你把所有要换的词都换掉。</p>
<pre><code class="language-js">const originalText = &quot;Hello world, hello universe&quot;;
const newText = originalText.replaceAll(&quot;hello&quot;, &quot;hi&quot;);
console.log(newText); // 输出: 'Hi world, hi universe'
</code></pre>
<ul>
<li>Promise.any</li>
</ul>
<p><code>Promise.any</code> 是 <code>Promise</code> 的一个新方法，用于在一组 Promise 中，只要有一个成功就返回，不必等待所有 Promise 都结束。</p>
<pre><code class="language-js">const promises = [
  Promise.reject(&quot;Error 1&quot;),
  Promise.resolve(&quot;Success!&quot;),
  Promise.reject(&quot;Error 2&quot;),
];

Promise.any(promises)
  .then((result) =&gt; console.log(result))
  .catch((errors) =&gt; console.error(errors));
</code></pre>
<ul>
<li>数字分隔符</li>
</ul>
<p>分隔符是一种在数字中插入下划线，以便更易读的语法。</p>
<pre><code class="language-js">const largeNumber = 1_000_000;
console.log(largeNumber); // 输出: 1000000
</code></pre>
<ul>
<li>逻辑赋值运算符</li>
</ul>
<p>结合了逻辑运算符 &amp;&amp;、||、??​ 和逻辑表达式 =</p>
<pre><code class="language-js">// &quot;Or Or Equals&quot; (or, the Mallet operator :wink:)
a ||= b; // a || (a = b);

// &quot;And And Equals&quot;
a &amp;&amp;= b; // a &amp;&amp; (a = b);

// &quot;QQ Equals&quot;
a ??= b; // a ?? (a = b);
</code></pre>
<ul>
<li>WeakRefs</li>
</ul>
<p>WeakRefs 是一种新的对象引用类型，用于创建对对象的弱引用，不会影响对象的垃圾回收。</p>
<p>想象你有一个备忘录，但是只在你需要的时候才能看到。WeakRefs 就像是对对象的一种轻量级引用，不会让对象被保持得太久。</p>
<pre><code class="language-js">const obj = { data: &quot;Some data&quot; };
const weakRef = new WeakRef(obj);
// 只有当 obj 还存在时，weakRef 才能获取到它
const retrievedObj = weakRef.deref();
console.log(retrievedObj?.data); // 输出: 'Some data'
</code></pre>
<h3>ES2022</h3>
<ul>
<li>类私有属性</li>
</ul>
<p>这是 JavaScript 中类的一个新特性，允许在类内部声明私有属性，仅在类的内部可访问。</p>
<p>想象你有一本笔记本，里面有些笔记是只有你能看到的。类私有属性就像是在类里面写下一些只有类自己能看到的东西。</p>
<pre><code class="language-js">class Person {
  #name = &quot;Alice&quot;; // 私有属性
  sayHello() {
    console.log(`Hello, my name is ${this.#name}`);
  }
}
const person = new Person();
person.sayHello(); // 输出: 'Hello, my name is Alice'
console.log(person.#name); // 无法访问私有属性
</code></pre>
<ul>
<li>私有字段检查</li>
</ul>
<p>一种新的访问控制，允许类的私有属性在外部被访问时触发特定的操作。</p>
<p>想象你的门上装有警报，如果有人试图进入你的房间，会发出声音。私有字段检查就像是在访问私有属性时触发警报。</p>
<pre><code class="language-js">class BankAccount {
  #balance = 1000; // 私有属性

  #checkAccess() {
    console.log(&quot;Access to balance checked&quot;);
  }

  get balance() {
    this.#checkAccess();
    return this.#balance;
  }
}

const account = new BankAccount();
console.log(account.balance); // 输出: 'Access to balance checked' 和账户余额
</code></pre>
<ul>
<li>顶层 await</li>
</ul>
<p>允许在模块顶层使用 await。</p>
<p>想象你在工作，需要等一份文件完成才能继续。顶层 await 就像是你在等这份文件，但不需要停下其他的工作。</p>
<pre><code class="language-js">// 在模块顶层使用 await
const data = await fetchData();
console.log(data);
</code></pre>
<ul>
<li>.At 方法返回指定索引的元素</li>
</ul>
<p>想象你有一个大盒子，里面有很多东西。.at 方法就像是帮你从盒子中取出特定位置的东西。</p>
<pre><code class="language-js">const arr = [1, 2, 3, 4, 5];
console.log(arr.at(2)); // 输出: 3
const text = &quot;Hello&quot;;
console.log(text.at(1)); // 输出: 'e'
</code></pre>
<ul>
<li>Object.hasOwn()</li>
</ul>
<p>一个全局函数，用于检查对象是否具有指定的自有属性。</p>
<p>想象你有一张名单，上面写着一些名字。Object.hasOwn() 就像是帮你查看名单上是否有某个名字。</p>
<pre><code class="language-js">const person = { name: &quot;Alice&quot; };
console.log(Object.hasOwn(person, &quot;name&quot;)); // 输出: true
console.log(Object.hasOwn(person, &quot;age&quot;)); // 输出: false
</code></pre>
<ul>
<li>异常链</li>
</ul>
<p>一种更好地处理异常信息的方式，允许你在异常中包含更多信息。</p>
<p>想象你有一串蛋糕，但其中一个蛋糕有问题。异常链就像是在蛋糕上贴上标签，告诉你哪个蛋糕有问题，以及为什么有问题。</p>
<pre><code class="language-js">try {
  // 一些可能出错的代码
} catch (error) {
  const detailedError = new Error(&quot;详细错误信息&quot;);
  detailedError.originalError = error;
  throw detailedError;
}
</code></pre>
<ul>
<li>类静态块</li>
</ul>
<p>类的一个新特性，允许在类内部定义一块在类被初始化时执行的代码。</p>
<p>想象你在搭建一个房子，房子刚建好时，你想做一些特定的准备工作。类静态块就像是在房子刚建好时，执行一些初始化工作。</p>
<pre><code class="language-js">class MyClass {
  static {
    console.log(&quot;类初始化中...&quot;);
  }
  constructor() {
    console.log(&quot;实例化对象&quot;);
  }
}
const obj = new MyClass();
</code></pre>
<h3>ES2023</h3>
<ul>
<li>Array 支持从尾部查找</li>
</ul>
<p>新增两个方法： .findLast()、.findLastIndex()​  从数组的最后一个元素开始查找，可以同  find()、findIndex()  做一个对比。</p>
<p>想象你有一条长长的队伍，人们站成一列。你可以从前面开始数，也可以从后面开始数。数组支持从尾部查找就像是你从队伍尾部开始数人。</p>
<pre><code class="language-js">const arr = [{ value: 1 }, { value: 2 }, { value: 3 }, { value: 4 }];

// find vs findLast
console.log(arr.find(n n.value % 2 === 1)); // { value: 1 }
console.log(arr.findLast(n n.value % 2 === 1)); // { value: 3 }

// findIndex vs findLastIndex
console.log(arr.findIndex(n n.value % 2 === 1)); // 0
console.log(arr.findLastIndex(n n.value % 2 === 1)); // 2
</code></pre>
<ul>
<li>Hashbang 语法</li>
</ul>
<p>Hashbang 语法是一种在 URL 中使用 #! 符号，用于标记 Web 应用中的前端路由。</p>
<p>想象你有一本书，但书中有很多章节。你可以用不同的书签快速翻到你想读的章节。Hashbang 语法就像是在 URL 中放了一个特殊的书签，让你能迅速定位到网页的某个部分。</p>
<pre><code class="language-js">// URL 中的 Hashbang
https://example.com/#!/page1
https://example.com/#!/page2
</code></pre>
 
    </div>
  </div>
  <div class="article__wrapper_footer">
    <a class="article__wrapper_footer-left " href="/articles/03.html"><svg t="1713708729970" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8437" width="48" height="48"><path d="M409.272947 512.57741l403.237243 403.237243a63.349415 63.349415 0 1 1-89.622481 89.622482L274.839224 557.324726a63.349415 63.349415 0 0 1 0-89.494632L722.951633 19.717685a63.349415 63.349415 0 1 1 89.494633 89.622482L409.336872 512.57741z" p-id="8438" fill="#8a8a8a"></path></svg></a>
    <a class="article__wrapper_footer-right " href="/articles/05.html"><svg t="1713708697355" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8093" width="48" height="48"><path d="M855.123 517.004c0 8.245-3.167 15.51-9.503 21.823L402.999 981.47c-6.336 6.336-13.625 9.477-21.869 9.477s-15.51-3.142-21.845-9.477L311.8 933.96c-6.336-6.336-9.502-13.6-9.502-21.845 0-8.222 3.167-15.51 9.502-21.845l373.29-373.29-373.293-373.267c-6.336-6.336-9.502-13.6-9.502-21.845s3.167-15.533 9.503-21.869l47.484-47.484c6.336-6.336 13.6-9.502 21.845-9.502s15.533 3.167 21.869 9.503l442.621 442.622c6.334 6.334 9.503 13.625 9.503 21.869z" fill="#8a8a8a" p-id="8094"></path></svg></a>
  </div>
  <a class="article__wrapper_index" href="/articles/"><svg t="1713708857338" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9656" width="48" height="48"><path d="M549.61981 133.022476l319.683047 203.605334A70.851048 70.851048 0 0 1 902.095238 396.361143v434.883047A70.89981 70.89981 0 0 1 831.146667 902.095238h-282.819048l0.024381-218.112h-71.826286v218.087619L192.853333 902.095238A70.89981 70.89981 0 0 1 121.904762 831.24419V390.241524c0-24.527238 12.678095-47.299048 33.54819-60.220953l318.659048-197.485714a70.972952 70.972952 0 0 1 75.50781 0.487619zM828.952381 828.952381V397.214476L511.488 195.047619 195.047619 391.119238V828.952381h211.309714v-216.551619h212.187429v216.527238L828.952381 828.952381z" p-id="9657" fill="#707070"></path></svg></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
  <script src="../assets/js/articles-detail.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</body>
</html>
    