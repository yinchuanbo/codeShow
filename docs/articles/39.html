<!DOCTYPE html>
<html lang="en">
  <head>
    <title>当你的网站有新内容，如何立即通知你的用户呢？</title>
    <meta charset="utf-8">
    <meta name="description" content="This is a page">
    <meta name="keywords" content="page, sample">
    <meta name="author" content="None">
    <link rel="icon" sizes="any" mask href="../assets/images/ico6.svg" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <link rel="stylesheet" href="../assets/css/articles.css">
</head>
<body>
  <div class="article__wrapper_left">
    <div class="article__wrapper_left-mulu">目录</div>
    <ul class="articles__list"><li class="">
          <a href="/articles/40.html">
            裁剪的3种方式，CSS 如何隐藏移动端的滚动条？
          </a>
        </li><li class="">
          <a href="/articles/41.html">
            属性的 getter 和 setter
          </a>
        </li><li class="">
          <a href="/articles/42.html">
            原生的延迟加载支持
          </a>
        </li><li class="">
          <a href="/articles/43.html">
            视频加载
          </a>
        </li><li class="">
          <a href="/articles/44.html">
            加载注意事项
          </a>
        </li><li class="">
          <a href="/articles/45.html">
            网站优化之静态资源优化
          </a>
        </li><li class="">
          <a href="/articles/46.html">
            资源优先级
          </a>
        </li><li class="">
          <a href="/articles/47.html">
            书写高性能的代码
          </a>
        </li><li class="">
          <a href="/articles/48.html">
            构建优化
          </a>
        </li><li class="">
          <a href="/articles/49.html">
            Object.create()
          </a>
        </li></ul>
  </div>
  <div class="article__wrapper_sidebar">
    <a href="/" target="_blank"><svg t="1714001835347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4298" width="48" height="48"><path d="M147.904 304.128l301.866667-179.541333a128 128 0 0 1 131.712 0.512l295.466666 178.88A128 128 0 0 1 938.666667 413.482667V810.666667a128 128 0 0 1-128 128H213.333333a128 128 0 0 1-128-128V414.144a128 128 0 0 1 62.570667-110.016z m43.626667 73.344A42.666667 42.666667 0 0 0 170.666667 414.144V810.666667a42.666667 42.666667 0 0 0 42.666666 42.666666h597.333334a42.666667 42.666667 0 0 0 42.666666-42.666666V413.482667a42.666667 42.666667 0 0 0-20.565333-36.501334l-295.466667-178.88a42.666667 42.666667 0 0 0-43.925333-0.170666l-301.866667 179.541333z" fill="#8a919f" p-id="4299"></path><path d="M405.333333 469.333333h213.333334a42.666667 42.666667 0 1 1 0 85.333334H405.333333a42.666667 42.666667 0 1 1 0-85.333334z m0 85.333334a42.666667 42.666667 0 1 0 0-85.333334h213.333334a42.666667 42.666667 0 1 0 0 85.333334H405.333333z" fill="#8a919f" p-id="4300"></path></svg></a>
    <a href="/tools/" target="_blank"><svg t="1714002003458" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6911" width="48" height="48"><path d="M817.87 556.31h-63.58v-66.24A42.27 42.27 0 0 0 712 447.8h-84.81a42.27 42.27 0 0 0-42.27 42.27v66.24H436.57v-66.24a42.27 42.27 0 0 0-42.27-42.27h-84.83a42.27 42.27 0 0 0-42.27 42.27v66.24h-61.83A22.39 22.39 0 0 0 183 578.7a22.39 22.39 0 0 0 22.39 22.39h61.81v65.55a42.27 42.27 0 0 0 42.27 42.27h84.83a42.27 42.27 0 0 0 42.27-42.27v-65.55h148.36v65.55a42.27 42.27 0 0 0 42.27 42.27H712a42.27 42.27 0 0 0 42.27-42.27v-65.55h63.58a22.39 22.39 0 0 0 22.39-22.39 22.39 22.39 0 0 0-22.37-22.39z m-438.64 95.26h-54.69V505.14h54.69z m317.72 0h-54.69V505.14H697z" p-id="6912" fill="#8a919f"></path><path d="M823 202.58h-90.81v-63.09a71.88 71.88 0 0 0-71.88-71.88H363.19a71.88 71.88 0 0 0-71.88 71.88v63.08h-90.12A137.17 137.17 0 0 0 64 339.75v479a137.17 137.17 0 0 0 137.19 137.14H823a137.17 137.17 0 0 0 137.19-137.17v-479A137.17 137.17 0 0 0 823 202.58z m-474.36-54.1A23.52 23.52 0 0 1 372.17 125h279.16a23.52 23.52 0 0 1 23.52 23.52v54.1h-326.2z m554.23 673.31a76.76 76.76 0 0 1-76.76 76.76h-628a76.76 76.76 0 0 1-76.76-76.76V336.67a76.76 76.76 0 0 1 76.76-76.76h628a76.76 76.76 0 0 1 76.76 76.76z" p-id="6913" fill="#8a919f"></path></svg></a>
  </div>
  <div class="article__wrapper">
    <div class="article__wrapper__main">
      <div class="article__wrapper_header">
        <h1>当你的网站有新内容，如何立即通知你的用户呢？</h1>
        <span class="articles__home_time">NaN/NaN/NaN · YinHao</span>
      </div>
      <p>你有没有遇到过这样的场景：当你在浏览网页时，突然收到一个通知，告诉你有新的内容更新，或者有一条重要的消息通知你查看。</p>
<p>作为一枚前端开发，你可能会想，这不就是请求轮询吗？</p>
<p>没错，异步请求通过轮询的方式确实能实现类似的功能，但这不是我们今天要分享的主题 ~</p>
<p>是什么呢？</p>
<p>是 <strong>Service Worker</strong>！</p>
<p>是的，通过 Service Worker 来实现“推送通知”的功能。Service Worker 是 Web API 的一部分，其功能非常强大。相信通过今天的内容，你肯定会有所收获。</p>
<p>那么现在，就让我们正式开始吧~</p>
<h3>1. 初识 Service Worker</h3>
<p>简单来说，Service Worker 是一种在浏览器背后默默工作的 JS 脚本，它可以在用户没有打开网页的情况下运行，为网页提供了各种强大的功能，比如离线缓存、后台同步等，当然还有我们今天要分享的——推送通知。</p>
<p>有些网站的推送通知做的相当不错，比如油管（YouTube）。当你关注了油管上的某个 UP 主，当 TA 更新视频后浏览器就会给你推送消息，这时候就算你没有打开浏览器，你也会收到通知。Windows 10 系统上在桌面右下角会弹出一个来自浏览器的消息通知框，通知的内容来自油管那位 UP 主的更新信息；Mac 系统上，在桌面右上角会有一条来自浏览器的通知，通知的内容与 Windows 上的信息一致。</p>
<p>你可能会问，为什么我们要使用 Service Worker 来实现推送通知呢？</p>
<p>原因很简单，因为它可以帮助我们更好地与用户进行交互，能提高用户的参与度，甚至在一定程度上可以提高用户的留存率。设想一下，如果你的网站有新的内容更新，你可以立即通过推送通知告诉你的用户。</p>
<p>这样的话，你的用户就不会错过重要通知了，而通知的内容恰好又戳到了用户的 G 点，那 TA 肯定会点一下消息框，然后瞬间就回到你的网站了。相较于用户首先打开浏览器然后点击书签访问到你的网站来说，这种类似于系统级别的消息通知能极大提高用户粘性。</p>
<p>所以，要不要考虑把 Service Worker 在自己网站上用起来呢？</p>
<p>下面，我们就来一步步实现这个功能。</p>
<h3>2. Service Worker 基础</h3>
<p>现在你已经对 Service Worker 有了一个基本的了解，接下来我们看一下它的基础知识。</p>
<p>首先你要明白 Service Worker 是如何实现推送通知的。其实它的工作原理也不复杂，当用户访问网页时，Service Worker 就会被安装到用户的设备上。当服务器有新的信息需要传递给用户时，服务器就会发送一个推送事件到 Service Worker。然后，Service Worker 就会接收这个事件推送，并根据这个事件显示给用户一个通知。</p>
<p>这就是 Service Worker 实现推送通知的基本原理，是不是挺简单的？</p>
<p>接下来让我们动手实践一下吧 ~</p>
<h3>3. 注册 Service Worker</h3>
<p>第一步，我们需要注册一个 Service Worker。你可能会问，“注册 Service Worker”是什么意思呢？</p>
<p>其实，这是要跟浏览器说：</p>
<p>“Hi，我要在我的网站上用 Service Worker 哦~”</p>
<p>要怎么注册 Service Worker 呢？很简单，只需要几行代码。首先，你需要检查一下浏览器是不是支持 Service Worker。检查方式也不难，通过浏览器的 <code>navigator</code> 对象上的 <code>serviceWorker</code> 属性来判断即可。如果 <code>navigator.serviceWorker</code> 存在，则表示浏览器支持 Service Worker。</p>
<p>具体代码如下：</p>
<pre><code class="language-js">if (&quot;serviceWorker&quot; in navigator) {
  window.addEventListener(&quot;load&quot;, function () {
    navigator.serviceWorker.register(&quot;/sw.js&quot;).then(
      function (registration) {
        console.log(&quot;Service Worker 注册成功，作用域是：&quot;, registration.scope);
      },
      function (err) {
        console.log(&quot;Service Worker 注册失败，错误是：&quot;, err);
      }
    );
  });
}
</code></pre>
<p>这段代码中有个地方需要注意，在 register 方法中需要提供 Service Worker 的脚本路径，这里放在了网站根目录。比如，你用的是 Next.js，那么 sw.js 文件就应该放在 public 目录下面。</p>
<p><code>navigator.serviceWorker.register</code> 方法返回一个 Promise，这个 Promise 在 Service Worker 注册成功时会解析为一个 <code>registration</code> 对象，这个对象包含了关于 Service Worker 的一些信息，比如它的作用域。如果 Service Worker 注册失败，Promise 会被拒绝，并且错误信息会被捕获并打印出来。</p>
<p>我们看一下在浏览器中注册之后的效果：</p>
<p><img src="../assets/images/articles/39/01.png" alt=""></p>
<p>是不是注册 Service Worker 很简单？</p>
<p>注册完，接下来就是订阅了。</p>
<h3>4. Service Worker 订阅推送</h3>
<p>什么是“订阅推送”呢？简单来说，订阅推送就是告诉服务器：</p>
<p>“Hey，有新的消息要告诉我哦~”</p>
<p>这样，当服务器有新的内容时，它就会把这些内容推送给你。</p>
<p>那么，我们如何使用 Service Worker 订阅推送呢？其实，这个过程也非常简单，几个步骤就能搞定。</p>
<p>首先要做的：获取用户许可。为什么要征得用户同意才行呢？因为推送通知是一种可以打扰到用户的行为，所以我们需要获取用户的许可才行。</p>
<p>至于请求用户许可的方法也很简单，用 <code>Notification.requestPermission</code> 方法来征得用户同意即可。调用这个方法后，浏览器会弹出一个对话框，询问用户是否允许接收通知。如果用户同意，这个方法就会返回一个解析为 'granted' 的 Promise。</p>
<p>然后，我们还需要生成一个订阅对象。可以通过 <code>registration.pushManager.subscribe</code> 方法来生成一个订阅对象。这个方法需要一个参数，这个参数是一个包含 <code>userVisibleOnly</code> 和 <code>applicationServerKey</code> 属性的对象。<code>userVisibleOnly</code> 属性表示每个推送消息都必须对用户可见，<code>applicationServerKey</code> 属性是服务器的公钥，用于加密推送消息。</p>
<p>最后，我们需要把这个订阅对象发送给服务器。可以使用 <code>fetch</code> 方法来发送一个 POST 请求到服务器，请求的主体就是我们的订阅对象。</p>
<p>参考代码如下：</p>
<pre><code class="language-js">Notification.requestPermission().then(function (permission) {
  if (permission === &quot;granted&quot;) {
    navigator.serviceWorker.ready.then(function (registration) {
      registration.pushManager
        .subscribe({
          userVisibleOnly: true,
          // PUBLIC_KEY 是 VAPID 公钥，VAPID 公钥和秘钥是配对的，需要在你自己的服务器上生成 VAPID 公钥和私钥。
          // 可以在 https://web-push-codelab.glitch.me/ 中生成用公钥和秘钥以做测试用。
          applicationServerKey: urlBase64ToUint8Array(&quot;YOUR_PUBLIC_KEY&quot;),
        })
        .then(function (subscription) {
          fetch(&quot;/subscribe&quot;, {
            method: &quot;POST&quot;,
            headers: {
              &quot;Content-Type&quot;: &quot;application/json&quot;,
            },
            body: JSON.stringify(subscription),
          });
        });
    });
  }
});
</code></pre>
<p>在这段代码中，我们首先请求用户的许可。如果用户同意接收通知，我们就等待 Service Worker 准备好，然后生成一个订阅对象，并把这个订阅对象发送给服务器。</p>
<p>之后服务器可以返回一个消息告诉浏览器是否订阅成功，比如我们在 Next.js 中模拟一下：</p>
<pre><code class="language-js">// pages/api/subscribe.js
import type { NextApiRequest, NextApiResponse } from &quot;next/types&quot;;

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse&lt;{ message: string }&gt;
) {
  if (req.method === &quot;POST&quot;) {
    // 在这里处理订阅对象
    const subscription = req.body;

    // 保存订阅对象到数据库或其他地方
    // ...

    res.status(200).json({ message: &quot;订阅成功&quot; });
  } else {
    res.status(405).json({ message: &quot;只接受 POST 请求&quot; });
  }
}
</code></pre>
<p>服务器收到订阅对象后，返回了一个对象表示订阅成功。</p>
<p>![](../assets/images/articles/39/01.gif&quot; /&gt;</p>
<p>这样，当服务器有新的消息时就能直接通知到用户了。</p>
<p>如果你想测试一下消息推送功能该怎么办呢？这个也很简单。</p>
<p>你可以在 Service Worker 中模拟一下从服务端发送消息：</p>
<pre><code class="language-js">// Service Worker: /public/sw.js

self.addEventListener(&quot;push&quot;, function (event) {
  const title = &quot;新消息：模拟服务端发送的消息！&quot;;
  const options = {
    body: event.data.text(),
  };

  event.waitUntil(self.registration.showNotification(title, options));
});
</code></pre>
<p>之后，你可以使用浏览器的开发者工具来模拟推送事件。在浏览器的开发者工具中，你可以选择“应用”选项卡下的 “Service Worker”菜单，然后点击 &quot;推送&quot; 按钮来模拟一个推送事件。</p>
<p><img src="../assets/images/articles/39/02.png" alt=""></p>
<p>![](../assets/images/articles/39/02.gif&quot; /&gt;</p>
<h3>5. 交互通知</h3>
<p>目前为止，我们已经实现了“推送通知”的功能，但是只有通知是不够的。我们还需要让用户能够与这个通知进行交互。比如，当用户看到这个通知后可能会下意识去点一下，那么，我们就可以通过用户的这个点击动作，把用户引导到我们的网站上。</p>
<p>具体应该怎么实现呢？</p>
<p>其实也不难，我们只需要在 Service Worker 中添加一个监听器就可以了。这个事件监听器会监听 'notificationclick' 事件，当用户点击通知时，这个事件就会被触发。</p>
<pre><code class="language-js">self.addEventListener(&quot;notificationclick&quot;, function (event) {
  event.notification.close(); // 关闭通知
  event.waitUntil(
    clients.openWindow(&quot;https://www.yourwebsite.com&quot;) // 打开你的网站
  );
});
</code></pre>
<p>这段代码会在用户点击通知时关闭通知，并打开你的网站。</p>
<p>​ 是不是很简单？这里就不放截屏了。</p>
<h3>6. 最佳实践和注意事项</h3>
<p>至此，Service Worker 推送通知就已经实现了。不过这一功能需要后端支持，如果你对后端开发有一些经验，那就再好不过了。</p>
<p>但是，还有一些需要注意的事项。</p>
<p>首先，你的网站必须是通过 HTTPS 访问的，因为 Service Worker 只能在 HTTPS 网站上生效。这主要是基于安全的考虑。</p>
<p>再就是 Service Worker 有它自己的生命周期，它会在安装、激活和终止等阶段执行不同的任务。所以，你要理解、掌握它的生命周期。鉴于篇幅原因，这部分内容没有涉及。不过不要担心，这部分内容会后面和大家分享。</p>
<p>最后一点就是用户体验的问题了。虽然其推送通知的能力非常强，但是如果频繁给用户推送消息，用户得烦死了~ 所以，你要尽可能保证你推送的通知是有价值的，且不能过于频繁。还有一点，你应该、也必须提供一个简单的方式让用户能取消订阅。这部分内容我们也会在后面和大家分享，你可以先自己了解一下这方面的知识。</p>
 
    </div>
  </div>
  <div class="article__wrapper_footer">
    <a class="article__wrapper_footer-left " href="/articles/38.html"><svg t="1713708729970" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8437" width="48" height="48"><path d="M409.272947 512.57741l403.237243 403.237243a63.349415 63.349415 0 1 1-89.622481 89.622482L274.839224 557.324726a63.349415 63.349415 0 0 1 0-89.494632L722.951633 19.717685a63.349415 63.349415 0 1 1 89.494633 89.622482L409.336872 512.57741z" p-id="8438" fill="#8a8a8a"></path></svg></a>
    <a class="article__wrapper_footer-right " href="/articles/40.html"><svg t="1713708697355" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8093" width="48" height="48"><path d="M855.123 517.004c0 8.245-3.167 15.51-9.503 21.823L402.999 981.47c-6.336 6.336-13.625 9.477-21.869 9.477s-15.51-3.142-21.845-9.477L311.8 933.96c-6.336-6.336-9.502-13.6-9.502-21.845 0-8.222 3.167-15.51 9.502-21.845l373.29-373.29-373.293-373.267c-6.336-6.336-9.502-13.6-9.502-21.845s3.167-15.533 9.503-21.869l47.484-47.484c6.336-6.336 13.6-9.502 21.845-9.502s15.533 3.167 21.869 9.503l442.621 442.622c6.334 6.334 9.503 13.625 9.503 21.869z" fill="#8a8a8a" p-id="8094"></path></svg></a>
  </div>
  <a class="article__wrapper_index" href="/articles/"><svg t="1713708857338" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9656" width="48" height="48"><path d="M549.61981 133.022476l319.683047 203.605334A70.851048 70.851048 0 0 1 902.095238 396.361143v434.883047A70.89981 70.89981 0 0 1 831.146667 902.095238h-282.819048l0.024381-218.112h-71.826286v218.087619L192.853333 902.095238A70.89981 70.89981 0 0 1 121.904762 831.24419V390.241524c0-24.527238 12.678095-47.299048 33.54819-60.220953l318.659048-197.485714a70.972952 70.972952 0 0 1 75.50781 0.487619zM828.952381 828.952381V397.214476L511.488 195.047619 195.047619 391.119238V828.952381h211.309714v-216.551619h212.187429v216.527238L828.952381 828.952381z" p-id="9657" fill="#707070"></path></svg></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
  <script src="../assets/js/articles-detail.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</body>
</html>
    