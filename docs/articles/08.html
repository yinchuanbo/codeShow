<!DOCTYPE html>
<html lang="en">
  <head>
    <title>真正理解Promise</title>
    <meta charset="utf-8">
    <meta name="description" content="This is a page">
    <meta name="keywords" content="page, sample">
    <meta name="author" content="None">
    <link rel="icon" sizes="any" mask href="../assets/images/ico4.svg" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <link rel="stylesheet" href="../assets/css/articles.css">
</head>
<body>
  <!--<div class="article__wrapper_left">
    <div class="article__wrapper_left-mulu">目录</div>
    <ul class="articles__list"><li class="">
          <a href="/articles/09.html">
            50个JS高级知识点
          </a>
        </li><li class="">
          <a href="/articles/10.html">
            ES6到ES12常用新特性
          </a>
        </li><li class="">
          <a href="/articles/100.html">
            Set 和 WeakSet 的用法和区别
          </a>
        </li><li class="">
          <a href="/articles/101.html">
            获取上传进度的几种方式
          </a>
        </li><li class="">
          <a href="/articles/102.html">
            使用音频和视频
          </a>
        </li><li class="">
          <a href="/articles/103.html">
            History API 与单页应用
          </a>
        </li><li class="">
          <a href="/articles/104.html">
            Drag 和 Drop 介绍
          </a>
        </li><li class="">
          <a href="/articles/105.html">
            利用 Performance API 分析网站性能
          </a>
        </li><li class="">
          <a href="/articles/106.html">
            使用 HTML5 音频和视频
          </a>
        </li><li class="">
          <a href="/articles/107.html">
            Web Storage
          </a>
        </li></ul>
  </div>-->
  <div class="article__wrapper_sidebar">
    <a href="/" target="_blank"><svg t="1714001835347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4298" width="48" height="48"><path d="M147.904 304.128l301.866667-179.541333a128 128 0 0 1 131.712 0.512l295.466666 178.88A128 128 0 0 1 938.666667 413.482667V810.666667a128 128 0 0 1-128 128H213.333333a128 128 0 0 1-128-128V414.144a128 128 0 0 1 62.570667-110.016z m43.626667 73.344A42.666667 42.666667 0 0 0 170.666667 414.144V810.666667a42.666667 42.666667 0 0 0 42.666666 42.666666h597.333334a42.666667 42.666667 0 0 0 42.666666-42.666666V413.482667a42.666667 42.666667 0 0 0-20.565333-36.501334l-295.466667-178.88a42.666667 42.666667 0 0 0-43.925333-0.170666l-301.866667 179.541333z" fill="#8a919f" p-id="4299"></path><path d="M405.333333 469.333333h213.333334a42.666667 42.666667 0 1 1 0 85.333334H405.333333a42.666667 42.666667 0 1 1 0-85.333334z m0 85.333334a42.666667 42.666667 0 1 0 0-85.333334h213.333334a42.666667 42.666667 0 1 0 0 85.333334H405.333333z" fill="#8a919f" p-id="4300"></path></svg></a>
    <a href="/tools/" target="_blank"><svg t="1714002003458" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6911" width="48" height="48"><path d="M817.87 556.31h-63.58v-66.24A42.27 42.27 0 0 0 712 447.8h-84.81a42.27 42.27 0 0 0-42.27 42.27v66.24H436.57v-66.24a42.27 42.27 0 0 0-42.27-42.27h-84.83a42.27 42.27 0 0 0-42.27 42.27v66.24h-61.83A22.39 22.39 0 0 0 183 578.7a22.39 22.39 0 0 0 22.39 22.39h61.81v65.55a42.27 42.27 0 0 0 42.27 42.27h84.83a42.27 42.27 0 0 0 42.27-42.27v-65.55h148.36v65.55a42.27 42.27 0 0 0 42.27 42.27H712a42.27 42.27 0 0 0 42.27-42.27v-65.55h63.58a22.39 22.39 0 0 0 22.39-22.39 22.39 22.39 0 0 0-22.37-22.39z m-438.64 95.26h-54.69V505.14h54.69z m317.72 0h-54.69V505.14H697z" p-id="6912" fill="#8a919f"></path><path d="M823 202.58h-90.81v-63.09a71.88 71.88 0 0 0-71.88-71.88H363.19a71.88 71.88 0 0 0-71.88 71.88v63.08h-90.12A137.17 137.17 0 0 0 64 339.75v479a137.17 137.17 0 0 0 137.19 137.14H823a137.17 137.17 0 0 0 137.19-137.17v-479A137.17 137.17 0 0 0 823 202.58z m-474.36-54.1A23.52 23.52 0 0 1 372.17 125h279.16a23.52 23.52 0 0 1 23.52 23.52v54.1h-326.2z m554.23 673.31a76.76 76.76 0 0 1-76.76 76.76h-628a76.76 76.76 0 0 1-76.76-76.76V336.67a76.76 76.76 0 0 1 76.76-76.76h628a76.76 76.76 0 0 1 76.76 76.76z" p-id="6913" fill="#8a919f"></path></svg></a>
  </div>
  <div class="article__wrapper">
    <div class="article__wrapper__main">
      <div class="article__wrapper_header">
        <h1>真正理解Promise</h1>
        <span class="articles__home_time">2023/08/27 · YinHao</span>
      </div>
      <h2>Promise 的简单介绍</h2>
<p><code>Promise</code> 是用来进行异步编程的。在 <code>Promise</code> 出现之前，传统的异步编程靠的是监听事件和回调函数，比如：</p>
<pre><code class="language-js">const xhr = new XMLHttpRequest();
xhr.addEventListener(&quot;load&quot;, function (data) {
  console.log(data);
});
xhr.open(&quot;GET&quot;, &quot;http://www.example.com/&quot;);
xhr.send();
</code></pre>
<p>这种方式有一个致命的缺点，那就是<strong>回调地狱</strong>，如果我们想在第一个请求成功返回数据之后，再发送第二个请求，那就只能在第一个请求成功的回调函数中发送，以此类推，还想再发送下一个请求时，就只能在上一个请求成功的回调函数中发送：</p>
<pre><code class="language-js">const xhr = new XMLHttpRequest();
xhr.addEventListener(&quot;load&quot;, function (data) {
  console.log(data);
  const xhr1 = new XMLHttpRequest();
  xhr1.open(&quot;GET&quot;, &quot;http://www.example.com/&quot;);
  xhr1.send();
  xhr1.addEventListener(&quot;load&quot;, function (data1) {
    console.log(data1);
    //... 发送第三个请求
  });
});
xhr.open(&quot;GET&quot;, &quot;http://www.example.com/&quot;);
xhr.send();
</code></pre>
<p>这种代码不仅看起来很痛苦，写起来也非常痛苦。而 <code>Promise</code> 就是用来解决这个问题的，可以把 <code>Promise</code> 理解成一个容器，里面保存着某个未来才会结束的事件的结果（也就是异步操作的结果），它有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败），状态改变只有两种：从 <code>pending</code> 变为 <code>fulfilled</code> 或从 <code>pending</code> 变为 <code>rejected</code> ，一旦状态改变，就不会再变了。一般情况下，可以分别通过 <code>resolve</code> 函数使得状态变为 <code>fulfilled</code>，<code>reject</code> 函数使得状态变为 <code>rejected</code>。</p>
<p>我们使用 <code>Promise</code> 来简单改造一下上述的多个请求方式：</p>
<pre><code class="language-js">function request(url) {
  return new Promise((resolve, reject) =&gt; {
    const xhr = new XMLHttpRequest();
    xhr.addEventListener(&quot;load&quot;, function (data) {
      console.log(data);
      resolve();
    });
    xhr.open(&quot;GET&quot;, url);
    xhr.send();
  });
}
// 发送第一个请求
request(&quot;http://www.example.com/&quot;)
  .then(() =&gt; {
    // 发送第二个请求
    return request(&quot;http://www.example1.com/&quot;);
  })
  .then(() =&gt; {
    // 发送第三个请求
    return request(&quot;http://www.example2.com/&quot;);
  });
</code></pre>
<p>可以看到，有了 <code>Promise</code> 的帮助，代码完全脱离了回调地狱的嵌套，以一种流水线的方式来承接发送请求的功能，代码结构上更加清晰。</p>
<blockquote>
<p>更多关于 <code>Promise</code> 的介绍可以参考阮一峰老师的《ECMAScript 6 入门》中的 <a href="https://es6.ruanyifeng.com/#docs/promise">Promise 对象</a>。</p>
</blockquote>
<h2>捉摸不透的 Promise 输出顺序</h2>
<p>简单地熟悉了 <code>Promise</code> 的功能之后，我们再来看看这三种 <code>Promise</code> 的输出顺序：</p>
<pre><code class="language-js">Promise.resolve()
  .then(() =&gt; {
    console.log(0);
    return 4;
  })
  .then((res) =&gt; {
    console.log(res);
  });
Promise.resolve()
  .then(() =&gt; {
    console.log(1);
  })
  .then(() =&gt; {
    console.log(2);
  })
  .then(() =&gt; {
    console.log(3);
  })
  .then(() =&gt; {
    console.log(5);
  });
// 0 1 4 2 3 5
</code></pre>
<pre><code class="language-js">Promise.resolve()
  .then(() =&gt; {
    console.log(0);
    return {
      then(resolve) {
        resolve(4);
      },
    };
  })
  .then((res) =&gt; {
    console.log(res);
  });
Promise.resolve()
  .then(() =&gt; {
    console.log(1);
  })
  .then(() =&gt; {
    console.log(2);
  })
  .then(() =&gt; {
    console.log(3);
  })
  .then(() =&gt; {
    console.log(5);
  });
// 0 1 2 4 3 5
</code></pre>
<pre><code class="language-js">Promise.resolve()
  .then(() =&gt; {
    console.log(0);
    return Promise.resolve(4);
  })
  .then((value) =&gt; {
    console.log(value);
  });
Promise.resolve()
  .then(() =&gt; {
    console.log(1);
  })
  .then(() =&gt; {
    console.log(2);
  })
  .then(() =&gt; {
    console.log(3);
  })
  .then(() =&gt; {
    console.log(5);
  });
// 0 1 2 3 4 5
</code></pre>
<p>这三种 <code>Promise</code> 的输出顺序不同之处在于 4 的位置，而决定 4 的位置的关键代码在于第一个 <code>then</code> 方法回调函数的返回值。</p>
<p>尤其是第二种，大家可能比较少见，返回的是一个具有 <code>then</code> 方法的对象，这个对象被称之为 <code>thenable</code> 对象，这个对象的 <code>then</code> 方法接收两个参数，<code>resolve</code> 和 <code>reject</code>，它们都是函数，其含义和 <code>Promise</code> 构造函数中的 <code>resolve</code> 和 <code>reject</code> 一样。所以后面紧跟的链式 <code>then</code> 方法能够接收到 4 这个值。</p>
<p>要想彻底搞明白这三种 <code>Promise</code> 的输出顺序，我们就得来手动实现一遍 <code>Promise</code> 的原理，看看里面到底有啥法宝。</p>
<h2>Promise 源码实现</h2>
<h3>基础功能</h3>
<p>万事开头难，为了让大家更有兴趣地往下看，我们先简单地实现 <code>Promise</code> 的基础功能。</p>
<p>先看一个基础功能的例子，如下：</p>
<pre><code class="language-js">const p = new Promise((resolve, reject) =&gt; {
  resolve(&quot;fulfilled&quot;);
  reject(&quot;rejected&quot;);
});
p.then(
  (value) =&gt; {
    console.log(value);
  },
  (reason) =&gt; {
    console.log(reason);
  }
);
// fulfilled
</code></pre>
<p>我们来分析一下这段代码都做了什么：</p>
<ol>
<li>
<p><code>Promise</code> 构造函数会传入一个回调函数作为参数，回调函数又会接收两个参数 — <code>resolve</code> 和 <code>reject</code>，它们都是函数，前文说过，<code>resolve</code> 和 <code>reject</code> 是用来改变 <code>Promise</code> 实例对象的状态。</p>
</li>
<li>
<p>一旦状态改变，就不会再改变了。状态改变之后，会调用 <code>then</code> 方法的两个回调函数中的一个，并且会相对应地接收 <code>resolve</code> 或 <code>reject</code> 函数的参数值。</p>
</li>
<li>
<p><code>fulfilled</code> 状态下会执行 <code>then</code> 方法的第一个回调函数，<code>rejected</code> 状态会执行第二个回调函数。</p>
</li>
</ol>
<p>理解了这段代码的执行逻辑之后，我们分两步来实现 <code>Promise</code> 的基础功能，分别是： <code>new Promise</code> 的实现原理和 <code>then</code> 方法的实现原理。</p>
<h4>new Promise 的实现原理</h4>
<pre><code class="language-js">// 定义状态
const PENDING = &quot;pending&quot;;
const FULFILLED = &quot;fulfilled&quot;;
const REJECTED = &quot;rejected&quot;;
class SelfPromise {
  // 储存状态，初始值是 pending
  status = PENDING;
  // 成功之后的值
  value = null;
  // 失败之后的原因
  reason = null;

  constructor(executor) {
    // 将 resolve 和 reject 传给 new Promsie 的回调函数
    executor(this.resolve, this.reject);
  }

  // 箭头函数可以使函数里面的 this 始终指向 Promise 实例对象
  resolve = (value) =&gt; {
    // 只有状态是 pending 的情况下，才改变为 fulfilled 状态
    if (this.status === PENDING) {
      this.status = FULFILLED;
      this.value = value;
    }
  };
  reject = (reason) =&gt; {
    // 只有状态是 pending 的情况下，才改变为 rejected 状态
    if (this.status === PENDING) {
      this.status = REJECTED;
      this.reason = reason;
    }
  };
}
</code></pre>
<p>这里有两个注意点：</p>
<ol>
<li>
<p><code>resolve</code> 和 <code>reject</code> 方法只有是在箭头函数的情况下，才能直接传递给 <code>executor</code> 函数作为参数（<code>executor(this.resolve, this.reject)</code>），这样在外部调用 <code>resolve</code> 或 <code>reject</code> 函数的时候，它们的 <code>this</code> 指向始终是 <code>Promise</code> 实例对象。那改为普通函数可不可以呢？也可以，不过就是需要使用 <code>bind</code> 方法来稳定 <code>resolve</code> 和 <code>reject</code> 的 <code>this</code> 指向 — <code>executor(this.resolve.bind(this), this.reject.bind(this))</code>。</p>
</li>
<li>
<p><code>resolve</code> 和 <code>reject</code> 只有在 <code>pending</code> 状态下，才需要改变状态和记录结果，这样就达到了 <code>Promise</code> 状态一旦改变就不能再改变的效果。</p>
</li>
</ol>
<h4>then 方法的实现原理</h4>
<pre><code class="language-js">//... 省略部分代码
class SelfPromise {
  //... 省略部分代码

  then(onFulfilled, onRejected) {
    if (this.status === FULFILLED) {
      // 把 resolve 的值传递给 fulfilled 状态的回调函数，并且调用它。
      onFulfilled(this.value);
    } else if (this.status === REJECTED) {
      // 把 reject 的值传递给 rejected 状态的回调函数，并且调用它。
      onRejected(this.reason);
    }
  }
}
</code></pre>
<p><code>then</code> 方法的实现相对来说比较简单，只需要根据状态调用相应的回调函数即可。</p>
<h3>基础功能的完整代码</h3>
<pre><code class="language-js">// 定义状态
const PENDING = &quot;pending&quot;;
const FULFILLED = &quot;fulfilled&quot;;
const REJECTED = &quot;rejected&quot;;
class SelfPromise {
  // 储存状态，初始值是 pending
  status = PENDING;
  // 成功之后的值
  value = null;
  // 失败之后的原因
  reason = null;

  constructor(executor) {
    // 将 resolve 和 reject 传给 new Promsie 的回调函数
    executor(this.resolve, this.reject);
  }

  // 箭头函数可以函数里面的 this 始终指向 Promise 实例对象
  resolve = (value) =&gt; {
    // 只有状态是 pending 的情况下，才改变为 fulfilled 状态
    if (this.status === PENDING) {
      this.status = FULFILLED;
      this.value = value;
    }
  };
  reject = (reason) =&gt; {
    // 只有状态是 pending 的情况下，才改变为 rejected 状态
    if (this.status === PENDING) {
      this.status = REJECTED;
      this.reason = reason;
    }
  };

  then(onFulfilled, onRejected) {
    if (this.status === FULFILLED) {
      // 把 resolve 的值传递给 fulfilled 状态的回调函数，并且调用它。
      onFulfilled(this.value);
    } else if (this.status === REJECTED) {
      // 把 reject 的值传递给 rejected 状态的回调函数，并且调用它。
      onRejected(this.reason);
    }
  }
}
</code></pre>
<p>用一开始的 <code>Promise</code> 基础功能的例子来测试一下：</p>
<pre><code class="language-js">const p = new SelfPromise((resolve, reject) =&gt; {
  resolve(&quot;fulfilled&quot;);
  reject(&quot;rejected&quot;);
});
p.then(
  (value) =&gt; {
    console.log(value);
  },
  (reason) =&gt; {
    console.log(reason);
  }
);
// fulfilled
</code></pre>
<p>撒花~ 完美！<code>Promise</code> 基础功能的实现原理顺利完成。</p>
<h3>处理异步逻辑</h3>
<p>基础版的 <code>Promise</code> 有一个很大的缺点，就是处理不了异步的情况。</p>
<pre><code class="language-js">const p = new SelfPromise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;fulfilled&quot;);
  });
});
p.then(
  (value) =&gt; {
    console.log(value);
  },
  (reason) =&gt; {
    console.log(reason);
  }
);
// 不会输出任何信息
</code></pre>
<p>由于使用了 <code>setTimeout</code> 执行 <code>resolve</code> 函数，导致 <code>then</code> 方法执行比 <code>resolve</code> 函数要早，所以 <code>then</code> 方法在执行的时候，<code>Promise</code> 的状态是 <code>pending</code>，不会执行任何回调函数。</p>
<p>基于这种情况，我们需要在 <code>then</code> 方法中添加处理 <code>pending</code> 状态的逻辑。</p>
<p>实现思路是：如果在 <code>then</code> 方法中判断到状态是 <code>pending</code>，那么就先将两个回调函数保存起来，然后在 <code>Promise</code> 内部的 <code>resolve</code> 或 <code>reject</code> 方法中执行。</p>
<pre><code class="language-js">//... 省略部分代码
class SelfPromise {
+   // 保存 onFulfilled 回调函数
+   onFulfilledCallback = null;
+   // 保存 onRejected 回调函数
+   onRejectedCallback = null;

    //... 省略部分代码

    resolve = (value) =&gt; {
        if (this.status === PENDING) {
            this.status = FULFILLED;
            this.value = value;
+           // 执行 onFulfilled 回调函数
+           this.onFulfilledCallback &amp;&amp; this.onFulfilledCallback(value);
        }
    };

    reject = (reason) =&gt; {
        if (this.status === PENDING) {
            this.status = REJECTED;
            this.reason = reason;
+           // 执行 onRejected 回调函数
+           this.onRejectedCallback &amp;&amp; this.onRejectedCallback(reason);
        }
    };

    then(onFulfilled, onRejected) {
        if (this.status === FULFILLED) {
            onFulfilled(this.value);
        } else if (this.status === REJECTED) {
            onRejected(this.reason);
+       } else {
+           // pending 状态下保存回调函数
+           this.onFulfilledCallback = onFulfilled;
+           this.onRejectedCallback = onRejected;
        }
    }
}
</code></pre>
<p>再运行一下用例，我们就可以打印出 <code>fulfilled</code> 信息了。</p>
<h3>then 方法的多次调用</h3>
<p>别忘了，<code>Promise</code> 实例对象的 <code>then</code> 方法是可以多次调用的，而我们现在的代码是无法做到这一点的：</p>
<pre><code class="language-js">const p = new SelfPromise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;fulfilled&quot;);
  });
});
p.then((value) =&gt; {
  console.log(&quot;1&quot;, value);
});
p.then((value) =&gt; {
  console.log(&quot;2&quot;, value);
});
p.then((value) =&gt; {
  console.log(&quot;3&quot;, value);
});
// 3 fulfilled
</code></pre>
<p>目前的代码只能输出 <code>3 fulfilled</code>，需要把 <code>1 fulfilled</code> 和 <code>2 fulfilled</code> 的输出补上。至于为什么只能输出 <code>3 fulfilled</code> 呢？关键在于源码当中 <code>then</code> 方法保存回调函数的方式：</p>
<pre><code class="language-js">class SelfPromise {
  //... 省略部分代码
  then(onFulfilled, onRejected) {
    if (this.status === FULFILLED) {
      onFulfilled(this.value);
    } else if (this.status === REJECTED) {
      onRejected(this.reason);
    } else {
      // pending 状态下保存回调函数
      this.onFulfilledCallback = onFulfilled;
      this.onRejectedCallback = onRejected;
    }
  }
}
</code></pre>
<p>回调函数会直接保存在 <code>this.onFulfilledCallback</code> 或 <code>this.onRejectedCallback</code> 中，这样就会导致保存的是最后一个 <code>then</code> 方法的回调函数，所以这里不能直接用两个变量来保存，而是用两个数组来保存所有的回调函数，同时 <code>Promise</code> 内部的 <code>resolve</code> 和 <code>reject</code> 方法也需要循环调用所有的回调函数。</p>
<pre><code class="language-js">//... 省略部分代码
class SelfPromise {
+   // 保存所有的 onFulfilled 回调函数
+   onFulfilledCallbacks = [];
+   // 保存所有的 onRejected 回调函数
+   onRejectedCallbacks = [];

    //... 省略部分代码

    resolve = (value) =&gt; {
        if (this.status === PENDING) {
            this.status = FULFILLED;
            this.value = value;
+           // 执行所有的 onFulfilled 回调函数
+           this.onFulfilledCallbacks.forEach((fn) =&gt; fn(value));
        }
    };

    reject = (reason) =&gt; {
        if (this.status === PENDING) {
            this.status = REJECTED;
            this.reason = reason;
+           // 执行 onRejected 回调函数
+           this.onRejectedCallbacks.forEach((fn) =&gt; fn(reason));
        }
    };

    then(onFulfilled, onRejected) {
        if (this.status === FULFILLED) {
            onFulfilled(this.value);
        } else if (this.status === REJECTED) {
            onRejected(this.reason);
+       } else {
+           // pending 状态下保存所有的回调函数
+           this.onFulfilledCallbacks.push(onFulfilled);
+           this.onRejectedCallbacks.push(onRejected);
        }
    }
}
</code></pre>
<p>细心的朋友应该发现了这其实是一个<strong>观察者模式</strong>，<code>then</code> 方法的 <code>this.onFulfilledCallbacks.push(onFulfilled)</code> 和 <code>this.onRejectedCallbacks.push(onRejected)</code> 就是在添加订阅者，而 <code>resolve</code> 和 <code>reject</code> 方法就是在通知所有的订阅者。</p>
<p>我们再运行一下用例，得出结果：</p>
<pre><code class="language-sh">1 fulfilled
2 fulfilled
3 fulfilled
</code></pre>
<p>完美，令人满意的结果！</p>
<h3>then 方法的链式调用</h3>
<p><code>Promise</code> 最核心的功能就是 <code>then</code> 方法的链式调用，这也是解决回调地狱的关键所在。就目前我们手动实现的代码来看，是不能够进行 <code>then</code> 方法的链式调用的，因为 <code>then</code> 方法没有任何返回值。</p>
<p>要想实现 <code>then</code> 方法的链式调用，<code>then</code> 方法必须返回 <code>Promise</code> 对象，并且下一个 <code>then</code> 方法的回调函数的参数会依赖上一个 <code>then</code> 方法的回调函数的返回值，这种依赖有两种情况：</p>
<ol>
<li>如果返回的是 <code>Promise</code> 实例对象，那么下一个 <code>then</code> 方法的回调函数会接收该实例对象的 <code>resolve</code> 或 <code>reject</code> 函数传入的值，比如：</li>
</ol>
<pre><code class="language-js">const p = new Promise((resolve, reject) =&gt; {
  resolve(1);
});
p.then((value) =&gt; {
  console.log(value);
  return new Promise((resolve, reject) =&gt; {
    resolve(2);
    // reject(2);
  });
}).then(
  (value) =&gt; {
    console.log(&quot;fulfilled&quot;, value);
  },
  (err) =&gt; {
    console.log(&quot;rejected&quot;, err);
  }
);

// 1
// fulfilled 2

// 如果调用的是 reject(2)，那么返回的是：
// 1
// rejected 2
</code></pre>
<ol start="2">
<li>如果返回的是 <code>thenable</code> 对象，会和第一种情况一样：</li>
</ol>
<pre><code class="language-js">const p = new Promise((resolve, reject) =&gt; {
  resolve(1);
});
p.then((value) =&gt; {
  console.log(value);
  return {
    then(resolve, reject) {
      resolve(2);
      // reject(2);
    },
  };
}).then(
  (value) =&gt; {
    console.log(&quot;fulfilled&quot;, value);
  },
  (err) =&gt; {
    console.log(&quot;rejected&quot;, err);
  }
);
// 1
// fulfilled 2
// 如果调用的是 reject(2)，那么返回的是：
// 1
// rejected 2
</code></pre>
<ol start="3">
<li>如果返回的是其他对象或者原始数据类型的值，那么下一个 <code>then</code> 方法的回调函数的参数会直接接收这个值，比如：</li>
</ol>
<pre><code class="language-js">const p = new Promise((resolve, reject) =&gt; {
  resolve(1);
});
p.then((value) =&gt; {
  console.log(value);
  return {
    value: 2,
  };
}).then((value) =&gt; {
  console.log(&quot;fulfilled&quot;, value);
});
// 1
// fulfilled { value: 2 }
</code></pre>
<p>了解了 <code>then</code> 方法链式调用的基本情况之后，我们来动手实现一下 <code>then</code> 方法的链式调用。</p>
<p>首先，让 <code>then</code> 方法返回一个 <code>Promise</code> 对象：</p>
<pre><code class="language-js">class SelfPromise {
  // ... 省略部分代码

    then(onFulfilled, onRejected) {
+       const promise2 = new SelfPromise((resolve, reject) =&gt; {
            if (this.status === FULFILLED) {
                onFulfilled(this.value);
            } else if (this.status === REJECTED) {
                onRejected(this.reason);
            } else {
                this.onFulfilledCallbacks.push(onFulfilled);
                this.onRejectedCallbacks.push(onRejected);
            }
+       });
+       // 返回 Promise 对象
+       return promise2;
    }
}
</code></pre>
<p>接着，通过 <code>resolve</code> 和 <code>reject</code> 函数来改变 <code>promise2</code> 对象的状态，并且建立上一个 <code>then</code> 方法与下一个 <code>then</code> 方法的依赖关系。</p>
<pre><code class="language-js">class SelfPromise {
  // ... 省略部分代码

    then(onFulfilled, onRejected) {
        const promise2 = new SelfPromise((resolve, reject) =&gt; {
            if (this.status === FULFILLED) {
+               // 获取上一个 then 方法的 fulfilled 回调函数的返回值
+               const v = onFulfilled(this.value);
+               // 根据返回值，改变 promise2 的状态，并建立与下一个 then 方法的关系
+               resolvePromise(v, resolve, reject);
            } else if (this.status === REJECTED) {
+               // 获取上一个 then 方法的 rejected 回调函数的返回值
+               const v = onRejected(this.reason);
+               //根据返回值，改变 promise2 的状态，并建立与下一个 then 方法的关系
+               resolvePromise(v, resolve, reject);
            } else {
                this.onFulfilledCallbacks.push(onFulfilled);
                this.onRejectedCallbacks.push(onRejected);
            }
        });

        return promise2;
    }
}

function resolvePromise(value, resolve, reject) {
    if (typeof value === &quot;object&quot; || typeof value === &quot;function&quot;) {
        if (value === null) {
            // 如果返回值是 null，
            // 直接调用 resolve 函数，promise2 的状态变为 fulfilled，
            // 返回值由下一个 then 方法的第一个回调函数接收。
            return resolve(value);
        }
        try {
            if (typeof value.then === &quot;function&quot;) {
                // 如果返回值是 Promise 对象或者 thenable 对象
                // 那就只能交给它们的 then 方法来改变 promise2 的状态，以及获取相对应的状态值
                // 以下代码等同于 value.then((value) =&gt; resolve(value), (err) =&gt; reject(err))
                value.then(resolve, reject);
            } else {
                // 如果 then 不是函数，同 null 情况一样的处理逻辑。
                resolve(value);
            }
        } catch (error) {
            // 出现异常的情况下，调用 reject 函数
            // promise2 的状态变为 rejected，
            // 错误信息由下一个 then 方法的第二回调函数接收
            reject(error);
        }
    } else {
        // 如果返回值是其他对象或者原始数据类型值，同 null 情况一样的处理逻辑。
        resolve(value);
    }
}
</code></pre>
<p>这里比较难理解的应该是，返回值为 <code>Promise</code> 对象或者 <code>thenable</code> 对象的处理情况 — <code>value.then(resolve, reject)</code>，这段代码写完整一点就是 <code>value.then((value) =&gt; resolve(value), (err) =&gt; reject(err))</code>，这里 <code>then</code> 方法的回调函数中 <code>value</code> 参数值和 <code>err</code> 参数值就是 <code>Promise</code> 对象或者 <code>thenable</code> 对象内部调用 <code>resolve</code> 或者 <code>reject</code> 函数传入的参数值，再把这些值传递给 <code>promise2</code> 的 <code>resolve</code> 和 <code>reject</code> 函数，从而达到改变 <code>promise2</code> 的状态，下一个 <code>then</code> 方法的回调函数也会被调用并且接收到这些值。</p>
<p>总得来说就是，<code>promise2</code> 的状态完全由返回值（<code>Promise</code> 对象或者 <code>thenable</code> 对象）来控制。就跟以下这段代码一样：</p>
<pre><code class="language-js">const promise2 = new SelfPromise((resolve2, reject2) =&gt; {
  const value = new SelfPromise((resolve, reject) =&gt; {
    resolve(1);
  });
  value.then(
    (v) =&gt; resolve2(v),
    (err) =&gt; reject2(err)
  );
});
promise2.then((value) =&gt; {
  console.log(value);
});
// 1
</code></pre>
<p>理解清楚上述的逻辑之后，执行一下测试用例。</p>
<pre><code class="language-js">const p = new SelfPromise((resolve, reject) =&gt; {
  resolve(1);
});
</code></pre>
<pre><code class="language-js">p.then((value) =&gt; {
  console.log(value);
  return new SelfPromise((resolve) =&gt; {
    resolve(2);
  });
}).then((value) =&gt; {
  console.log(value);
});
// 1
// 2
</code></pre>
<pre><code class="language-js">p.then((value) =&gt; {
  console.log(value);
  return {
    then(resolve) {
      resolve(2);
    },
  };
}).then((value) =&gt; {
  console.log(value);
});
// 1
// 2
</code></pre>
<pre><code class="language-js">p.then((value) =&gt; {
  console.log(value);
  return 2;
  };
}).then((value) =&gt; {
  console.log(value);
});

// 1
// 2
</code></pre>
<p>令人满意的结果~</p>
<p>那如果 <code>then</code> 方法是返回自身的 <code>Promise</code> 对象该怎么办？我们来看看原生的 <code>Promise</code> 是怎么处理的：</p>
<pre><code class="language-js">const p = new Promise((resolve, reject) =&gt; {
  resolve(1);
});
const p1 = p.then((value) =&gt; {
  console.log(value);
  return p1;
});
// 1
// Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
</code></pre>
<p>报错，错误信息是：会发生 <code>Promise</code> 循环调用。</p>
<p>所以，我们需要改造一下 <code>SelfPromise</code> 的代码，来模拟这种报错的效果：</p>
<pre><code class="language-js">function resolvePromise(promise2, value, resolve, reject) {
+   // 如果 then 方法返回的是自身 Promise 对象，返回错误信息
+   if (promise2 === value) {
+       return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;'));
+   }
    if (typeof value === &quot;object&quot; || typeof value === &quot;function&quot;) {
        if (value === null) {
            return resolve(value);
        }
        try {
            if (typeof value.then === &quot;function&quot;) {
                value.then(resolve, reject);
            } else {
                resolve(value);
            }
        } catch (error) {
            reject(error);
        }
    } else {
        resolve(value);
    }
}

class SelfPromise {
  // ... 省略部分代码

    then(onFulfilled, onRejected) {
        const promise2 = new SelfPromise((resolve, reject) =&gt; {
            if (this.status === FULFILLED) {
                const v = onFulfilled(this.value);
+               // 将 promise2 传入进行判断
+               resolvePromise(promise2, v, resolve, reject);
            } else if (this.status === REJECTED) {
                const v = onRejected(this.reason);
+               // 将 promise2 传入进行判断
+               resolvePromise(promise2, v, resolve, reject);
            } else {
                this.onFulfilledCallbacks.push(onFulfilled);
                this.onRejectedCallbacks.push(onRejected);
            }
        });

        return promise2;
    }
}
</code></pre>
<p>再测试一下前面的例子，得出结果：</p>
<pre><code class="language-js">// 1
// Uncaught ReferenceError: Cannot access 'p1' before initialization
</code></pre>
<p>尴尬，错误信息完全不一样，这里根据提示可以知道，我们在 <code>p1</code> 定义之前就使用了它。实际情况也确实如此，我们是先等 <code>then</code> 方法里面的回调函数执行完毕之后，<code>then</code> 方法再返回 <code>Promise</code> 对象，但我们却在回调函数内先用了这个 <code>Promise</code> 对象，所以才报的这个错误信息。</p>
<p>那怎么办呢？其实只需要把 <code>then</code> 方法的回调函数的同步执行改为异步执行就可以了。对原生 <code>Promise</code> 足够了解的朋友应该知道，<code>then</code> 方法的回调函数是微任务，创建微任务的方式有以下这几种：</p>
<ol>
<li>
<p>浏览器环境下有 <code>MutationObserver</code>。</p>
</li>
<li>
<p><code>Promise.then()</code></p>
</li>
<li>
<p>Node 环境下有 <code>process.nextTick</code>。</p>
</li>
<li>
<p><code>queueMicrotask</code></p>
</li>
</ol>
<p>由于 <code>Promise.then</code> 是我们自己要手动实现的，<code>MutationObserver</code> 和 <code>process.nextTick</code> 又需要在专门的环境下使用，所以这里选择使用 <code>queueMicrotask</code> 来实现微任务的创建。</p>
<blockquote>
<p>可以在 MDN 文档上了解更多关于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">queueMicrotask</a> 的信息。</p>
</blockquote>
<p>我们再来改造一下 <code>SelfPromise</code> 的代码：</p>
<pre><code class="language-js">class SelfPromise {
    // ... 省略部分代码

    then(onFulfilled, onRejected) {
        const promise2 = new SelfPromise((resolve, reject) =&gt; {
+           const fulfilledMicrotask = () =&gt; {
+               queueMicrotask(() =&gt; {
+                   const v = onFulfilled(this.value);
+                   resolvePromise(promise2, v, resolve, reject);
+               });
+           };

+           const rejectedMicrotask = () =&gt; {
+               queueMicrotask(() =&gt; {
+                   const v = onRejected(this.reason);
+                   resolvePromise(promise2, v, resolve, reject);
+               });
+           };

            if (this.status === FULFILLED) {
+               // 异步执行 fulfilled 回调函数
+               fulfilledMicrotask();
            } else if (this.status === REJECTED) {
+               // 异步执行 rejected 回调函数
+               rejectedMicrotask();
            } else {
+               // 添加订阅者（异步执行的回调函数）
+               this.onFulfilledCallbacks.push(fulfilledMicrotask);
+               this.onRejectedCallbacks.push(rejectedMicrotask);
            }
        });

        return promise2;
    }
}
</code></pre>
<p>测试一下：</p>
<pre><code class="language-js">const p = new SelfPromise((resolve, reject) =&gt; {
  resolve(&quot;1&quot;);
});

// 返回自身 Promise 对象
const p1 = p.then((value) =&gt; {
  console.log(value);
  return p1;
});

// 接收错误信息
p1.then(
  (value) =&gt; {
    console.log(2);
    console.log(&quot;fulfilled&quot;, value);
  },
  (err) =&gt; {
    console.log(3);
    console.log(&quot;reject&quot;, err.message);
  }
);
// 1
// 3
// reject Chaining cycle detected for promise #&lt;Promise&gt;
</code></pre>
<p>效果终于达到了！</p>
<h3>thenable 对象的处理补充</h3>
<p>通过对 <code>then</code> 方法链式调用的实现，我们可以知道：<code>then</code> 方法的回调函数是异步执行的，属于微任务。</p>
<p>回想一下前文说到的 <code>then</code> 方法返回 <code>Promise</code> 对象或 <code>thenable</code> 对象的处理方式：</p>
<pre><code class="language-js">function resolvePromise(promise2, value, resolve, reject) {
  // 部分省略代码...
  if (typeof value === &quot;object&quot; || typeof value === &quot;function&quot;) {
    // 部分省略代码...
    try {
      if (typeof value.then === &quot;function&quot;) {
        value.then(resolve, reject);
      } else {
        resolve(value);
      }
    } catch (error) {
      reject(error);
    }
  } else {
    resolve(value);
  }
}
</code></pre>
<p>从这段代码上看，<code>Promise</code> 对象和 <code>thenable</code> 对象处理方式是一样的，但是，别忘了，<code>Promise</code> 对象的 <code>then</code> 方法的回调函数是异步执行的，而 <code>thenable</code> 对象的 <code>then</code> 方法 的回调函数可能是同步的也可能是异步的，因为 <code>thenable</code> 对象属于开发人员自定义的对象，是否异步完全由开发人员自己处理。</p>
<p>所以，为了能够让它稳定异步执行，我们需要把它放到 <code>queueMicrotask</code> 的回调函数中执行：</p>
<pre><code class="language-js">function resolvePromise(promise2, value, resolve, reject) {
    // 部分省略代码...
    if (typeof value === &quot;object&quot; || typeof value === &quot;function&quot;) {
         // 部分省略代码...
        try {
            if (typeof value.then === &quot;function&quot;) {
+               // 异步执行
+               queueMicrotask(() =&gt; {
+                   value.then(resolve, reject);
+               });
            } else {
                resolve(value);
            }
        } catch (error) {
            reject(error);
        }
    } else {
        resolve(value);
    }
}
</code></pre>
<p>给 <code>thenable</code> 对象添加上了异步执行，是不是就完美了呢？当然不是，刚刚说到了，<code>thenable</code> 对象属于开发人员自定义的对象，所以，我们还需要处理以下这三点：</p>
<ol>
<li><code>thenable</code> 对象可能被开发人员通过 <code>Object.defineProperty()</code> 或 <code>new Proxy()</code> 给 <code>then</code> 方法设置了一层代理（很多库或者框架的作者都会这么做），为了避免在调用 <code>then</code> 方法的时候，触发代理逻辑，所以需要先将函数取出来存放到一个变量上，再通过 <code>call</code> 方法进行调用，保持 <code>this</code> 指向是 <code>thenable</code> 对象。</li>
</ol>
<pre><code class="language-js">function resolvePromise(promise2, value, resolve, reject) {
    // 部分省略代码...
    if (typeof value === &quot;object&quot; || typeof value === &quot;function&quot;) {
        // 部分省略代码...
+       // 将函数取出并存到一个常量上
+       const then = value.then;
        try {
+           if (typeof then === &quot;function&quot;) {
                queueMicrotask(() =&gt; {
+                   then.call(value, resolve, reject);
                });
            } else {
                resolve(value);
            }
        } catch (error) {
            reject(error);
        }
    } else {
        resolve(value);
    }
}
</code></pre>
<ol start="2">
<li><code>thenable</code> 对象可能会同时调用 <code>resolve</code> 和 <code>reject</code> 回调函数，所以我们需要控制，只要调用其中一个回调函数，就不会再调用另一个回调函数，跟 <code>Promise</code> 内部的 <code>resolve</code> 和 <code>reject</code> 回调函数一样。</li>
</ol>
<pre><code class="language-js">function resolvePromise(promise2, value, resolve, reject) {
   // 部分省略代码...
   if (typeof value === &quot;object&quot; || typeof value === &quot;function&quot;) {
       // 部分省略代码...
+       // called 变量控制 thanable 对象只调用 resolve 或 reject 函数一次
+       let called = false;
       // 将函数取出并存到一个常量上
       const then = value.then;
       try {
           if (typeof then === &quot;function&quot;) {
               queueMicrotask(() =&gt; {
                   then.call(
                       value,
+                       (value2) =&gt; {
+                           if (called) return;
+                           // 调用了 resolve，called 设为 true，防止再一次调用 reject
+                           called = true;
+                           resolve(value);
+                       },
+                       (err) =&gt; {
+                           if (called) return;
+                           // 调用了 reject，called 设为 true，防止再一次调用 reolve
+                           called = true;
+                           reject(err);
+                       }
                   );
               });
           } else {
               resolve(value);
           }
       } catch (error) {
+          if (called) return;
+          // 错误处理，会调用 reject，called 设为 true，防止再一次调用 reolve
+          called = true;
           reject(error);
       }
   } else {
       resolve(value);
   }
}
</code></pre>
<ol start="3">
<li>在某些情况下，<code>thenable</code> 对象中的 <code>resolve</code> 回调函数很有可能传入的是 <code>Promise</code> 对象或者 <code>thenable</code> 对象，比如：</li>
</ol>
<pre><code class="language-js">const p = new Promise((resolve, reject) =&gt; {
  resolve(1);
});
const thenable = {
  then(resolve) {
    resolve(p);
  },
};
Promise.resolve(thenable).then((value) =&gt; {
  console.log(value);
});
// 1
</code></pre>
<p>所以，要递归调用 <code>resolvePromise</code> 函数处理这种情况。</p>
<pre><code class="language-js">function resolvePromise(promise2, value, resolve, reject) {
  // 部分省略代码...
  if (typeof value === &quot;object&quot; || typeof value === &quot;function&quot;) {
    // 部分省略代码...
    // called 变量控制 thanable 对象只调用 resolve 或 reject 函数一次
    let called = false;
    // 将函数取出并存到一个常量上
    const then = value.then;
    try {
      if (typeof then === &quot;function&quot;) {
        queueMicrotask(() =&gt; {
          then.call(
            value,
            (value2) =&gt; {
              if (called) return;
              // 调用了 resolve，called 设为 true，防止再一次调用 reject
              called = true;
              +(
                // value2 可能是 Promise 对象，所以需要调用 resolvePromise 函数来进行处理
                (+resolvePromise(promise2, value2, resolve, reject))
              );
            },
            (err) =&gt; {
              if (called) return;
              // 调用了 reject，called 设为 true，防止再一次调用 reolve
              called = true;
              reject(err);
            }
          );
        });
      } else {
        resolve(value);
      }
    } catch (error) {
      if (called) return;
      // 错误处理，会调用 reject，called 设为 true，防止再一次调用 reolve
      called = true;
      reject(error);
    }
  } else {
    resolve(value);
  }
}
</code></pre>
<h3>特殊的 resolve 函数参数</h3>
<p>前面说到了，<code>thenable</code> 对象中的 <code>resolve</code> 回调函数很有可能传入的是 <code>Promise</code> 对象或 <code>thenable</code> 对象，同理，<code>Promise</code> 构造函数中的 <code>resolve</code> 函数也会有这种情况。而在该情况下，<code>resolve</code> 函数变成 <code>fulfilled</code> 状态的机制完全交给参数（<code>Promise</code> 对象或 <code>thenable</code> 对象）决定，比如：</p>
<pre><code class="language-js">const p = new SelfPromise((resolve, reject) =&gt; {
  resolve(SelfPromise.reject(1));
  reject(2);
});
p.then((value) =&gt; {
  console.log(&quot;onFulfilled&quot;, value);
}).catch((err) =&gt; {
  console.log(&quot;rejected&quot;, err);
});
// rejected 1
</code></pre>
<p>处理的方式跟 <code>thenable</code> 对象一样，再次调用 <code>resolvePromise</code> 函数，只不过第一个参数是 <code>null</code> 或者 <code>undefined</code>，因为这是本次 <code>Promise</code> 对象的处理情况，而不是 <code>then</code> 方法返回的 <code>Promise</code> 对象。</p>
<p>js</p>
<p>复制代码</p>
<pre><code class="language-js">// ...省略部分代码
class SelfPromise {
    then(onFulfilled, onRejected) {
        const promise2 = new SelfPromise((resolve, reject) =&gt; {
            const fulfilledMicrotask = () =&gt; {
                queueMicrotask(() =&gt; {
                    try {
+                       if (this.value &amp;&amp; typeof this.value.then === &quot;function&quot;) {
+                           // 如果 resolve 函数传入的值是 Promise 对象或 thenable 对象
+                           resolvePromise(null, this.value, onFulfilled, onRejected);
+                       } else {
                            // 获取上一个 then 方法的 fulfilled 回调函数的返回值
                            const v = onFulfilled(this.value);
                            // 根据返回值，改变 promise2 的状态，并建立与下一个 then 方法的关系
                            resolvePromise(promise2, v, resolve, reject);
+                       }
                    } catch (error) {
                        reject(error);
                    }
                });
            };
        });
        return promise2;
    }
}
</code></pre>
<h3>错误捕获的补充</h3>
<p>我们在所有可能发生代码运行错误的地方套上 <code>try...catch</code>，然后再调用 <code>reject</code> 函数接收错误：</p>
<pre><code class="language-js">// ...省略部分代码
class SelfPromise {
    // ...省略部分代码
    constructor(executor) {
+       try {
            executor(this.resolve, this.reject);
+       } catch (error) {
+           this.reject(error);
+       }
    }
    // ...省略部分代码

    then(onFulfilled, onRejected) {
        const promise2 = new SelfPromise((resolve, reject) =&gt; {
            const fulfilledMicrotask = () =&gt; {
                queueMicrotask(() =&gt; {
+                   try {
                        const v = onFulfilled(this.value);
                        resolvePromise(promise2, v, resolve, reject);
+                   } catch (error) {
+                       reject(error);
+                   }
                });
            };

            const rejectedMicrotask = () =&gt; {
                queueMicrotask(() =&gt; {
+                   try {
                        const v = onRejected(this.reason);
                        resolvePromise(promise2, v, resolve, reject);
+                   } catch (error) {
+                       reject(error);
+                   }
                });
            };
        });

        return promise2;
    }
}
</code></pre>
<h3>then 方法的值穿透</h3>
<p>什么是 <code>then</code> 方法的值穿透？就是在 <code>then</code> 方法链式调用的情况下，如果有一个 <code>then</code> 方法不传入 <code>fulfilled</code> 回调函数，那么会一直传给下一个 <code>then</code> 方法，直到这个 <code>then</code> 方法有 <code>fulfilled</code> 回调函数。比如：</p>
<pre><code class="language-js">const p = new Promise((resolve, reject) =&gt; {
  resolve(1);
});
p.then()
  .then()
  .then((value) =&gt; console.log(value));
// 1
</code></pre>
<p>不传入 <code>rejected</code> 回调函数的情况也是一样：</p>
<pre><code class="language-js">const p = new Promise((resolve, reject) =&gt; {
  reject(2);
});
p.then((value) =&gt; console.log(&quot;fulfilled&quot;, value)).then(
  (valu1e) =&gt; console.log(&quot;fulfilled&quot;, value1),
  (reason) =&gt; console.log(&quot;rejected&quot;, reason)
);
// rejected 2
</code></pre>
<p><code>then</code> 方法的值穿透的原理是什么呢？其实主要靠 <code>then</code> 方法的链式调用来实现的，上面第一种情况的代码等同于：</p>
<pre><code class="language-js">const p = new Promise((resolve, reject) =&gt; {
  resolve(1);
});
p.then((value) =&gt; value)
  .then((value) =&gt; value)
  .then((value) =&gt; console.log(value));
</code></pre>
<p>只不过 <code>Promise</code> 内部帮我们做了这件事：如果 <code>then</code> 的第一个参数不传 <code>fulfilled</code> 回调函数或者是非函数类型的数据，那就将第一个参数的值设置为 <code>(value) =&gt; value</code>；同理第二个参数的值设置为 <code>(reason) =&gt; throw reason</code>，抛出错误，就可以调用 <code>reject</code> 函数接收错误。</p>
<p>接下来，我们自己动手实现一下：</p>
<pre><code class="language-js">// ...省略部分代码
class SelfPromise {
    // ...省略部分代码
    then(onFulfilled, onRejected) {
        const promise2 = new SelfPromise((resolve, reject) =&gt; {
+           // onFulfilled 回调函数的默认值，then 方法值传递的原理
+           onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : (value) =&gt; value;
+           // onRejected 回调函数的默认值，then 方法值传递的原理
+           onRejected = typeof onRejected === &quot;function&quot; ? onRejected : (reason) =&gt; { reject(reason); };

            // ...省略部分代码
        });
        return promise2;
    }
}
</code></pre>
<p>再运行上面的例子，你会发现结果是一模一样的。</p>
<h3>静态方法 resolve 和 reject 的实现</h3>
<h4>静态 resolve 方法的实现原理</h4>
<p>我们经常使用 <code>Promise.resolve()</code> 来生成一个状态是 <code>fulfilled</code> 的 <code>Promise</code> 对象，该方法的参数有三种：</p>
<ol>
<li>
<p>参数可以是一个 <code>Promise</code> 实例对象。</p>
<p>如果参数是 <code>Promise</code> 实例对象，那么 <code>Promise.resolve</code> 方法将原封不动地返回这个对象。</p>
</li>
<li>
<p>参数可以是一个 <code>thenable</code> 对象</p>
<p>如果参数是 <code>thenable</code> 对象，那么在 <code>Promise.resolve</code> 内部会将该对象的 <code>then</code> 方法放入微任务队列中执行。比如：</p>
</li>
</ol>
<pre><code class="language-js">const thenable = {
  then(resolve, reject) {
    console.log(1);
    resolve(2);
  },
};

Promise.resolve(thenable).then((value) =&gt; {
  console.log(value);
});

console.log(3);

// 3
// 1
// 2
</code></pre>
<ol start="3">
<li>不传参数或者参数是其他类型的数据，<code>Promise.resolve</code> 方法返回 <code>fulfilled</code> 状态的 <code>Promise</code> 实例对象。</li>
</ol>
<p>基于以上的特点，我们来实现一下它的原理：</p>
<pre><code class="language-js">// ...省略部分代码
class SelfPromise {
  // ...省略部分代码

  static resolve(param) {
    // 如果参数是 Promise 实例对象，原封不动地返回这个对象
    if (param instanceof SelfPromise) {
      return param;
    }

    return new SelfPromise((resolve, reject) =&gt; {
      if (param &amp;&amp; typeof param.then === &quot;function&quot;) {
        // 如果参数是 thenable 对象，放入微任务队列中执行
        queueMicrotask(() =&gt; {
          param.then(resolve, reject);
        });
      } else {
        // 其他情况直接调用 resolve 函数，返回 fulfilled 状态的 Promise 对象
        resolve(param);
      }
    });
  }
}
</code></pre>
<h4>静态 reject 方法的实现原理</h4>
<p><code>Promise.reject</code> 方法也是一个 <code>Promise</code> 对象，状态是 <code>rejected</code>，但它的参数类型并没有 <code>Promise.resolve</code> 方法那么复杂，只有一种情况：无论传入什么类型的数据，都只会返回 <code>rejected</code> 状态的 <code>Promise</code> 实例对象。</p>
<p>实现原理也比较简单：</p>
<pre><code class="language-js">// ...省略部分代码
class SelfPromise {
  // ...省略部分代码

  static reject(param) {
    return new SelfPromise((resolve, reject) =&gt; {
      reject(param);
    });
  }
}
</code></pre>
<h3>Promise 实例对象方法的实现</h3>
<p>Promise 实例对象的方法除了 <code>then</code> 方法，还有 <code>catch</code> 方法和 <code>finally</code> 方法，接下来，我们也手动实现一下这两个方法。</p>
<h4>catch 方法实现原理</h4>
<p><code>catch</code> 方法是用于指定发生错误时的回调函数，它其实就是对 <code>then</code> 方法的调用，想想我们之前是通过 <code>then</code> 方法的第二个参数来接收 <code>rejected</code> 状态的错误：</p>
<pre><code class="language-js">const p = new SelfPromise((resolve, reject) =&gt; {
  reject(1);
});
p.then(
  (value) =&gt; {
    console.log(&quot;fulfilled&quot;, value);
  },
  (reason) =&gt; {
    console.log(&quot;rejected&quot;, reason);
  }
);
// rejected 1
</code></pre>
<p>所以， <code>catch</code> 方法等同于 <code>then(null, onRejected)</code> 或 <code>then(undefined, onRejected)</code>，因此实现原理也很明了：</p>
<pre><code class="language-js">// ...省略部分代码
class SelfPromise {
  // ...省略部分代码
  catch(onRejected) {
    return this.then(null, onRejected);
  }
}
</code></pre>
<h4>finally 方法实现原理</h4>
<p><code>finally</code> 方法用于在 <code>Promise</code> 对象的状态是 <code>fulfilled</code> 还是 <code>rejected</code> 的情况下，都会执行的操作。注意，<code>finally</code> 方法的回调函数不接受任何参数，同时，<code>finally</code> 方法也会返回 <code>Promise</code> 对象。</p>
<p>finally 中文翻译过来是最终的意思，所以，<code>finally</code> 方法的回调函数无论返回什么值，都不会传递给后面链式调用的 <code>then</code> 方法的回调函数。并且，<code>finally</code> 方法自带值穿透特性，会将前面 <code>then</code> 方法回调函数返回的值自动传给它后面的 <code>then</code> 方法或者 <code>catch</code> 方法的回调函数。比如：</p>
<pre><code class="language-js">Promise.reject(1)
  .finally((reason) =&gt; {
    console.log(&quot;finally&quot;, reason);
    return 2;
  })
  .then((value) =&gt; {
    console.log(&quot;then&quot;, value);
  })
  .catch((reason) =&gt; {
    console.log(&quot;catch&quot;, reason);
  });
// finally undefined
// catch 1
</code></pre>
<p><code>finally</code> 本质上也是 <code>then</code> 方法的特例，由于 <code>finally</code> 方法的回调函数跟前面 <code>Promise</code> 对象的状态无关，所以，就等同于需要在 <code>then</code> 方法中的两个回调函数里调用 <code>finally</code> 方法的回调函数，并且基于 <code>finally</code> 自身的一些特性，还需要借助静态方法 <code>resolve</code> 来实现其原理：</p>
<pre><code class="language-js">// ...省略部分代码
class SelfPromise {
  // ...省略部分代码
  finally(callback) {
    return this.then(
      // 值穿透以及 callback() 返回值不会传递给后面 then 方法的原理
      (value) =&gt; SelfPromise.resolve(callback()).then(() =&gt; value),
      (reason) =&gt;
        SelfPromise.resolve(callback()).then(() =&gt; {
          throw reason;
        })
    );
  }
}
</code></pre>
<h3>静态方法 all，race，allSettled 和 any 的实现</h3>
<h4>Promise.all 的实现原理</h4>
<p><code>Promise.all</code> 方法接收一个具有 <code>Iterator</code> 接口的数据作为参数，参数中的每一个元素都是 <code>Promise</code> 对象，如果不是，就会用 <code>Promise.resolve</code> 方法将它转换为 <code>Promise</code> 对象。</p>
<p><code>Promise.all</code> 方法返回的也是一个新的 <code>Promise</code> 对象，当所有元素的状态都是 <code>fulfilled</code> 时，返回的新 <code>Promise</code> 对象的状态才是 <code>fulfilled</code>，否则就是 <code>rejected</code>。</p>
<p>如果新 <code>Promise</code> 对象的状态是 <code>fulfilled</code>，那么用 <code>then</code> 方法接收的结果是一个数组，数组中结果的顺序就是 <code>Promise.all</code> 方法参数的顺序，比如：</p>
<pre><code class="language-js">Promise.all([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]).then(
  (res) =&gt; {
    console.log(res);
  }
);
// [1, 2, 3]
</code></pre>
<p>原理实现思路：</p>
<ol>
<li>首先要判断参数的 <code>Symbol.iterator</code> 属性是否是函数，如果是，这表明参数是具有 <code>Iterator</code> 接口的数据，如果不是直接返回错误。</li>
<li>统一遍历具有 <code>Iterator</code> 接口的数据的方法，因为需要考虑到 <code>Set</code>，<code>Map</code>，<code>String</code> 等类型数据。</li>
<li>当每个 <code>Promise</code> 对象元素的状态变为 <code>fulfilled</code> 时，会将其结果存到对应索引的数组中。</li>
</ol>
<pre><code class="language-js">// ...省略部分代码
class SelfPromise {
  // ...省略部分代码
  static all(promiseIterator) {
    return new SelfPromise((resolve, reject) =&gt; {
      // 判断参数是否是具有 `Iterator` 接口的数据
      if (
        promiseIterator &amp;&amp;
        typeof promiseIterator[Symbol.iterator] === &quot;function&quot;
      ) {
        const res = []; // 结果数组
        let countRes = 0; // 记录数组中结果的个数
        const len = promiseIterator.length || promiseIterator.size;
        // 保存对应索引的结果
        function saveRes(value, index) {
          res[index] = value;
          if (++countRes === len) {
            resolve(res);
          }
        }
        // 返回迭代器对象
        const iterator = promiseIterator[Symbol.iterator]();
        // 遍历具有迭代器的数据结构，并且记录索引值
        for (
          let i = 0, iteratorRes = iterator.next();
          iteratorRes.done !== true;
          i++, iteratorRes = iterator.next()
        ) {
          SelfPromise.resolve(iteratorRes.value).then((value) =&gt; {
            // 在对应索引位置上保存结果
            saveRes(value, i);
          }, reject);
        }
      } else {
        reject(new TypeError(&quot;Arguments is not iterable&quot;));
      }
    });
  }
}
</code></pre>
<h4>Promise.race 的实现原理</h4>
<p><code>Promise.race</code> 方法接收的参数和返回值同 <code>Promise.all</code> 一样，它的特点是：哪个 <code>Promise</code> 实例对象的状态改变得快，<code>Promise.race</code> 方法最后就是什么状态，并且那个率先改变状态的 <code>Promise</code> 实例对象的返回值，会传递给 <code>Promise.race</code> 方法返回值的 <code>then</code> 方法或 <code>catch</code> 方法。</p>
<p>举个例子：</p>
<pre><code class="language-js">const p1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(1);
  }, 1000);
});
const p2 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    reject(2);
  }, 2000);
});
Promise.race([p1, p2]).then((res) =&gt; {
  console.log(res);
});
// 一秒过后，输出 1，状态为 fulfilled
</code></pre>
<p>实现原理跟 <code>Promise.all</code> 方法差不多，只不过不再需要把结果保存到数组上了。</p>
<pre><code class="language-js">// ...省略部分代码
class SelfPromise {
  // ...省略部分代码
  static race(promiseIterator) {
    return new SelfPromise((resolve, reject) =&gt; {
      if (
        promiseIterator &amp;&amp;
        typeof promiseIterator[Symbol.iterator] === &quot;function&quot;
      ) {
        // 返回迭代器对象
        const iterator = promiseIterator[Symbol.iterator]();
        // 遍历具有迭代器的数据结构
        for (
          let iteratorRes = iterator.next();
          iteratorRes.done !== true;
          iteratorRes = iterator.next()
        ) {
          // 哪个 Promise 对象状态改变得快，race 方法最后就是什么状态
          SelfPromise.resolve(iteratorRes.value).then(resolve, reject);
        }
      } else {
        reject(new TypeError(&quot;Arguments is not iterable&quot;));
      }
    });
  }
}
</code></pre>
<h4>Promise.allSettled 的实现原理</h4>
<p><code>Promise.allSettled</code> 方法接收的参数同 <code>Promise.all</code> 一样，不过 <code>Promise.allSettled</code> 方法只有在所有 <code>Promise</code> 对象都发生状态改变了（无论是 <code>fulfilled</code> 还是 <code>rejected</code>），返回的新 <code>Promise</code> 实例对象状态才会改变，并且状态总是为 <code>fulfilled</code>。</p>
<p>实现原理和 <code>Promise.all</code> 方法基本一样，只不过在每个 <code>Promise</code> 对象上的 <code>rejected</code> 状态的回调函数处理不同。</p>
<pre><code class="language-js">// ...省略部分代码
class SelfPromise {
  // ...省略部分代码
  static allSettled(promiseIterator) {
    return new SelfPromise((resolve, reject) =&gt; {
      if (
        promiseIterator &amp;&amp;
        typeof promiseIterator[Symbol.iterator] === &quot;function&quot;
      ) {
        const res = [];
        let countRes = 0;
        const len = promiseIterator.length || promiseIterator.size;
        function saveRes(value, index) {
          res[index] = value;
          if (++countRes === len) {
            resolve(res);
          }
        }
        // 返回迭代器对象
        const iterator = promiseIterator[Symbol.iterator]();
        // 遍历具有迭代器的数据结构，并且记录索引值
        for (
          let i = 0, iteratorRes = iterator.next();
          iteratorRes.done !== true;
          i++, iteratorRes = iterator.next()
        ) {
          SelfPromise.resolve(iteratorRes.value)
            .then((value) =&gt; {
              saveRes({ status: &quot;fullfilled&quot;, value }, i);
            })
            .catch((reason) =&gt; {
              saveRes({ status: &quot;rejected&quot;, reason }, i);
            });
        }
      } else {
        reject(new TypeError(&quot;Arguments is not iterable&quot;));
      }
    });
  }
}
</code></pre>
<h4>Promise.any 的实现原理</h4>
<p><code>Promise.any</code> 方法接收的参数同 <code>Promise.all</code> 一样，只要其中一个 <code>Promise</code> 实例对象的状态变成 <code>fulfilled</code>，那么<code>Promise.any</code> 方法返回的新 <code>Promise</code> 实例对象的状态就是 <code>fulfilled</code>，如果所有 <code>Promise</code> 实例对象都变成 <code>rejected</code> 状态，返回的新 <code>Promise</code> 实例对象的状态才会变成 <code>rejected</code> 状态。</p>
<p>在实现原理上，有一点是跟 <code>Promise.all</code> 方法反过来的，那就是每个 <code>Promise</code> 实例对象在 <code>rejected</code> 状态才保存对应索引位置上的结果。</p>
<pre><code class="language-js">// ...省略部分代码
class SelfPromise {
  // ...省略部分代码
  static any(promiseIterator) {
    return new SelfPromise((resolve, reject) =&gt; {
      if (
        promiseIterator &amp;&amp;
        typeof promiseIterator[Symbol.iterator] === &quot;function&quot;
      ) {
        const res = [];
        let countRes = 0;
        const len = promiseIterator.length || promiseIterator.size;
        function saveRes(reason, index) {
          res[index] = reason;
          if (++countRes === len) {
            const err = new AggregateError(res, &quot;All promises were rejected&quot;);
            reject(err);
          }
        }
        // 返回迭代器对象
        const iterator = promiseIterator[Symbol.iterator]();
        // 遍历具有迭代器的数据结构，并且记录索引值
        for (
          let i = 0, iteratorRes = iterator.next();
          iteratorRes.done !== true;
          i++, iteratorRes = iterator.next()
        ) {
          SelfPromise.resolve(iteratorRes.value).then(resolve, (reason) =&gt; {
            // 在对应索引位置上保存结果
            saveRes(reason, i);
          });
        }
      } else {
        reject(new TypeError(&quot;Arguments is not iterable&quot;));
      }
    });
  }
}
</code></pre>
<h2>总结</h2>
<p>完整版的 <code>Promise</code> 实现原理我已经放到 Github 上了 — <a href="https://github.com/EasyRo/self-promise">self-promise</a>，里面的测试也有前面说到的捉摸不透的三种  <code>Promise</code>  的输出顺序。</p>
<p>总得来说，实现 <code>Promise</code> 的原理关键在于：</p>
<ol>
<li>
<p><code>Promise</code> 运用了观察者模式，<code>then</code> 方法用于添加订阅者，<code>resolve</code> 和 <code>reject</code> 函数用于通知所有订阅者。</p>
</li>
<li>
<p><code>then</code> 方法的回调函数是异步执行的，属于微任务，所以对于 <code>thenable</code> 对象中 <code>then</code> 方法放在 <code>Promise</code> 内部执行也是异步的。</p>
</li>
<li>
<p><code>then</code> 链式调用的功能在于 <code>then</code> 方法的返回值是 <code>Promise</code> 对象，对于 <code>then</code> 方法回调函数的返回值类型要有不同的处理方式。</p>
</li>
<li>
<p>静态方法 <code>resolve</code> 和 <code>reject</code> 就是封装了创建 <code>Promise</code> 对象的创建过程；实例方法 <code>catch</code> 和 <code>finally</code> 就是对 <code>then</code> 方法的二次封装；静态方法 <code>all</code>，<code>race</code>，<code>allSettled</code>，<code>any</code> 也是利用了 <code>then</code> 方法的机制。</p>
</li>
</ol>
 
    </div>
  </div>
  <div class="article__wrapper_footer">
    <a class="article__wrapper_footer-left " href="/articles/07.html"><svg t="1713708729970" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8437" width="48" height="48"><path d="M409.272947 512.57741l403.237243 403.237243a63.349415 63.349415 0 1 1-89.622481 89.622482L274.839224 557.324726a63.349415 63.349415 0 0 1 0-89.494632L722.951633 19.717685a63.349415 63.349415 0 1 1 89.494633 89.622482L409.336872 512.57741z" p-id="8438" fill="#8a8a8a"></path></svg></a>
    <a class="article__wrapper_footer-right " href="/articles/09.html"><svg t="1713708697355" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8093" width="48" height="48"><path d="M855.123 517.004c0 8.245-3.167 15.51-9.503 21.823L402.999 981.47c-6.336 6.336-13.625 9.477-21.869 9.477s-15.51-3.142-21.845-9.477L311.8 933.96c-6.336-6.336-9.502-13.6-9.502-21.845 0-8.222 3.167-15.51 9.502-21.845l373.29-373.29-373.293-373.267c-6.336-6.336-9.502-13.6-9.502-21.845s3.167-15.533 9.503-21.869l47.484-47.484c6.336-6.336 13.6-9.502 21.845-9.502s15.533 3.167 21.869 9.503l442.621 442.622c6.334 6.334 9.503 13.625 9.503 21.869z" fill="#8a8a8a" p-id="8094"></path></svg></a>
  </div>
  <a class="article__wrapper_index" href="/articles/"><svg t="1713708857338" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9656" width="48" height="48"><path d="M549.61981 133.022476l319.683047 203.605334A70.851048 70.851048 0 0 1 902.095238 396.361143v434.883047A70.89981 70.89981 0 0 1 831.146667 902.095238h-282.819048l0.024381-218.112h-71.826286v218.087619L192.853333 902.095238A70.89981 70.89981 0 0 1 121.904762 831.24419V390.241524c0-24.527238 12.678095-47.299048 33.54819-60.220953l318.659048-197.485714a70.972952 70.972952 0 0 1 75.50781 0.487619zM828.952381 828.952381V397.214476L511.488 195.047619 195.047619 391.119238V828.952381h211.309714v-216.551619h212.187429v216.527238L828.952381 828.952381z" p-id="9657" fill="#707070"></path></svg></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
  <script src="../assets/js/articles-detail.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</body>
</html>
    