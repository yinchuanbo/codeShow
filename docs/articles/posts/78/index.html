<!DOCTYPE html>






























<html
  class="not-ready text-sm lg:text-base"
  style="--bg: "
  lang="en"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>比较运算 - 灏天阁</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="等值检测 等值检测的目的是判断两个变量是否相等，
名称 运算符 说明 相等 == 比较两个表达式，看是否相等 不等 != 比较两个表达式，看是否不相等 严格相等 === 比较两个表达式，看值是否相等并具有相同的数据类型 不严格相等 !== 比较两个表达式，看是否具有不相等的值或不同的数据类型 对于等值检测来说，最简单和最有效的方法当然是比较两个变量引用（所指向的内存地址），但这并不准确，因为我们显然会在两个不同的内存地址上存放同样的数据，例如两个相同的字符串。
因此比较引用虽然高效，但在很多时候却需要比较两个变量的值。
等值检测中“相等”的运算原则 类型 运算规则 值类型与引用类型进行比较 将引用类型的数据转换为与值类型数据相同的数据，再进行“数据等值”比较 两个值类型进行比较 转换成相同数据类型的值进行“数据等值”比较 两个引用类型进行比较 比较引用（内存地址） 上述规则中所谓的 “数据等值” 仅指对 “值类型” 的比较而言，表明比较是变量所指向的存储单元中的数据（通常指 “内存数据”）
在三种值类型（数值、布尔值、字符串）中，如果两个被比较的值类型不用，那么：
有任何一个是数字时，会将另一个转换为数字进行比较
有任何一个数布尔值时，它将被转换为数字进行比较（并且由于上一个规则的存在，所以另一个数据也将被转换为数字），
有任何一个是对象（或函数）时，将调用该对象的 valueOf() 方法将其转换为数据进行比较，且在多数情况下该值数据作为数字值处理
按照特定规则返回比较结果，例如 undefined 与 null 值总是相等的。
undefined === undefined; // true null === null; // true 可见，Js 总是尽量用数字值比较来实现等值检测，
这主要是因为 Js 内部的数据存储格式适合这一操作，同样的原因（即出于内部存储的格式的限制），字符串检测通常会存在非常大的开销。
严格来说，必须对字符串中的每一个字符串进行比较，才能判断两个字符串是否相等，
var str1 = &#34;abc&#34; &#43; &#34;def&#34;; console.log(typeof str1); // string var str2 = &#34;abcd&#34; &#43; &#34;ef&#34;; console." />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="/articles/main.min.css" />

  

  
  
  
    
  
  <link
    rel="preload"
    as="image"
    href="/articles/theme.png"
  />

  
  
  
  <link rel="preload" as="image" href="/imgs/logo.png" />
  
  

  

  
  <link rel="icon" href="/img/ico.ico" />
  <link rel="apple-touch-icon" href="/articles/apple-touch-icon.png" />
  
  <meta name="generator" content="Hugo 0.108.0">

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="比较运算" />
<meta property="og:description" content="等值检测 等值检测的目的是判断两个变量是否相等，
名称 运算符 说明 相等 == 比较两个表达式，看是否相等 不等 != 比较两个表达式，看是否不相等 严格相等 === 比较两个表达式，看值是否相等并具有相同的数据类型 不严格相等 !== 比较两个表达式，看是否具有不相等的值或不同的数据类型 对于等值检测来说，最简单和最有效的方法当然是比较两个变量引用（所指向的内存地址），但这并不准确，因为我们显然会在两个不同的内存地址上存放同样的数据，例如两个相同的字符串。
因此比较引用虽然高效，但在很多时候却需要比较两个变量的值。
等值检测中“相等”的运算原则 类型 运算规则 值类型与引用类型进行比较 将引用类型的数据转换为与值类型数据相同的数据，再进行“数据等值”比较 两个值类型进行比较 转换成相同数据类型的值进行“数据等值”比较 两个引用类型进行比较 比较引用（内存地址） 上述规则中所谓的 “数据等值” 仅指对 “值类型” 的比较而言，表明比较是变量所指向的存储单元中的数据（通常指 “内存数据”）
在三种值类型（数值、布尔值、字符串）中，如果两个被比较的值类型不用，那么：
有任何一个是数字时，会将另一个转换为数字进行比较
有任何一个数布尔值时，它将被转换为数字进行比较（并且由于上一个规则的存在，所以另一个数据也将被转换为数字），
有任何一个是对象（或函数）时，将调用该对象的 valueOf() 方法将其转换为数据进行比较，且在多数情况下该值数据作为数字值处理
按照特定规则返回比较结果，例如 undefined 与 null 值总是相等的。
undefined === undefined; // true null === null; // true 可见，Js 总是尽量用数字值比较来实现等值检测，
这主要是因为 Js 内部的数据存储格式适合这一操作，同样的原因（即出于内部存储的格式的限制），字符串检测通常会存在非常大的开销。
严格来说，必须对字符串中的每一个字符串进行比较，才能判断两个字符串是否相等，
var str1 = &#34;abc&#34; &#43; &#34;def&#34;; console.log(typeof str1); // string var str2 = &#34;abcd&#34; &#43; &#34;ef&#34;; console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/articles/posts/78/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-19T20:34:10+07:00" />
<meta property="article:modified_time" content="2023-10-19T20:34:10+07:00" />

  
  <meta itemprop="name" content="比较运算">
<meta itemprop="description" content="等值检测 等值检测的目的是判断两个变量是否相等，
名称 运算符 说明 相等 == 比较两个表达式，看是否相等 不等 != 比较两个表达式，看是否不相等 严格相等 === 比较两个表达式，看值是否相等并具有相同的数据类型 不严格相等 !== 比较两个表达式，看是否具有不相等的值或不同的数据类型 对于等值检测来说，最简单和最有效的方法当然是比较两个变量引用（所指向的内存地址），但这并不准确，因为我们显然会在两个不同的内存地址上存放同样的数据，例如两个相同的字符串。
因此比较引用虽然高效，但在很多时候却需要比较两个变量的值。
等值检测中“相等”的运算原则 类型 运算规则 值类型与引用类型进行比较 将引用类型的数据转换为与值类型数据相同的数据，再进行“数据等值”比较 两个值类型进行比较 转换成相同数据类型的值进行“数据等值”比较 两个引用类型进行比较 比较引用（内存地址） 上述规则中所谓的 “数据等值” 仅指对 “值类型” 的比较而言，表明比较是变量所指向的存储单元中的数据（通常指 “内存数据”）
在三种值类型（数值、布尔值、字符串）中，如果两个被比较的值类型不用，那么：
有任何一个是数字时，会将另一个转换为数字进行比较
有任何一个数布尔值时，它将被转换为数字进行比较（并且由于上一个规则的存在，所以另一个数据也将被转换为数字），
有任何一个是对象（或函数）时，将调用该对象的 valueOf() 方法将其转换为数据进行比较，且在多数情况下该值数据作为数字值处理
按照特定规则返回比较结果，例如 undefined 与 null 值总是相等的。
undefined === undefined; // true null === null; // true 可见，Js 总是尽量用数字值比较来实现等值检测，
这主要是因为 Js 内部的数据存储格式适合这一操作，同样的原因（即出于内部存储的格式的限制），字符串检测通常会存在非常大的开销。
严格来说，必须对字符串中的每一个字符串进行比较，才能判断两个字符串是否相等，
var str1 = &#34;abc&#34; &#43; &#34;def&#34;; console.log(typeof str1); // string var str2 = &#34;abcd&#34; &#43; &#34;ef&#34;; console."><meta itemprop="datePublished" content="2023-10-19T20:34:10+07:00" />
<meta itemprop="dateModified" content="2023-10-19T20:34:10+07:00" />
<meta itemprop="wordCount" content="391">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="比较运算"/>
<meta name="twitter:description" content="等值检测 等值检测的目的是判断两个变量是否相等，
名称 运算符 说明 相等 == 比较两个表达式，看是否相等 不等 != 比较两个表达式，看是否不相等 严格相等 === 比较两个表达式，看值是否相等并具有相同的数据类型 不严格相等 !== 比较两个表达式，看是否具有不相等的值或不同的数据类型 对于等值检测来说，最简单和最有效的方法当然是比较两个变量引用（所指向的内存地址），但这并不准确，因为我们显然会在两个不同的内存地址上存放同样的数据，例如两个相同的字符串。
因此比较引用虽然高效，但在很多时候却需要比较两个变量的值。
等值检测中“相等”的运算原则 类型 运算规则 值类型与引用类型进行比较 将引用类型的数据转换为与值类型数据相同的数据，再进行“数据等值”比较 两个值类型进行比较 转换成相同数据类型的值进行“数据等值”比较 两个引用类型进行比较 比较引用（内存地址） 上述规则中所谓的 “数据等值” 仅指对 “值类型” 的比较而言，表明比较是变量所指向的存储单元中的数据（通常指 “内存数据”）
在三种值类型（数值、布尔值、字符串）中，如果两个被比较的值类型不用，那么：
有任何一个是数字时，会将另一个转换为数字进行比较
有任何一个数布尔值时，它将被转换为数字进行比较（并且由于上一个规则的存在，所以另一个数据也将被转换为数字），
有任何一个是对象（或函数）时，将调用该对象的 valueOf() 方法将其转换为数据进行比较，且在多数情况下该值数据作为数字值处理
按照特定规则返回比较结果，例如 undefined 与 null 值总是相等的。
undefined === undefined; // true null === null; // true 可见，Js 总是尽量用数字值比较来实现等值检测，
这主要是因为 Js 内部的数据存储格式适合这一操作，同样的原因（即出于内部存储的格式的限制），字符串检测通常会存在非常大的开销。
严格来说，必须对字符串中的每一个字符串进行比较，才能判断两个字符串是否相等，
var str1 = &#34;abc&#34; &#43; &#34;def&#34;; console.log(typeof str1); // string var str2 = &#34;abcd&#34; &#43; &#34;ef&#34;; console."/>

  
  
</head>
  <body class="text-black duration-200 ease-out dark:text-white">
    
    

    
    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 dark:prose-invert"
      id="main"
    >
      

<article>
  <header class="mb-10">
    <h1 class="!my-0 pb-2.5">
      比较运算
    </h1>

    
    <div class="text-sm opacity-60">
      
      <time>Oct 19, 2023</time>
      
      
      <span class="mx-1">&middot;</span>
      <span>Yin灏</span>
    </div>
    
  </header>

  <section><h2 id="等值检测">等值检测</h2>
<p>等值检测的目的是判断两个变量是否相等，</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>相等</td>
<td>==</td>
<td>比较两个表达式，看是否相等</td>
</tr>
<tr>
<td>不等</td>
<td>!=</td>
<td>比较两个表达式，看是否不相等</td>
</tr>
<tr>
<td>严格相等</td>
<td>===</td>
<td>比较两个表达式，看值是否相等并具有相同的数据类型</td>
</tr>
<tr>
<td>不严格相等</td>
<td>!==</td>
<td>比较两个表达式，看是否具有不相等的值或不同的数据类型</td>
</tr>
</tbody>
</table>
<p>对于等值检测来说，最简单和最有效的方法当然是比较两个变量引用（所指向的内存地址），但这并不准确，因为我们显然会在两个不同的内存地址上存放同样的数据，例如两个相同的字符串。</p>
<p>因此比较引用虽然高效，但在很多时候却需要比较两个变量的值。</p>
<ul>
<li><strong>等值检测中“相等”的运算原则</strong></li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>运算规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>值类型与引用类型进行比较</td>
<td>将引用类型的数据转换为与值类型数据相同的数据，再进行“数据等值”比较</td>
</tr>
<tr>
<td>两个值类型进行比较</td>
<td>转换成相同数据类型的值进行“数据等值”比较</td>
</tr>
<tr>
<td>两个引用类型进行比较</td>
<td>比较引用（内存地址）</td>
</tr>
</tbody>
</table>
<p>上述规则中所谓的 “数据等值” 仅指对 “值类型” 的比较而言，表明比较是变量所指向的存储单元中的数据（通常指 “内存数据”）</p>
<p>在三种值类型（数值、布尔值、字符串）中，如果两个被比较的值类型不用，那么：</p>
<ol>
<li>
<p>有任何一个是数字时，会将另一个转换为数字进行比较</p>
</li>
<li>
<p>有任何一个数布尔值时，它将被转换为数字进行比较（并且由于上一个规则的存在，所以另一个数据也将被转换为数字），</p>
</li>
<li>
<p>有任何一个是对象（或函数）时，将调用该对象的 <code>valueOf()</code> 方法将其转换为数据进行比较，且在多数情况下该值数据作为数字值处理</p>
</li>
<li>
<p>按照特定规则返回比较结果，例如 undefined 与 null 值总是相等的。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span>; <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">null</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// true
</span></span></span></code></pre></div><p>可见，Js 总是尽量用<strong>数字值</strong>比较来实现等值检测，</p>
<p>这主要是因为 Js 内部的数据存储格式适合这一操作，同样的原因（即出于内部存储的格式的限制），字符串检测通常会存在非常大的开销。</p>
<p>严格来说，必须对字符串中的每一个字符串进行比较，才能判断两个字符串是否相等，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abc&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;def&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">str1</span>); <span style="color:#75715e">// string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str2</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abcd&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;ef&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">str2</span>); <span style="color:#75715e">// string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">str1</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">str2</span>); <span style="color:#75715e">// 这个运算需要进行 6 次字符比较，才能得到结果值 true
</span></span></span></code></pre></div><ul>
<li><strong>等值检测中“严格相等”的运算原则</strong></li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>运算规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>值类型与引用类型进行比较</td>
<td>必然 “不严格相等”</td>
</tr>
<tr>
<td>两个值类型进行比较</td>
<td>如果数据类型不同，则必然 “不严格相等”，否则，按等值检测中 “相等” 的运算规则进行比较</td>
</tr>
<tr>
<td>两个引用类型进行比较</td>
<td>比较引用（地址）</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abcdef&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String(<span style="color:#a6e22e">str</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj2</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String(<span style="color:#a6e22e">str</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 比较
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">obj1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">obj2</span>); <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">obj1</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">obj2</span>); <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">obj</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">obj2</span>); <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">obj</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">obj2</span>); <span style="color:#75715e">// true
</span></span></span></code></pre></div><p>在等值检测运算中存在一些特例，包括：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 1.NaN 不等于自身
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">NaN</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">NaN</span>; <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">NaN</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">NaN</span>; <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">NaN</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">NaN</span>; <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">NaN</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">NaN</span>; <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 2.符号可以转换为 true，但不等值于 true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Boolean(<span style="color:#a6e22e">Symbol</span>()); <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">!</span><span style="color:#a6e22e">Symbol</span>(); <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Symbol</span>() <span style="color:#f92672">==</span> <span style="color:#66d9ef">true</span>; <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Symbol</span>() <span style="color:#f92672">===</span> <span style="color:#66d9ef">true</span>; <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 3.即使字面量相同的引用类型，也不是严格相等的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{} <span style="color:#f92672">===</span> {}; <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">/./</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">/./</span>; <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span>() {} <span style="color:#f92672">===</span> <span style="color:#a6e22e">funciton</span>() {}; <span style="color:#75715e">// false
</span></span></span></code></pre></div><h2 id="序列检测">序列检测</h2>
<ul>
<li><strong>Js 中可进行序列检测的数据类型</strong></li>
</ul>
<table>
<thead>
<tr>
<th>可比较序列的类型</th>
<th>序列值</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>0 ~ 1</td>
</tr>
<tr>
<td>string</td>
<td>当等值检测中有任何一个数据是符号时，该符号无须进行任何数据转换，因为它总是不等值于任何其他数据</td>
</tr>
<tr>
<td>number</td>
<td>NEGATIVE_INFINITY ~ POSITIVE_INFINITY</td>
</tr>
</tbody>
</table>
<p>序列检测的含义在于比较变量在序列中的大小，</p>
<ul>
<li><strong>序列检测的运算规则</strong></li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>运算负责</th>
</tr>
</thead>
<tbody>
<tr>
<td>两个值类型进行比较</td>
<td>直接比较数据在序列中的大小</td>
</tr>
<tr>
<td>值类型与引用类型进行比较</td>
<td>将引用类型的数据转换为与值类型数据相同的数据，再进行 “序列大小” 比较</td>
</tr>
<tr>
<td>两个引用类型进行比较</td>
<td>无意义，总是返回 false</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">o1</span> <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">o2</span> <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;123&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b0</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ref</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1.值类型的比较
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">b1</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">num</span>); <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">b1</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">num</span>); <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">b1</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">b0</span>); <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 2.值类型与引用类型的比较
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 空字符串被转换为 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">num</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">ref</span>); <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 3.两个对象比较时总是返回 false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o1</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">o2</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">o1</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">o2</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">o1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">o2</span>);
</span></span></code></pre></div><ul>
<li>
<p>当两个操作数都是字符串时，使用 <code>&gt;、&gt;=、&lt;、&lt;=</code> 表示字符串序列检测</p>
</li>
<li>
<p>当任意一个操作数是非字符串时，会将字符串转换为数值来参与运算</p>
</li>
</ul>
<p>下例说明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abc&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s2</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ab&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s3</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;101&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1.两个操作数为字符串，将比较 `每个字符` 的序列值，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s1</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">s2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 2. 在将字符串 s3 转换为数值时得到 101
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s3</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">i</span>); <span style="color:#75715e">// 101 &gt; 100 true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 3. 在将字符串 s1 转换为数值时得到 NaN，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 变量 b 的布尔值为 true，转换为数值 1 参与运算
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s1</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">s1</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">s1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">b</span>); <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 4.两个 NaN 的比较，NaN 不等值也不大于或小于自身，所以下面的三个比较都为 false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s1</span> <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">NaN</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">s1</span> <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">NaN</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">s1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">NaN</span>);
</span></span></code></pre></div></section>

  
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a class="flex w-1/2 items-center p-6 pr-3 no-underline" href="/articles/posts/79/"
      ><span class="mr-1.5">←</span><span>如何使用 Promise 去控制并发请求？</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="/articles/posts/77/"
      ><span>20个JS工具函数助力高效开发</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
  style="position: relative; z-index: 10;display: none;"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="/articles/">灏天阁</a>
  </div>
  <a class="link" href="https://yinchuanbo.github.io/" rel="noopener" target="_blank"
    >Powered by YinHao</a
  >️ ▷
</footer>


    <div class="img__mask" style="display: none;">
      <img src="" alt="">
      <span class="close_btn"></span>
    </div>

    <script>
      const imgs = document.images;
      const imgMask = document.querySelector('.img__mask')
      const closeBtn = document.querySelector('.close_btn')
      for (let i = 0; i < imgs.length; i++) {
        const element = imgs[i];
        element.onclick = () => {
          const src = element.src;
          imgMask.style.display = 'flex';
          imgMask.querySelector('img').src = src;
        }
      }
      closeBtn.onclick = () => {
        imgMask.style.display = 'none';
      }
    </script>
  </body>
</html>
