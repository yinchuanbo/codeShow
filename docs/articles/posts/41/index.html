<!DOCTYPE html>






























<html
  class="not-ready text-sm lg:text-base"
  style="--bg: "
  lang="en"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>属性的 getter 和 setter - 灏天阁</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="有两种类型的对象属性。
第一种是 数据属性。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是数据属性。
第二种类型的属性是新东西。它是 访问器属性（accessor property）。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。
getter 和 setter 访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 get 和 set 表示：
let obj = { get propName() { // 当读取 obj.propName 时，getter 起作用 }, set propName(value) { // 当执行 obj.propName = value 操作时，setter 起作用 }, }; 当读取 obj.propName 时，getter 起作用，当 obj.propName 被赋值时，setter 起作用。
例如，我们有一个具有 name 和 surname 属性的对象 user：
let user = { name: &#34;John&#34;, surname: &#34;Smith&#34;, }; 现在我们想添加一个 fullName 属性，该属性值应该为 &quot;John Smith&quot;。当然，我们不想复制粘贴已有的信息，因此我们可以使用访问器来实现：" />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="/articles/main.min.css" />

  

  
  
  
    
  
  <link
    rel="preload"
    as="image"
    href="/articles/theme.png"
  />

  
  
  
  <link rel="preload" as="image" href="/imgs/logo.png" />
  
  

  

  
  <link rel="icon" href="/img/ico.ico" />
  <link rel="apple-touch-icon" href="/articles/apple-touch-icon.png" />
  
  <meta name="generator" content="Hugo 0.108.0">

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="属性的 getter 和 setter" />
<meta property="og:description" content="有两种类型的对象属性。
第一种是 数据属性。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是数据属性。
第二种类型的属性是新东西。它是 访问器属性（accessor property）。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。
getter 和 setter 访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 get 和 set 表示：
let obj = { get propName() { // 当读取 obj.propName 时，getter 起作用 }, set propName(value) { // 当执行 obj.propName = value 操作时，setter 起作用 }, }; 当读取 obj.propName 时，getter 起作用，当 obj.propName 被赋值时，setter 起作用。
例如，我们有一个具有 name 和 surname 属性的对象 user：
let user = { name: &#34;John&#34;, surname: &#34;Smith&#34;, }; 现在我们想添加一个 fullName 属性，该属性值应该为 &quot;John Smith&quot;。当然，我们不想复制粘贴已有的信息，因此我们可以使用访问器来实现：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/articles/posts/41/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-11T19:34:22+08:00" />
<meta property="article:modified_time" content="2023-09-11T19:34:22+08:00" />

  
  <meta itemprop="name" content="属性的 getter 和 setter">
<meta itemprop="description" content="有两种类型的对象属性。
第一种是 数据属性。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是数据属性。
第二种类型的属性是新东西。它是 访问器属性（accessor property）。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。
getter 和 setter 访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 get 和 set 表示：
let obj = { get propName() { // 当读取 obj.propName 时，getter 起作用 }, set propName(value) { // 当执行 obj.propName = value 操作时，setter 起作用 }, }; 当读取 obj.propName 时，getter 起作用，当 obj.propName 被赋值时，setter 起作用。
例如，我们有一个具有 name 和 surname 属性的对象 user：
let user = { name: &#34;John&#34;, surname: &#34;Smith&#34;, }; 现在我们想添加一个 fullName 属性，该属性值应该为 &quot;John Smith&quot;。当然，我们不想复制粘贴已有的信息，因此我们可以使用访问器来实现："><meta itemprop="datePublished" content="2023-09-11T19:34:22+08:00" />
<meta itemprop="dateModified" content="2023-09-11T19:34:22+08:00" />
<meta itemprop="wordCount" content="446">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="属性的 getter 和 setter"/>
<meta name="twitter:description" content="有两种类型的对象属性。
第一种是 数据属性。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是数据属性。
第二种类型的属性是新东西。它是 访问器属性（accessor property）。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。
getter 和 setter 访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 get 和 set 表示：
let obj = { get propName() { // 当读取 obj.propName 时，getter 起作用 }, set propName(value) { // 当执行 obj.propName = value 操作时，setter 起作用 }, }; 当读取 obj.propName 时，getter 起作用，当 obj.propName 被赋值时，setter 起作用。
例如，我们有一个具有 name 和 surname 属性的对象 user：
let user = { name: &#34;John&#34;, surname: &#34;Smith&#34;, }; 现在我们想添加一个 fullName 属性，该属性值应该为 &quot;John Smith&quot;。当然，我们不想复制粘贴已有的信息，因此我们可以使用访问器来实现："/>

  
  
</head>
  <body class="text-black duration-200 ease-out dark:text-white">
    
    

    
    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 dark:prose-invert"
      id="main"
    >
      

<article>
  <header class="mb-10">
    <h1 class="!my-0 pb-2.5">
      属性的 getter 和 setter
    </h1>

    
    <div class="text-sm opacity-60">
      
      <time>Sep 11, 2023</time>
      
      
      <span class="mx-1">&middot;</span>
      <span>Yin灏</span>
    </div>
    
  </header>

  <section><p>有两种类型的对象属性。</p>
<p>第一种是 <strong>数据属性</strong>。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是数据属性。</p>
<p>第二种类型的属性是新东西。它是 <strong>访问器属性（accessor property）</strong>。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。</p>
<h3 id="getter-和-setter">getter 和 setter</h3>
<p>访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 <code>get</code> 和 <code>set</code> 表示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">propName</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当读取 obj.propName 时，getter 起作用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">propName</span>(<span style="color:#a6e22e">value</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当执行 obj.propName = value 操作时，setter 起作用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  },
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>当读取 <code>obj.propName</code> 时，getter 起作用，当 <code>obj.propName</code> 被赋值时，setter 起作用。</p>
<p>例如，我们有一个具有 <code>name</code> 和 <code>surname</code> 属性的对象 <code>user</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;John&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">surname</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Smith&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>现在我们想添加一个 <code>fullName</code> 属性，该属性值应该为 <code>&quot;John Smith&quot;</code>。当然，我们不想复制粘贴已有的信息，因此我们可以使用访问器来实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;John&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">surname</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Smith&#34;</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">fullName</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">surname</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">fullName</span>); <span style="color:#75715e">// John Smith
</span></span></span></code></pre></div><p>从外表看，访问器属性看起来就像一个普通属性。这就是访问器属性的设计思想。我们不以函数的方式 <strong>调用</strong> <code>user.fullName</code>，我们正常 <strong>读取</strong> 它：getter 在幕后运行。</p>
<p>截至目前，<code>fullName</code> 只有一个 getter。如果我们尝试赋值操作 <code>user.fullName=</code>，将会出现错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">fullName</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`...`</span>;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">fullName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Test&#34;</span>; <span style="color:#75715e">// Error（属性只有一个 getter）
</span></span></span></code></pre></div><p>让我们通过为 <code>user.fullName</code> 添加一个 setter 来修复它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;John&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">surname</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Smith&#34;</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">fullName</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">surname</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">fullName</span>(<span style="color:#a6e22e">value</span>) {
</span></span><span style="display:flex;"><span>    [<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">surname</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">split</span>(<span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// set fullName 将以给定值执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">fullName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Alice Cooper&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">name</span>); <span style="color:#75715e">// Alice
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">surname</span>); <span style="color:#75715e">// Cooper
</span></span></span></code></pre></div><p>现在，我们就有一个“虚拟”属性。它是可读且可写的。</p>
<h3 id="访问器描述符">访问器描述符</h3>
<p>访问器属性的描述符与数据属性的不同。</p>
<p>对于访问器属性，没有 <code>value</code> 和 <code>writable</code>，但是有 <code>get</code> 和 <code>set</code> 函数。</p>
<p>所以访问器描述符可能有：</p>
<ul>
<li><strong><code>get</code></strong> —— 一个没有参数的函数，在读取属性时工作，</li>
<li><strong><code>set</code></strong> —— 带有一个参数的函数，当属性被设置时调用，</li>
<li><strong><code>enumerable</code></strong> —— 与数据属性的相同，</li>
<li><strong><code>configurable</code></strong> —— 与数据属性的相同。</li>
</ul>
<p>例如，要使用 <code>defineProperty</code> 创建一个 <code>fullName</code> 访问器，我们可以使用 <code>get</code> 和 <code>set</code> 来传递描述符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;John&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">surname</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Smith&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Object.<span style="color:#a6e22e">defineProperty</span>(<span style="color:#a6e22e">user</span>, <span style="color:#e6db74">&#34;fullName&#34;</span>, {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">get</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">surname</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">value</span>) {
</span></span><span style="display:flex;"><span>    [<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">surname</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">split</span>(<span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">fullName</span>); <span style="color:#75715e">// John Smith
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">user</span>) <span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">key</span>); <span style="color:#75715e">// name, surname
</span></span></span></code></pre></div><p>请注意，一个属性要么是访问器（具有 <code>get/set</code> 方法），要么是数据属性（具有 <code>value</code>），但不能两者都是。</p>
<p>如果我们试图在同一个描述符中同时提供 <code>get</code> 和 <code>value</code>，则会出现错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// Error: Invalid property descriptor.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Object.<span style="color:#a6e22e">defineProperty</span>({}, <span style="color:#e6db74">&#34;prop&#34;</span>, {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">get</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h3 id="更聪明的-gettersetter">更聪明的 getter/setter</h3>
<p>getter/setter 可以用作“真实”属性值的包装器，以便对它们进行更多的控制。</p>
<p>例如，如果我们想禁止太短的 <code>user</code> 的 name，我们可以创建一个 setter <code>name</code>，并将值存储在一个单独的属性 <code>_name</code> 中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">name</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_name</span>;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">name</span>(<span style="color:#a6e22e">value</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">&#34;Name is too short, need at least 4 characters&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Pete&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">name</span>); <span style="color:#75715e">// Pete
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; <span style="color:#75715e">// Name 太短了……
</span></span></span></code></pre></div><p>所以，name 被存储在 <code>_name</code> 属性中，并通过 getter 和 setter 进行访问。</p>
<p>从技术上讲，外部代码可以使用 <code>user._name</code> 直接访问 name。但是，这儿有一个众所周知的约定，即以下划线 <code>&quot;_&quot;</code> 开头的属性是内部属性，不应该从对象外部进行访问。</p>
<h3 id="兼容性">兼容性</h3>
<p>访问器的一大用途是，它们允许随时通过使用 getter 和 setter 替换“正常的”数据属性，来控制和调整这些属性的行为。</p>
<p>想象一下，我们开始使用数据属性 <code>name</code> 和 <code>age</code> 来实现 user 对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">User</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">age</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">age</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">john</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">User</span>(<span style="color:#e6db74">&#34;John&#34;</span>, <span style="color:#ae81ff">25</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">john</span>.<span style="color:#a6e22e">age</span>); <span style="color:#75715e">// 25
</span></span></span></code></pre></div><p>……但迟早，情况可能会发生变化。我们可能会决定存储 <code>birthday</code>，而不是 <code>age</code>，因为它更精确，更方便：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">User</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">birthday</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">birthday</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">birthday</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">john</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">User</span>(<span style="color:#e6db74">&#34;John&#34;</span>, <span style="color:#66d9ef">new</span> Date(<span style="color:#ae81ff">1992</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1</span>));
</span></span></code></pre></div><p>现在应该如何处理仍使用 <code>age</code> 属性的旧代码呢？</p>
<p>我们可以尝试找到所有这些地方并修改它们，但这会花费很多时间，而且如果其他很多人都在使用该代码，那么可能很难完成所有修改。而且，<code>user</code> 中有 <code>age</code> 是一件好事，对吧？</p>
<p>那我们就把它保留下来吧。</p>
<p>为 <code>age</code> 添加一个 getter 来解决这个问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">User</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">birthday</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">birthday</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">birthday</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 年龄是根据当前日期和生日计算得出的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Object.<span style="color:#a6e22e">defineProperty</span>(<span style="color:#66d9ef">this</span>, <span style="color:#e6db74">&#34;age&#34;</span>, {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">get</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">todayYear</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Date().<span style="color:#a6e22e">getFullYear</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">todayYear</span> <span style="color:#f92672">-</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">birthday</span>.<span style="color:#a6e22e">getFullYear</span>();
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">john</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">User</span>(<span style="color:#e6db74">&#34;John&#34;</span>, <span style="color:#66d9ef">new</span> Date(<span style="color:#ae81ff">1992</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">john</span>.<span style="color:#a6e22e">birthday</span>); <span style="color:#75715e">// birthday 是可访问的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">john</span>.<span style="color:#a6e22e">age</span>); <span style="color:#75715e">// ……age 也是可访问的
</span></span></span></code></pre></div><p>现在旧的代码也可以工作，而且我们还拥有了一个不错的附加属性。</p>
</section>

  
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a class="flex w-1/2 items-center p-6 pr-3 no-underline" href="/articles/posts/42/"
      ><span class="mr-1.5">←</span><span>原生的延迟加载支持</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="/articles/posts/40/"
      ><span>裁剪的3种方式，CSS 如何隐藏移动端的滚动条？</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
  style="position: relative; z-index: 10;display: none;"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="/articles/">灏天阁</a>
  </div>
  <a class="link" href="https://yinchuanbo.github.io/" rel="noopener" target="_blank"
    >Powered by YinHao</a
  >️ ▷
</footer>


    <div class="img__mask" style="display: none;">
      <img src="" alt="">
      <span class="close_btn"></span>
    </div>

    <script>
      const imgs = document.images;
      const imgMask = document.querySelector('.img__mask')
      const closeBtn = document.querySelector('.close_btn')
      for (let i = 0; i < imgs.length; i++) {
        const element = imgs[i];
        element.onclick = () => {
          const src = element.src;
          imgMask.style.display = 'flex';
          imgMask.querySelector('img').src = src;
        }
      }
      closeBtn.onclick = () => {
        imgMask.style.display = 'none';
      }
    </script>
  </body>
</html>
