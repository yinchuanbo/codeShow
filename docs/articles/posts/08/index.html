<!DOCTYPE html>






























<html
  class="not-ready text-sm lg:text-base"
  style="--bg: "
  lang="en"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>真正理解Promise - 灏天阁</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="Promise 的简单介绍 Promise 是用来进行异步编程的。在 Promise 出现之前，传统的异步编程靠的是监听事件和回调函数，比如：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&#34;load&#34;, function (data) { console.log(data); }); xhr.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr.send(); 这种方式有一个致命的缺点，那就是回调地狱，如果我们想在第一个请求成功返回数据之后，再发送第二个请求，那就只能在第一个请求成功的回调函数中发送，以此类推，还想再发送下一个请求时，就只能在上一个请求成功的回调函数中发送：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&#34;load&#34;, function (data) { console.log(data); const xhr1 = new XMLHttpRequest(); xhr1.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr1.send(); xhr1.addEventListener(&#34;load&#34;, function (data1) { console.log(data1); //... 发送第三个请求 }); }); xhr.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr.send(); 这种代码不仅看起来很痛苦，写起来也非常痛苦。而 Promise 就是用来解决这个问题的，可以把 Promise 理解成一个容器，里面保存着某个未来才会结束的事件的结果（也就是异步操作的结果），它有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败），状态改变只有两种：从 pending 变为 fulfilled 或从 pending 变为 rejected ，一旦状态改变，就不会再变了。一般情况下，可以分别通过 resolve 函数使得状态变为 fulfilled，reject 函数使得状态变为 rejected。" />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="/articles/main.min.css" />

  

  
  
  
    
  
  <link
    rel="preload"
    as="image"
    href="/articles/theme.png"
  />

  
  
  
  <link rel="preload" as="image" href="/imgs/logo.png" />
  
  

  

  
  <link rel="icon" href="/img/ico.ico" />
  <link rel="apple-touch-icon" href="/articles/apple-touch-icon.png" />
  
  <meta name="generator" content="Hugo 0.108.0">

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="真正理解Promise" />
<meta property="og:description" content="Promise 的简单介绍 Promise 是用来进行异步编程的。在 Promise 出现之前，传统的异步编程靠的是监听事件和回调函数，比如：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&#34;load&#34;, function (data) { console.log(data); }); xhr.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr.send(); 这种方式有一个致命的缺点，那就是回调地狱，如果我们想在第一个请求成功返回数据之后，再发送第二个请求，那就只能在第一个请求成功的回调函数中发送，以此类推，还想再发送下一个请求时，就只能在上一个请求成功的回调函数中发送：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&#34;load&#34;, function (data) { console.log(data); const xhr1 = new XMLHttpRequest(); xhr1.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr1.send(); xhr1.addEventListener(&#34;load&#34;, function (data1) { console.log(data1); //... 发送第三个请求 }); }); xhr.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr.send(); 这种代码不仅看起来很痛苦，写起来也非常痛苦。而 Promise 就是用来解决这个问题的，可以把 Promise 理解成一个容器，里面保存着某个未来才会结束的事件的结果（也就是异步操作的结果），它有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败），状态改变只有两种：从 pending 变为 fulfilled 或从 pending 变为 rejected ，一旦状态改变，就不会再变了。一般情况下，可以分别通过 resolve 函数使得状态变为 fulfilled，reject 函数使得状态变为 rejected。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/articles/posts/08/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-27T22:32:16+08:00" />
<meta property="article:modified_time" content="2023-08-27T22:32:16+08:00" />

  
  <meta itemprop="name" content="真正理解Promise">
<meta itemprop="description" content="Promise 的简单介绍 Promise 是用来进行异步编程的。在 Promise 出现之前，传统的异步编程靠的是监听事件和回调函数，比如：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&#34;load&#34;, function (data) { console.log(data); }); xhr.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr.send(); 这种方式有一个致命的缺点，那就是回调地狱，如果我们想在第一个请求成功返回数据之后，再发送第二个请求，那就只能在第一个请求成功的回调函数中发送，以此类推，还想再发送下一个请求时，就只能在上一个请求成功的回调函数中发送：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&#34;load&#34;, function (data) { console.log(data); const xhr1 = new XMLHttpRequest(); xhr1.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr1.send(); xhr1.addEventListener(&#34;load&#34;, function (data1) { console.log(data1); //... 发送第三个请求 }); }); xhr.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr.send(); 这种代码不仅看起来很痛苦，写起来也非常痛苦。而 Promise 就是用来解决这个问题的，可以把 Promise 理解成一个容器，里面保存着某个未来才会结束的事件的结果（也就是异步操作的结果），它有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败），状态改变只有两种：从 pending 变为 fulfilled 或从 pending 变为 rejected ，一旦状态改变，就不会再变了。一般情况下，可以分别通过 resolve 函数使得状态变为 fulfilled，reject 函数使得状态变为 rejected。"><meta itemprop="datePublished" content="2023-08-27T22:32:16+08:00" />
<meta itemprop="dateModified" content="2023-08-27T22:32:16+08:00" />
<meta itemprop="wordCount" content="4030">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="真正理解Promise"/>
<meta name="twitter:description" content="Promise 的简单介绍 Promise 是用来进行异步编程的。在 Promise 出现之前，传统的异步编程靠的是监听事件和回调函数，比如：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&#34;load&#34;, function (data) { console.log(data); }); xhr.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr.send(); 这种方式有一个致命的缺点，那就是回调地狱，如果我们想在第一个请求成功返回数据之后，再发送第二个请求，那就只能在第一个请求成功的回调函数中发送，以此类推，还想再发送下一个请求时，就只能在上一个请求成功的回调函数中发送：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&#34;load&#34;, function (data) { console.log(data); const xhr1 = new XMLHttpRequest(); xhr1.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr1.send(); xhr1.addEventListener(&#34;load&#34;, function (data1) { console.log(data1); //... 发送第三个请求 }); }); xhr.open(&#34;GET&#34;, &#34;http://www.example.com/&#34;); xhr.send(); 这种代码不仅看起来很痛苦，写起来也非常痛苦。而 Promise 就是用来解决这个问题的，可以把 Promise 理解成一个容器，里面保存着某个未来才会结束的事件的结果（也就是异步操作的结果），它有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败），状态改变只有两种：从 pending 变为 fulfilled 或从 pending 变为 rejected ，一旦状态改变，就不会再变了。一般情况下，可以分别通过 resolve 函数使得状态变为 fulfilled，reject 函数使得状态变为 rejected。"/>

  
  
</head>
  <body class="text-black duration-200 ease-out dark:text-white">
    
    

    
    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 dark:prose-invert"
      id="main"
    >
      

<article>
  <header class="mb-10">
    <h1 class="!my-0 pb-2.5">
      真正理解Promise
    </h1>

    
    <div class="text-sm opacity-60">
      
      <time>Aug 27, 2023</time>
      
      
      <span class="mx-1">&middot;</span>
      <span>Yin灏</span>
    </div>
    
  </header>

  <section><h2 id="promise-的简单介绍">Promise 的简单介绍</h2>
<p><code>Promise</code> 是用来进行异步编程的。在 <code>Promise</code> 出现之前，传统的异步编程靠的是监听事件和回调函数，比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">xhr</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">XMLHttpRequest</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">xhr</span>.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#34;load&#34;</span>, <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">data</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">xhr</span>.<span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#e6db74">&#34;http://www.example.com/&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">xhr</span>.<span style="color:#a6e22e">send</span>();
</span></span></code></pre></div><p>这种方式有一个致命的缺点，那就是<strong>回调地狱</strong>，如果我们想在第一个请求成功返回数据之后，再发送第二个请求，那就只能在第一个请求成功的回调函数中发送，以此类推，还想再发送下一个请求时，就只能在上一个请求成功的回调函数中发送：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">xhr</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">XMLHttpRequest</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">xhr</span>.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#34;load&#34;</span>, <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">data</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">xhr1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">XMLHttpRequest</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">xhr1</span>.<span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#e6db74">&#34;http://www.example.com/&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">xhr1</span>.<span style="color:#a6e22e">send</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">xhr1</span>.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#34;load&#34;</span>, <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">data1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//... 发送第三个请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  });
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">xhr</span>.<span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#e6db74">&#34;http://www.example.com/&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">xhr</span>.<span style="color:#a6e22e">send</span>();
</span></span></code></pre></div><p>这种代码不仅看起来很痛苦，写起来也非常痛苦。而 <code>Promise</code> 就是用来解决这个问题的，可以把 <code>Promise</code> 理解成一个容器，里面保存着某个未来才会结束的事件的结果（也就是异步操作的结果），它有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败），状态改变只有两种：从 <code>pending</code> 变为 <code>fulfilled</code> 或从 <code>pending</code> 变为 <code>rejected</code> ，一旦状态改变，就不会再变了。一般情况下，可以分别通过 <code>resolve</code> 函数使得状态变为 <code>fulfilled</code>，<code>reject</code> 函数使得状态变为 <code>rejected</code>。</p>
<p>我们使用 <code>Promise</code> 来简单改造一下上述的多个请求方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">request</span>(<span style="color:#a6e22e">url</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">xhr</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">XMLHttpRequest</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xhr</span>.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#34;load&#34;</span>, <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">data</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">resolve</span>();
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xhr</span>.<span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#a6e22e">url</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xhr</span>.<span style="color:#a6e22e">send</span>();
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 发送第一个请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">request</span>(<span style="color:#e6db74">&#34;http://www.example.com/&#34;</span>)
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 发送第二个请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">request</span>(<span style="color:#e6db74">&#34;http://www.example1.com/&#34;</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 发送第三个请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">request</span>(<span style="color:#e6db74">&#34;http://www.example2.com/&#34;</span>);
</span></span><span style="display:flex;"><span>  });
</span></span></code></pre></div><p>可以看到，有了 <code>Promise</code> 的帮助，代码完全脱离了回调地狱的嵌套，以一种流水线的方式来承接发送请求的功能，代码结构上更加清晰。</p>
<blockquote>
<p>更多关于 <code>Promise</code> 的介绍可以参考阮一峰老师的《ECMAScript 6 入门》中的 <a href="https://es6.ruanyifeng.com/#docs/promise">Promise 对象</a>。</p>
</blockquote>
<h2 id="捉摸不透的-promise-输出顺序">捉摸不透的 Promise 输出顺序</h2>
<p>简单地熟悉了 <code>Promise</code> 的功能之后，我们再来看看这三种 <code>Promise</code> 的输出顺序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">resolve</span>()
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">res</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">res</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">resolve</span>()
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 0 1 4 2 3 5
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">resolve</span>()
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">res</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">res</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">resolve</span>()
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 0 1 2 4 3 5
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">resolve</span>()
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">resolve</span>()
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 0 1 2 3 4 5
</span></span></span></code></pre></div><p>这三种 <code>Promise</code> 的输出顺序不同之处在于 4 的位置，而决定 4 的位置的关键代码在于第一个 <code>then</code> 方法回调函数的返回值。</p>
<p>尤其是第二种，大家可能比较少见，返回的是一个具有 <code>then</code> 方法的对象，这个对象被称之为 <code>thenable</code> 对象，这个对象的 <code>then</code> 方法接收两个参数，<code>resolve</code> 和 <code>reject</code>，它们都是函数，其含义和 <code>Promise</code> 构造函数中的 <code>resolve</code> 和 <code>reject</code> 一样。所以后面紧跟的链式 <code>then</code> 方法能够接收到 4 这个值。</p>
<p>要想彻底搞明白这三种 <code>Promise</code> 的输出顺序，我们就得来手动实现一遍 <code>Promise</code> 的原理，看看里面到底有啥法宝。</p>
<h2 id="promise-源码实现">Promise 源码实现</h2>
<h3 id="基础功能">基础功能</h3>
<p>万事开头难，为了让大家更有兴趣地往下看，我们先简单地实现 <code>Promise</code> 的基础功能。</p>
<p>先看一个基础功能的例子，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;fulfilled&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">reject</span>(<span style="color:#e6db74">&#34;rejected&#34;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>(
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// fulfilled
</span></span></span></code></pre></div><p>我们来分析一下这段代码都做了什么：</p>
<ol>
<li>
<p><code>Promise</code> 构造函数会传入一个回调函数作为参数，回调函数又会接收两个参数 — <code>resolve</code> 和 <code>reject</code>，它们都是函数，前文说过，<code>resolve</code> 和 <code>reject</code> 是用来改变 <code>Promise</code> 实例对象的状态。</p>
</li>
<li>
<p>一旦状态改变，就不会再改变了。状态改变之后，会调用 <code>then</code> 方法的两个回调函数中的一个，并且会相对应地接收 <code>resolve</code> 或 <code>reject</code> 函数的参数值。</p>
</li>
<li>
<p><code>fulfilled</code> 状态下会执行 <code>then</code> 方法的第一个回调函数，<code>rejected</code> 状态会执行第二个回调函数。</p>
</li>
</ol>
<p>理解了这段代码的执行逻辑之后，我们分两步来实现 <code>Promise</code> 的基础功能，分别是： <code>new Promise</code> 的实现原理和 <code>then</code> 方法的实现原理。</p>
<h4 id="new-promise-的实现原理">new Promise 的实现原理</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 定义状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">PENDING</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pending&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">FULFILLED</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;fulfilled&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">REJECTED</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rejected&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 储存状态，初始值是 pending
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PENDING</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 成功之后的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 失败之后的原因
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">reason</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">executor</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 resolve 和 reject 传给 new Promsie 的回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">executor</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">resolve</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 箭头函数可以使函数里面的 this 始终指向 Promise 实例对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">resolve</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只有状态是 pending 的情况下，才改变为 fulfilled 状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">PENDING</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">FULFILLED</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">reject</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只有状态是 pending 的情况下，才改变为 rejected 状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">PENDING</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">REJECTED</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">reason</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里有两个注意点：</p>
<ol>
<li>
<p><code>resolve</code> 和 <code>reject</code> 方法只有是在箭头函数的情况下，才能直接传递给 <code>executor</code> 函数作为参数（<code>executor(this.resolve, this.reject)</code>），这样在外部调用 <code>resolve</code> 或 <code>reject</code> 函数的时候，它们的 <code>this</code> 指向始终是 <code>Promise</code> 实例对象。那改为普通函数可不可以呢？也可以，不过就是需要使用 <code>bind</code> 方法来稳定 <code>resolve</code> 和 <code>reject</code> 的 <code>this</code> 指向 — <code>executor(this.resolve.bind(this), this.reject.bind(this))</code>。</p>
</li>
<li>
<p><code>resolve</code> 和 <code>reject</code> 只有在 <code>pending</code> 状态下，才需要改变状态和记录结果，这样就达到了 <code>Promise</code> 状态一旦改变就不能再改变的效果。</p>
</li>
</ol>
<h4 id="then-方法的实现原理">then 方法的实现原理</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">//... 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//... 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">FULFILLED</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 把 resolve 的值传递给 fulfilled 状态的回调函数，并且调用它。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">onFulfilled</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">REJECTED</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 把 reject 的值传递给 rejected 状态的回调函数，并且调用它。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">onRejected</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>then</code> 方法的实现相对来说比较简单，只需要根据状态调用相应的回调函数即可。</p>
<h3 id="基础功能的完整代码">基础功能的完整代码</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 定义状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">PENDING</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pending&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">FULFILLED</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;fulfilled&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">REJECTED</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rejected&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 储存状态，初始值是 pending
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PENDING</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 成功之后的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 失败之后的原因
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">reason</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">executor</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 resolve 和 reject 传给 new Promsie 的回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">executor</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">resolve</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 箭头函数可以函数里面的 this 始终指向 Promise 实例对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">resolve</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只有状态是 pending 的情况下，才改变为 fulfilled 状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">PENDING</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">FULFILLED</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">reject</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只有状态是 pending 的情况下，才改变为 rejected 状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">PENDING</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">REJECTED</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">reason</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">FULFILLED</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 把 resolve 的值传递给 fulfilled 状态的回调函数，并且调用它。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">onFulfilled</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">REJECTED</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 把 reject 的值传递给 rejected 状态的回调函数，并且调用它。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">onRejected</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>用一开始的 <code>Promise</code> 基础功能的例子来测试一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;fulfilled&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">reject</span>(<span style="color:#e6db74">&#34;rejected&#34;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>(
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// fulfilled
</span></span></span></code></pre></div><p>撒花~ 完美！<code>Promise</code> 基础功能的实现原理顺利完成。</p>
<h3 id="处理异步逻辑">处理异步逻辑</h3>
<p>基础版的 <code>Promise</code> 有一个很大的缺点，就是处理不了异步的情况。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;fulfilled&#34;</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>(
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不会输出任何信息
</span></span></span></code></pre></div><p>由于使用了 <code>setTimeout</code> 执行 <code>resolve</code> 函数，导致 <code>then</code> 方法执行比 <code>resolve</code> 函数要早，所以 <code>then</code> 方法在执行的时候，<code>Promise</code> 的状态是 <code>pending</code>，不会执行任何回调函数。</p>
<p>基于这种情况，我们需要在 <code>then</code> 方法中添加处理 <code>pending</code> 状态的逻辑。</p>
<p>实现思路是：如果在 <code>then</code> 方法中判断到状态是 <code>pending</code>，那么就先将两个回调函数保存起来，然后在 <code>Promise</code> 内部的 <code>resolve</code> 或 <code>reject</code> 方法中执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">//... 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>   <span style="color:#75715e">// 保存 onFulfilled 回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>   <span style="color:#a6e22e">onFulfilledCallback</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>   <span style="color:#75715e">// 保存 onRejected 回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>   <span style="color:#a6e22e">onRejectedCallback</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//... 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">PENDING</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">FULFILLED</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#75715e">// 执行 onFulfilled 回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onFulfilledCallback</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onFulfilledCallback</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">reject</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">PENDING</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">REJECTED</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">reason</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#75715e">// 执行 onRejected 回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onRejectedCallback</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onRejectedCallback</span>(<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">FULFILLED</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">onFulfilled</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">REJECTED</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">onRejected</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#75715e">// pending 状态下保存回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onFulfilledCallback</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onFulfilled</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onRejectedCallback</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onRejected</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>再运行一下用例，我们就可以打印出 <code>fulfilled</code> 信息了。</p>
<h3 id="then-方法的多次调用">then 方法的多次调用</h3>
<p>别忘了，<code>Promise</code> 实例对象的 <code>then</code> 方法是可以多次调用的，而我们现在的代码是无法做到这一点的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;fulfilled&#34;</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;1&#34;</span>, <span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;2&#34;</span>, <span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;3&#34;</span>, <span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 3 fulfilled
</span></span></span></code></pre></div><p>目前的代码只能输出 <code>3 fulfilled</code>，需要把 <code>1 fulfilled</code> 和 <code>2 fulfilled</code> 的输出补上。至于为什么只能输出 <code>3 fulfilled</code> 呢？关键在于源码当中 <code>then</code> 方法保存回调函数的方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//... 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">FULFILLED</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">onFulfilled</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">REJECTED</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">onRejected</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// pending 状态下保存回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onFulfilledCallback</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onFulfilled</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onRejectedCallback</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onRejected</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>回调函数会直接保存在 <code>this.onFulfilledCallback</code> 或 <code>this.onRejectedCallback</code> 中，这样就会导致保存的是最后一个 <code>then</code> 方法的回调函数，所以这里不能直接用两个变量来保存，而是用两个数组来保存所有的回调函数，同时 <code>Promise</code> 内部的 <code>resolve</code> 和 <code>reject</code> 方法也需要循环调用所有的回调函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">//... 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>   <span style="color:#75715e">// 保存所有的 onFulfilled 回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>   <span style="color:#a6e22e">onFulfilledCallbacks</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>   <span style="color:#75715e">// 保存所有的 onRejected 回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>   <span style="color:#a6e22e">onRejectedCallbacks</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//... 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">PENDING</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">FULFILLED</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#75715e">// 执行所有的 onFulfilled 回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onFulfilledCallbacks</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">fn</span>) =&gt; <span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">value</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">reject</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">PENDING</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">REJECTED</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">reason</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#75715e">// 执行 onRejected 回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onRejectedCallbacks</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">fn</span>) =&gt; <span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">reason</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">FULFILLED</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">onFulfilled</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">REJECTED</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">onRejected</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#75715e">// pending 状态下保存所有的回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onFulfilledCallbacks</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">onFulfilled</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onRejectedCallbacks</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">onRejected</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>细心的朋友应该发现了这其实是一个<strong>观察者模式</strong>，<code>then</code> 方法的 <code>this.onFulfilledCallbacks.push(onFulfilled)</code> 和 <code>this.onRejectedCallbacks.push(onRejected)</code> 就是在添加订阅者，而 <code>resolve</code> 和 <code>reject</code> 方法就是在通知所有的订阅者。</p>
<p>我们再运行一下用例，得出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#ae81ff">1</span> fulfilled
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span> fulfilled
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> fulfilled
</span></span></code></pre></div><p>完美，令人满意的结果！</p>
<h3 id="then-方法的链式调用">then 方法的链式调用</h3>
<p><code>Promise</code> 最核心的功能就是 <code>then</code> 方法的链式调用，这也是解决回调地狱的关键所在。就目前我们手动实现的代码来看，是不能够进行 <code>then</code> 方法的链式调用的，因为 <code>then</code> 方法没有任何返回值。</p>
<p>要想实现 <code>then</code> 方法的链式调用，<code>then</code> 方法必须返回 <code>Promise</code> 对象，并且下一个 <code>then</code> 方法的回调函数的参数会依赖上一个 <code>then</code> 方法的回调函数的返回值，这种依赖有两种情况：</p>
<ol>
<li>如果返回的是 <code>Promise</code> 实例对象，那么下一个 <code>then</code> 方法的回调函数会接收该实例对象的 <code>resolve</code> 或 <code>reject</code> 函数传入的值，比如：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// reject(2);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  });
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">then</span>(
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;fulfilled&#34;</span>, <span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">err</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;rejected&#34;</span>, <span style="color:#a6e22e">err</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// fulfilled 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果调用的是 reject(2)，那么返回的是：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// rejected 2
</span></span></span></code></pre></div><ol start="2">
<li>如果返回的是 <code>thenable</code> 对象，会和第一种情况一样：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// reject(2);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    },
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">then</span>(
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;fulfilled&#34;</span>, <span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">err</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;rejected&#34;</span>, <span style="color:#a6e22e">err</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// fulfilled 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果调用的是 reject(2)，那么返回的是：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// rejected 2
</span></span></span></code></pre></div><ol start="3">
<li>如果返回的是其他对象或者原始数据类型的值，那么下一个 <code>then</code> 方法的回调函数的参数会直接接收这个值，比如：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;fulfilled&#34;</span>, <span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// fulfilled { value: 2 }
</span></span></span></code></pre></div><p>了解了 <code>then</code> 方法链式调用的基本情况之后，我们来动手实现一下 <code>then</code> 方法的链式调用。</p>
<p>首先，让 <code>then</code> 方法返回一个 <code>Promise</code> 对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ... 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">FULFILLED</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">onFulfilled</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">REJECTED</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">onRejected</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onFulfilledCallbacks</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">onFulfilled</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onRejectedCallbacks</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">onRejected</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       });
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       <span style="color:#75715e">// 返回 Promise 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>       <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">promise2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接着，通过 <code>resolve</code> 和 <code>reject</code> 函数来改变 <code>promise2</code> 对象的状态，并且建立上一个 <code>then</code> 方法与下一个 <code>then</code> 方法的依赖关系。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ... 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">FULFILLED</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#75715e">// 获取上一个 then 方法的 fulfilled 回调函数的返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>               <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onFulfilled</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#75715e">// 根据返回值，改变 promise2 的状态，并建立与下一个 then 方法的关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>               <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">REJECTED</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#75715e">// 获取上一个 then 方法的 rejected 回调函数的返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>               <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onRejected</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#75715e">//根据返回值，改变 promise2 的状态，并建立与下一个 then 方法的关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>               <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onFulfilledCallbacks</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">onFulfilled</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onRejectedCallbacks</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">onRejected</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">promise2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;object&#34;</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果返回值是 null，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 直接调用 resolve 函数，promise2 的状态变为 fulfilled，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 返回值由下一个 then 方法的第一个回调函数接收。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 如果返回值是 Promise 对象或者 thenable 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 那就只能交给它们的 then 方法来改变 promise2 的状态，以及获取相对应的状态值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 以下代码等同于 value.then((value) =&gt; resolve(value), (err) =&gt; reject(err))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 如果 then 不是函数，同 null 情况一样的处理逻辑。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 出现异常的情况下，调用 reject 函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// promise2 的状态变为 rejected，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 错误信息由下一个 then 方法的第二回调函数接收
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果返回值是其他对象或者原始数据类型值，同 null 情况一样的处理逻辑。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里比较难理解的应该是，返回值为 <code>Promise</code> 对象或者 <code>thenable</code> 对象的处理情况 — <code>value.then(resolve, reject)</code>，这段代码写完整一点就是 <code>value.then((value) =&gt; resolve(value), (err) =&gt; reject(err))</code>，这里 <code>then</code> 方法的回调函数中 <code>value</code> 参数值和 <code>err</code> 参数值就是 <code>Promise</code> 对象或者 <code>thenable</code> 对象内部调用 <code>resolve</code> 或者 <code>reject</code> 函数传入的参数值，再把这些值传递给 <code>promise2</code> 的 <code>resolve</code> 和 <code>reject</code> 函数，从而达到改变 <code>promise2</code> 的状态，下一个 <code>then</code> 方法的回调函数也会被调用并且接收到这些值。</p>
<p>总得来说就是，<code>promise2</code> 的状态完全由返回值（<code>Promise</code> 对象或者 <code>thenable</code> 对象）来控制。就跟以下这段代码一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve2</span>, <span style="color:#a6e22e">reject2</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>(
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">v</span>) =&gt; <span style="color:#a6e22e">resolve2</span>(<span style="color:#a6e22e">v</span>),
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">err</span>) =&gt; <span style="color:#a6e22e">reject2</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">promise2</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span></code></pre></div><p>理解清楚上述的逻辑之后，执行一下测试用例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 2
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 2
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 2
</span></span></span></code></pre></div><p>令人满意的结果~</p>
<p>那如果 <code>then</code> 方法是返回自身的 <code>Promise</code> 对象该怎么办？我们来看看原生的 <code>Promise</code> 是怎么处理的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p1</span>;
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
</span></span></span></code></pre></div><p>报错，错误信息是：会发生 <code>Promise</code> 循环调用。</p>
<p>所以，我们需要改造一下 <code>SelfPromise</code> 的代码，来模拟这种报错的效果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>   <span style="color:#75715e">// 如果 then 方法返回的是自身 Promise 对象，返回错误信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>   <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">promise2</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">value</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">reject</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">TypeError</span>(<span style="color:#e6db74">&#39;Chaining cycle detected for promise #&lt;Promise&gt;&#39;</span>));
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>   }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;object&#34;</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ... 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">FULFILLED</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onFulfilled</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#75715e">// 将 promise2 传入进行判断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>               <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">REJECTED</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onRejected</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#75715e">// 将 promise2 传入进行判断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>               <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onFulfilledCallbacks</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">onFulfilled</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onRejectedCallbacks</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">onRejected</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">promise2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>再测试一下前面的例子，得出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Uncaught ReferenceError: Cannot access &#39;p1&#39; before initialization
</span></span></span></code></pre></div><p>尴尬，错误信息完全不一样，这里根据提示可以知道，我们在 <code>p1</code> 定义之前就使用了它。实际情况也确实如此，我们是先等 <code>then</code> 方法里面的回调函数执行完毕之后，<code>then</code> 方法再返回 <code>Promise</code> 对象，但我们却在回调函数内先用了这个 <code>Promise</code> 对象，所以才报的这个错误信息。</p>
<p>那怎么办呢？其实只需要把 <code>then</code> 方法的回调函数的同步执行改为异步执行就可以了。对原生 <code>Promise</code> 足够了解的朋友应该知道，<code>then</code> 方法的回调函数是微任务，创建微任务的方式有以下这几种：</p>
<ol>
<li>
<p>浏览器环境下有 <code>MutationObserver</code>。</p>
</li>
<li>
<p><code>Promise.then()</code></p>
</li>
<li>
<p>Node 环境下有 <code>process.nextTick</code>。</p>
</li>
<li>
<p><code>queueMicrotask</code></p>
</li>
</ol>
<p>由于 <code>Promise.then</code> 是我们自己要手动实现的，<code>MutationObserver</code> 和 <code>process.nextTick</code> 又需要在专门的环境下使用，所以这里选择使用 <code>queueMicrotask</code> 来实现微任务的创建。</p>
<blockquote>
<p>可以在 MDN 文档上了解更多关于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">queueMicrotask</a> 的信息。</p>
</blockquote>
<p>我们再来改造一下 <code>SelfPromise</code> 的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... 省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fulfilledMicrotask</span> <span style="color:#f92672">=</span> () =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#a6e22e">queueMicrotask</span>(() =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onFulfilled</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               });
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rejectedMicrotask</span> <span style="color:#f92672">=</span> () =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#a6e22e">queueMicrotask</span>(() =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onRejected</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               });
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">FULFILLED</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#75715e">// 异步执行 fulfilled 回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>               <span style="color:#a6e22e">fulfilledMicrotask</span>();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">REJECTED</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#75715e">// 异步执行 rejected 回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>               <span style="color:#a6e22e">rejectedMicrotask</span>();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#75715e">// 添加订阅者（异步执行的回调函数）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>               <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onFulfilledCallbacks</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">fulfilledMicrotask</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">onRejectedCallbacks</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">rejectedMicrotask</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">promise2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>测试一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;1&#34;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 返回自身 Promise 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p1</span>;
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 接收错误信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">p1</span>.<span style="color:#a6e22e">then</span>(
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;fulfilled&#34;</span>, <span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">err</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;reject&#34;</span>, <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">message</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// reject Chaining cycle detected for promise #&lt;Promise&gt;
</span></span></span></code></pre></div><p>效果终于达到了！</p>
<h3 id="thenable-对象的处理补充">thenable 对象的处理补充</h3>
<p>通过对 <code>then</code> 方法链式调用的实现，我们可以知道：<code>then</code> 方法的回调函数是异步执行的，属于微任务。</p>
<p>回想一下前文说到的 <code>then</code> 方法返回 <code>Promise</code> 对象或 <code>thenable</code> 对象的处理方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 部分省略代码...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;object&#34;</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 部分省略代码...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从这段代码上看，<code>Promise</code> 对象和 <code>thenable</code> 对象处理方式是一样的，但是，别忘了，<code>Promise</code> 对象的 <code>then</code> 方法的回调函数是异步执行的，而 <code>thenable</code> 对象的 <code>then</code> 方法 的回调函数可能是同步的也可能是异步的，因为 <code>thenable</code> 对象属于开发人员自定义的对象，是否异步完全由开发人员自己处理。</p>
<p>所以，为了能够让它稳定异步执行，我们需要把它放到 <code>queueMicrotask</code> 的回调函数中执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 部分省略代码...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;object&#34;</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">// 部分省略代码...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               <span style="color:#75715e">// 异步执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>               <span style="color:#a6e22e">queueMicrotask</span>(() =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>               });
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>给 <code>thenable</code> 对象添加上了异步执行，是不是就完美了呢？当然不是，刚刚说到了，<code>thenable</code> 对象属于开发人员自定义的对象，所以，我们还需要处理以下这三点：</p>
<ol>
<li><code>thenable</code> 对象可能被开发人员通过 <code>Object.defineProperty()</code> 或 <code>new Proxy()</code> 给 <code>then</code> 方法设置了一层代理（很多库或者框架的作者都会这么做），为了避免在调用 <code>then</code> 方法的时候，触发代理逻辑，所以需要先将函数取出来存放到一个变量上，再通过 <code>call</code> 方法进行调用，保持 <code>this</code> 指向是 <code>thenable</code> 对象。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 部分省略代码...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;object&#34;</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 部分省略代码...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>       <span style="color:#75715e">// 将函数取出并存到一个常量上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>       <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">then</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">then</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">queueMicrotask</span>(() =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   <span style="color:#a6e22e">then</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li><code>thenable</code> 对象可能会同时调用 <code>resolve</code> 和 <code>reject</code> 回调函数，所以我们需要控制，只要调用其中一个回调函数，就不会再调用另一个回调函数，跟 <code>Promise</code> 内部的 <code>resolve</code> 和 <code>reject</code> 回调函数一样。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 部分省略代码...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;object&#34;</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">// 部分省略代码...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>       <span style="color:#75715e">// called 变量控制 thanable 对象只调用 resolve 或 reject 函数一次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>       <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">called</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">// 将函数取出并存到一个常量上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">then</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>;
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">then</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>               <span style="color:#a6e22e">queueMicrotask</span>(() =&gt; {
</span></span><span style="display:flex;"><span>                   <span style="color:#a6e22e">then</span>.<span style="color:#a6e22e">call</span>(
</span></span><span style="display:flex;"><span>                       <span style="color:#a6e22e">value</span>,
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                       (<span style="color:#a6e22e">value2</span>) =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                           <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">called</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                           <span style="color:#75715e">// 调用了 resolve，called 设为 true，防止再一次调用 reject
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>                           <span style="color:#a6e22e">called</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                           <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                       },
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                       (<span style="color:#a6e22e">err</span>) =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                           <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">called</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                           <span style="color:#75715e">// 调用了 reject，called 设为 true，防止再一次调用 reolve
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>                           <span style="color:#a6e22e">called</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                           <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">err</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                       }
</span></span><span style="display:flex;"><span>                   );
</span></span><span style="display:flex;"><span>               });
</span></span><span style="display:flex;"><span>           } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>               <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>           }
</span></span><span style="display:flex;"><span>       } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>          <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">called</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>          <span style="color:#75715e">// 错误处理，会调用 reject，called 设为 true，防止再一次调用 reolve
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>          <span style="color:#a6e22e">called</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>           <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>   } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="3">
<li>在某些情况下，<code>thenable</code> 对象中的 <code>resolve</code> 回调函数很有可能传入的是 <code>Promise</code> 对象或者 <code>thenable</code> 对象，比如：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">thenable</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">p</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">thenable</span>).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span></code></pre></div><p>所以，要递归调用 <code>resolvePromise</code> 函数处理这种情况。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 部分省略代码...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;object&#34;</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 部分省略代码...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// called 变量控制 thanable 对象只调用 resolve 或 reject 函数一次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">called</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将函数取出并存到一个常量上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">then</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">then</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">queueMicrotask</span>(() =&gt; {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">then</span>.<span style="color:#a6e22e">call</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">value</span>,
</span></span><span style="display:flex;"><span>            (<span style="color:#a6e22e">value2</span>) =&gt; {
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">called</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>              <span style="color:#75715e">// 调用了 resolve，called 设为 true，防止再一次调用 reject
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>              <span style="color:#a6e22e">called</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">+</span>(
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// value2 可能是 Promise 对象，所以需要调用 resolvePromise 函数来进行处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                (<span style="color:#f92672">+</span><span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">value2</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>))
</span></span><span style="display:flex;"><span>              );
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            (<span style="color:#a6e22e">err</span>) =&gt; {
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">called</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>              <span style="color:#75715e">// 调用了 reject，called 设为 true，防止再一次调用 reolve
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>              <span style="color:#a6e22e">called</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">err</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          );
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">called</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 错误处理，会调用 reject，called 设为 true，防止再一次调用 reolve
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">called</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="特殊的-resolve-函数参数">特殊的 resolve 函数参数</h3>
<p>前面说到了，<code>thenable</code> 对象中的 <code>resolve</code> 回调函数很有可能传入的是 <code>Promise</code> 对象或 <code>thenable</code> 对象，同理，<code>Promise</code> 构造函数中的 <code>resolve</code> 函数也会有这种情况。而在该情况下，<code>resolve</code> 函数变成 <code>fulfilled</code> 状态的机制完全交给参数（<code>Promise</code> 对象或 <code>thenable</code> 对象）决定，比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">SelfPromise</span>.<span style="color:#a6e22e">reject</span>(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">reject</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;onFulfilled&#34;</span>, <span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>}).<span style="color:#66d9ef">catch</span>((<span style="color:#a6e22e">err</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;rejected&#34;</span>, <span style="color:#a6e22e">err</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#75715e">// rejected 1
</span></span></span></code></pre></div><p>处理的方式跟 <code>thenable</code> 对象一样，再次调用 <code>resolvePromise</code> 函数，只不过第一个参数是 <code>null</code> 或者 <code>undefined</code>，因为这是本次 <code>Promise</code> 对象的处理情况，而不是 <code>then</code> 方法返回的 <code>Promise</code> 对象。</p>
<p>js</p>
<p>复制代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fulfilledMicrotask</span> <span style="color:#f92672">=</span> () =&gt; {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">queueMicrotask</span>(() =&gt; {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                       <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">typeof</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                           <span style="color:#75715e">// 如果 resolve 函数传入的值是 Promise 对象或 thenable 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>                           <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                       } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e">// 获取上一个 then 方法的 fulfilled 回调函数的返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onFulfilled</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e">// 根据返回值，改变 promise2 的状态，并建立与下一个 then 方法的关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                            <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                       }
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">promise2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="错误捕获的补充">错误捕获的补充</h3>
<p>我们在所有可能发生代码运行错误的地方套上 <code>try...catch</code>，然后再调用 <code>reject</code> 函数接收错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">executor</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">executor</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">resolve</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>       }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fulfilledMicrotask</span> <span style="color:#f92672">=</span> () =&gt; {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">queueMicrotask</span>(() =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onFulfilled</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                       <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rejectedMicrotask</span> <span style="color:#f92672">=</span> () =&gt; {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">queueMicrotask</span>(() =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onRejected</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise2</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                       <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">promise2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="then-方法的值穿透">then 方法的值穿透</h3>
<p>什么是 <code>then</code> 方法的值穿透？就是在 <code>then</code> 方法链式调用的情况下，如果有一个 <code>then</code> 方法不传入 <code>fulfilled</code> 回调函数，那么会一直传给下一个 <code>then</code> 方法，直到这个 <code>then</code> 方法有 <code>fulfilled</code> 回调函数。比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>()
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>()
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span></code></pre></div><p>不传入 <code>rejected</code> 回调函数的情况也是一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">reject</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;fulfilled&#34;</span>, <span style="color:#a6e22e">value</span>)).<span style="color:#a6e22e">then</span>(
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">valu1e</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;fulfilled&#34;</span>, <span style="color:#a6e22e">value1</span>),
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">reason</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;rejected&#34;</span>, <span style="color:#a6e22e">reason</span>)
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// rejected 2
</span></span></span></code></pre></div><p><code>then</code> 方法的值穿透的原理是什么呢？其实主要靠 <code>then</code> 方法的链式调用来实现的，上面第一种情况的代码等同于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; <span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; <span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>));
</span></span></code></pre></div><p>只不过 <code>Promise</code> 内部帮我们做了这件事：如果 <code>then</code> 的第一个参数不传 <code>fulfilled</code> 回调函数或者是非函数类型的数据，那就将第一个参数的值设置为 <code>(value) =&gt; value</code>；同理第二个参数的值设置为 <code>(reason) =&gt; throw reason</code>，抛出错误，就可以调用 <code>reject</code> 函数接收错误。</p>
<p>接下来，我们自己动手实现一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">onFulfilled</span>, <span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#75715e">// onFulfilled 回调函数的默认值，then 方法值传递的原理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>           <span style="color:#a6e22e">onFulfilled</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">onFulfilled</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">onFulfilled</span> <span style="color:#f92672">:</span> (<span style="color:#a6e22e">value</span>) =&gt; <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>           <span style="color:#75715e">// onRejected 回调函数的默认值，then 方法值传递的原理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span>           <span style="color:#a6e22e">onRejected</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">onRejected</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">onRejected</span> <span style="color:#f92672">:</span> (<span style="color:#a6e22e">reason</span>) =&gt; { <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">reason</span>); };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        });
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">promise2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>再运行上面的例子，你会发现结果是一模一样的。</p>
<h3 id="静态方法-resolve-和-reject-的实现">静态方法 resolve 和 reject 的实现</h3>
<h4 id="静态-resolve-方法的实现原理">静态 resolve 方法的实现原理</h4>
<p>我们经常使用 <code>Promise.resolve()</code> 来生成一个状态是 <code>fulfilled</code> 的 <code>Promise</code> 对象，该方法的参数有三种：</p>
<ol>
<li>
<p>参数可以是一个 <code>Promise</code> 实例对象。</p>
<p>如果参数是 <code>Promise</code> 实例对象，那么 <code>Promise.resolve</code> 方法将原封不动地返回这个对象。</p>
</li>
<li>
<p>参数可以是一个 <code>thenable</code> 对象</p>
<p>如果参数是 <code>thenable</code> 对象，那么在 <code>Promise.resolve</code> 内部会将该对象的 <code>then</code> 方法放入微任务队列中执行。比如：</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">thenable</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">thenable</span>).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 2
</span></span></span></code></pre></div><ol start="3">
<li>不传参数或者参数是其他类型的数据，<code>Promise.resolve</code> 方法返回 <code>fulfilled</code> 状态的 <code>Promise</code> 实例对象。</li>
</ol>
<p>基于以上的特点，我们来实现一下它的原理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">param</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果参数是 Promise 实例对象，原封不动地返回这个对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">param</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">SelfPromise</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">param</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">param</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">param</span>.<span style="color:#a6e22e">then</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果参数是 thenable 对象，放入微任务队列中执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">queueMicrotask</span>(() =&gt; {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">param</span>.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 其他情况直接调用 resolve 函数，返回 fulfilled 状态的 Promise 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">param</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="静态-reject-方法的实现原理">静态 reject 方法的实现原理</h4>
<p><code>Promise.reject</code> 方法也是一个 <code>Promise</code> 对象，状态是 <code>rejected</code>，但它的参数类型并没有 <code>Promise.resolve</code> 方法那么复杂，只有一种情况：无论传入什么类型的数据，都只会返回 <code>rejected</code> 状态的 <code>Promise</code> 实例对象。</p>
<p>实现原理也比较简单：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">param</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">param</span>);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="promise-实例对象方法的实现">Promise 实例对象方法的实现</h3>
<p>Promise 实例对象的方法除了 <code>then</code> 方法，还有 <code>catch</code> 方法和 <code>finally</code> 方法，接下来，我们也手动实现一下这两个方法。</p>
<h4 id="catch-方法实现原理">catch 方法实现原理</h4>
<p><code>catch</code> 方法是用于指定发生错误时的回调函数，它其实就是对 <code>then</code> 方法的调用，想想我们之前是通过 <code>then</code> 方法的第二个参数来接收 <code>rejected</code> 状态的错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">reject</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>(
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;fulfilled&#34;</span>, <span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;rejected&#34;</span>, <span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// rejected 1
</span></span></span></code></pre></div><p>所以， <code>catch</code> 方法等同于 <code>then(null, onRejected)</code> 或 <code>then(undefined, onRejected)</code>，因此实现原理也很明了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">onRejected</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">null</span>, <span style="color:#a6e22e">onRejected</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="finally-方法实现原理">finally 方法实现原理</h4>
<p><code>finally</code> 方法用于在 <code>Promise</code> 对象的状态是 <code>fulfilled</code> 还是 <code>rejected</code> 的情况下，都会执行的操作。注意，<code>finally</code> 方法的回调函数不接受任何参数，同时，<code>finally</code> 方法也会返回 <code>Promise</code> 对象。</p>
<p>finally 中文翻译过来是最终的意思，所以，<code>finally</code> 方法的回调函数无论返回什么值，都不会传递给后面链式调用的 <code>then</code> 方法的回调函数。并且，<code>finally</code> 方法自带值穿透特性，会将前面 <code>then</code> 方法回调函数返回的值自动传给它后面的 <code>then</code> 方法或者 <code>catch</code> 方法的回调函数。比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>  .<span style="color:#66d9ef">finally</span>((<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;finally&#34;</span>, <span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;then&#34;</span>, <span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#66d9ef">catch</span>((<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;catch&#34;</span>, <span style="color:#a6e22e">reason</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span><span style="color:#75715e">// finally undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// catch 1
</span></span></span></code></pre></div><p><code>finally</code> 本质上也是 <code>then</code> 方法的特例，由于 <code>finally</code> 方法的回调函数跟前面 <code>Promise</code> 对象的状态无关，所以，就等同于需要在 <code>then</code> 方法中的两个回调函数里调用 <code>finally</code> 方法的回调函数，并且基于 <code>finally</code> 自身的一些特性，还需要借助静态方法 <code>resolve</code> 来实现其原理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">finally</span>(<span style="color:#a6e22e">callback</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">then</span>(
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 值穿透以及 callback() 返回值不会传递给后面 then 方法的原理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      (<span style="color:#a6e22e">value</span>) =&gt; <span style="color:#a6e22e">SelfPromise</span>.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">callback</span>()).<span style="color:#a6e22e">then</span>(() =&gt; <span style="color:#a6e22e">value</span>),
</span></span><span style="display:flex;"><span>      (<span style="color:#a6e22e">reason</span>) =&gt;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">SelfPromise</span>.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">callback</span>()).<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">throw</span> <span style="color:#a6e22e">reason</span>;
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="静态方法-allraceallsettled-和-any-的实现">静态方法 all，race，allSettled 和 any 的实现</h3>
<h4 id="promiseall-的实现原理">Promise.all 的实现原理</h4>
<p><code>Promise.all</code> 方法接收一个具有 <code>Iterator</code> 接口的数据作为参数，参数中的每一个元素都是 <code>Promise</code> 对象，如果不是，就会用 <code>Promise.resolve</code> 方法将它转换为 <code>Promise</code> 对象。</p>
<p><code>Promise.all</code> 方法返回的也是一个新的 <code>Promise</code> 对象，当所有元素的状态都是 <code>fulfilled</code> 时，返回的新 <code>Promise</code> 对象的状态才是 <code>fulfilled</code>，否则就是 <code>rejected</code>。</p>
<p>如果新 <code>Promise</code> 对象的状态是 <code>fulfilled</code>，那么用 <code>then</code> 方法接收的结果是一个数组，数组中结果的顺序就是 <code>Promise.all</code> 方法参数的顺序，比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">all</span>([Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">1</span>), Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">2</span>), Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">3</span>)]).<span style="color:#a6e22e">then</span>(
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">res</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">res</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// [1, 2, 3]
</span></span></span></code></pre></div><p>原理实现思路：</p>
<ol>
<li>首先要判断参数的 <code>Symbol.iterator</code> 属性是否是函数，如果是，这表明参数是具有 <code>Iterator</code> 接口的数据，如果不是直接返回错误。</li>
<li>统一遍历具有 <code>Iterator</code> 接口的数据的方法，因为需要考虑到 <code>Set</code>，<code>Map</code>，<code>String</code> 等类型数据。</li>
<li>当每个 <code>Promise</code> 对象元素的状态变为 <code>fulfilled</code> 时，会将其结果存到对应索引的数组中。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">all</span>(<span style="color:#a6e22e">promiseIterator</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 判断参数是否是具有 `Iterator` 接口的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">promiseIterator</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">promiseIterator</span>[<span style="color:#a6e22e">Symbol</span>.<span style="color:#a6e22e">iterator</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>
</span></span><span style="display:flex;"><span>      ) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> []; <span style="color:#75715e">// 结果数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">countRes</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 记录数组中结果的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">len</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">promiseIterator</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">promiseIterator</span>.<span style="color:#a6e22e">size</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 保存对应索引的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">saveRes</span>(<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">index</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">res</span>[<span style="color:#a6e22e">index</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span><span style="color:#a6e22e">countRes</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">len</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">res</span>);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 返回迭代器对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">iterator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">promiseIterator</span>[<span style="color:#a6e22e">Symbol</span>.<span style="color:#a6e22e">iterator</span>]();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历具有迭代器的数据结构，并且记录索引值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">iteratorRes</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">iteratorRes</span>.<span style="color:#a6e22e">done</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>, <span style="color:#a6e22e">iteratorRes</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()
</span></span><span style="display:flex;"><span>        ) {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">SelfPromise</span>.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">iteratorRes</span>.<span style="color:#a6e22e">value</span>).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 在对应索引位置上保存结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">saveRes</span>(<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>          }, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">reject</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">TypeError</span>(<span style="color:#e6db74">&#34;Arguments is not iterable&#34;</span>));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="promiserace-的实现原理">Promise.race 的实现原理</h4>
<p><code>Promise.race</code> 方法接收的参数和返回值同 <code>Promise.all</code> 一样，它的特点是：哪个 <code>Promise</code> 实例对象的状态改变得快，<code>Promise.race</code> 方法最后就是什么状态，并且那个率先改变状态的 <code>Promise</code> 实例对象的返回值，会传递给 <code>Promise.race</code> 方法返回值的 <code>then</code> 方法或 <code>catch</code> 方法。</p>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }, <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">reject</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>  }, <span style="color:#ae81ff">2000</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">race</span>([<span style="color:#a6e22e">p1</span>, <span style="color:#a6e22e">p2</span>]).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">res</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">res</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一秒过后，输出 1，状态为 fulfilled
</span></span></span></code></pre></div><p>实现原理跟 <code>Promise.all</code> 方法差不多，只不过不再需要把结果保存到数组上了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">race</span>(<span style="color:#a6e22e">promiseIterator</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">promiseIterator</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">promiseIterator</span>[<span style="color:#a6e22e">Symbol</span>.<span style="color:#a6e22e">iterator</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>
</span></span><span style="display:flex;"><span>      ) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 返回迭代器对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">iterator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">promiseIterator</span>[<span style="color:#a6e22e">Symbol</span>.<span style="color:#a6e22e">iterator</span>]();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历具有迭代器的数据结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">iteratorRes</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">iteratorRes</span>.<span style="color:#a6e22e">done</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">iteratorRes</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()
</span></span><span style="display:flex;"><span>        ) {
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 哪个 Promise 对象状态改变得快，race 方法最后就是什么状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#a6e22e">SelfPromise</span>.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">iteratorRes</span>.<span style="color:#a6e22e">value</span>).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">reject</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">TypeError</span>(<span style="color:#e6db74">&#34;Arguments is not iterable&#34;</span>));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="promiseallsettled-的实现原理">Promise.allSettled 的实现原理</h4>
<p><code>Promise.allSettled</code> 方法接收的参数同 <code>Promise.all</code> 一样，不过 <code>Promise.allSettled</code> 方法只有在所有 <code>Promise</code> 对象都发生状态改变了（无论是 <code>fulfilled</code> 还是 <code>rejected</code>），返回的新 <code>Promise</code> 实例对象状态才会改变，并且状态总是为 <code>fulfilled</code>。</p>
<p>实现原理和 <code>Promise.all</code> 方法基本一样，只不过在每个 <code>Promise</code> 对象上的 <code>rejected</code> 状态的回调函数处理不同。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">allSettled</span>(<span style="color:#a6e22e">promiseIterator</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">promiseIterator</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">promiseIterator</span>[<span style="color:#a6e22e">Symbol</span>.<span style="color:#a6e22e">iterator</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>
</span></span><span style="display:flex;"><span>      ) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">countRes</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">len</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">promiseIterator</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">promiseIterator</span>.<span style="color:#a6e22e">size</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">saveRes</span>(<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">index</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">res</span>[<span style="color:#a6e22e">index</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span><span style="color:#a6e22e">countRes</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">len</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">res</span>);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 返回迭代器对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">iterator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">promiseIterator</span>[<span style="color:#a6e22e">Symbol</span>.<span style="color:#a6e22e">iterator</span>]();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历具有迭代器的数据结构，并且记录索引值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">iteratorRes</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">iteratorRes</span>.<span style="color:#a6e22e">done</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>, <span style="color:#a6e22e">iteratorRes</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()
</span></span><span style="display:flex;"><span>        ) {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">SelfPromise</span>.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">iteratorRes</span>.<span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">saveRes</span>({ <span style="color:#a6e22e">status</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;fullfilled&#34;</span>, <span style="color:#a6e22e">value</span> }, <span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>            .<span style="color:#66d9ef">catch</span>((<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">saveRes</span>({ <span style="color:#a6e22e">status</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;rejected&#34;</span>, <span style="color:#a6e22e">reason</span> }, <span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">reject</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">TypeError</span>(<span style="color:#e6db74">&#34;Arguments is not iterable&#34;</span>));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="promiseany-的实现原理">Promise.any 的实现原理</h4>
<p><code>Promise.any</code> 方法接收的参数同 <code>Promise.all</code> 一样，只要其中一个 <code>Promise</code> 实例对象的状态变成 <code>fulfilled</code>，那么<code>Promise.any</code> 方法返回的新 <code>Promise</code> 实例对象的状态就是 <code>fulfilled</code>，如果所有 <code>Promise</code> 实例对象都变成 <code>rejected</code> 状态，返回的新 <code>Promise</code> 实例对象的状态才会变成 <code>rejected</code> 状态。</p>
<p>在实现原理上，有一点是跟 <code>Promise.all</code> 方法反过来的，那就是每个 <code>Promise</code> 实例对象在 <code>rejected</code> 状态才保存对应索引位置上的结果。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SelfPromise</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...省略部分代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">any</span>(<span style="color:#a6e22e">promiseIterator</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SelfPromise</span>((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">promiseIterator</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">promiseIterator</span>[<span style="color:#a6e22e">Symbol</span>.<span style="color:#a6e22e">iterator</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;function&#34;</span>
</span></span><span style="display:flex;"><span>      ) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">countRes</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">len</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">promiseIterator</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">promiseIterator</span>.<span style="color:#a6e22e">size</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">saveRes</span>(<span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">index</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">res</span>[<span style="color:#a6e22e">index</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">reason</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span><span style="color:#a6e22e">countRes</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">len</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">AggregateError</span>(<span style="color:#a6e22e">res</span>, <span style="color:#e6db74">&#34;All promises were rejected&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">err</span>);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 返回迭代器对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">iterator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">promiseIterator</span>[<span style="color:#a6e22e">Symbol</span>.<span style="color:#a6e22e">iterator</span>]();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历具有迭代器的数据结构，并且记录索引值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">iteratorRes</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">iteratorRes</span>.<span style="color:#a6e22e">done</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>, <span style="color:#a6e22e">iteratorRes</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()
</span></span><span style="display:flex;"><span>        ) {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">SelfPromise</span>.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">iteratorRes</span>.<span style="color:#a6e22e">value</span>).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>, (<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 在对应索引位置上保存结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">saveRes</span>(<span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>          });
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">reject</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">TypeError</span>(<span style="color:#e6db74">&#34;Arguments is not iterable&#34;</span>));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="总结">总结</h2>
<p>完整版的 <code>Promise</code> 实现原理我已经放到 Github 上了 — <a href="https://github.com/EasyRo/self-promise">self-promise</a>，里面的测试也有前面说到的捉摸不透的三种  <code>Promise</code>  的输出顺序。</p>
<p>总得来说，实现 <code>Promise</code> 的原理关键在于：</p>
<ol>
<li>
<p><code>Promise</code> 运用了观察者模式，<code>then</code> 方法用于添加订阅者，<code>resolve</code> 和 <code>reject</code> 函数用于通知所有订阅者。</p>
</li>
<li>
<p><code>then</code> 方法的回调函数是异步执行的，属于微任务，所以对于 <code>thenable</code> 对象中 <code>then</code> 方法放在 <code>Promise</code> 内部执行也是异步的。</p>
</li>
<li>
<p><code>then</code> 链式调用的功能在于 <code>then</code> 方法的返回值是 <code>Promise</code> 对象，对于 <code>then</code> 方法回调函数的返回值类型要有不同的处理方式。</p>
</li>
<li>
<p>静态方法 <code>resolve</code> 和 <code>reject</code> 就是封装了创建 <code>Promise</code> 对象的创建过程；实例方法 <code>catch</code> 和 <code>finally</code> 就是对 <code>then</code> 方法的二次封装；静态方法 <code>all</code>，<code>race</code>，<code>allSettled</code>，<code>any</code> 也是利用了 <code>then</code> 方法的机制。</p>
</li>
</ol>
</section>

  
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a class="flex w-1/2 items-center p-6 pr-3 no-underline" href="/articles/posts/09/"
      ><span class="mr-1.5">←</span><span>50个JS高级知识点</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="/articles/posts/07/"
      ><span>10种JavaScript快乐写法</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
  style="position: relative; z-index: 10;display: none;"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="/articles/">灏天阁</a>
  </div>
  <a class="link" href="https://yinchuanbo.github.io/" rel="noopener" target="_blank"
    >Powered by YinHao</a
  >️ ▷
</footer>


    <div class="img__mask" style="display: none;">
      <img src="" alt="">
      <span class="close_btn"></span>
    </div>

    <script>
      const imgs = document.images;
      const imgMask = document.querySelector('.img__mask')
      const closeBtn = document.querySelector('.close_btn')
      for (let i = 0; i < imgs.length; i++) {
        const element = imgs[i];
        element.onclick = () => {
          const src = element.src;
          imgMask.style.display = 'flex';
          imgMask.querySelector('img').src = src;
        }
      }
      closeBtn.onclick = () => {
        imgMask.style.display = 'none';
      }
    </script>
  </body>
</html>
