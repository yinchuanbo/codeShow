<!DOCTYPE html>






























<html
  class="not-ready text-sm lg:text-base"
  style="--bg: "
  lang="en"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>ES2016到ES2023新特性 - 灏天阁</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="ES2016 Array.prototype.includes() 这个方法用于检查数组是否包含特定元素，如果包含则返回 true，否则返回 false
// 我有一个水果篮子 const fruitBasket = [&#34;apple&#34;, &#34;banana&#34;, &#34;orange&#34;, &#34;grape&#34;]; // 我要检查篮子里是否有橙子 const hasOrange = fruitBasket.includes(&#34;orange&#34;); console.log(hasOrange); // 输出: true // 我还想知道篮子里是否有葡萄 const hasGrape = fruitBasket.includes(&#34;grape&#34;); console.log(hasGrape); // 输出: true // 现在我要检查篮子里是否有西瓜 const hasWatermelon = fruitBasket.includes(&#34;watermelon&#34;); console.log(hasWatermelon); // 输出: false 求幂运算符 求幂运算符： 这是一个新的算术运算符，用于计算一个数的幂
// 我要计算 2 的 3 次幂 const result = 2 ** 3; console.log(result); // 输出: 8 ES2017 Object.values / Object.entries const person = { name: &#34;Alice&#34;, age: 25, city: &#34;New York&#34;, }; const values = Object." />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="/articles/main.min.css" />

  

  
  
  
    
  
  <link
    rel="preload"
    as="image"
    href="/articles/theme.png"
  />

  
  
  
  <link rel="preload" as="image" href="/imgs/logo.png" />
  
  

  

  
  <link rel="icon" href="/img/ico.ico" />
  <link rel="apple-touch-icon" href="/articles/apple-touch-icon.png" />
  
  <meta name="generator" content="Hugo 0.108.0">

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="ES2016到ES2023新特性" />
<meta property="og:description" content="ES2016 Array.prototype.includes() 这个方法用于检查数组是否包含特定元素，如果包含则返回 true，否则返回 false
// 我有一个水果篮子 const fruitBasket = [&#34;apple&#34;, &#34;banana&#34;, &#34;orange&#34;, &#34;grape&#34;]; // 我要检查篮子里是否有橙子 const hasOrange = fruitBasket.includes(&#34;orange&#34;); console.log(hasOrange); // 输出: true // 我还想知道篮子里是否有葡萄 const hasGrape = fruitBasket.includes(&#34;grape&#34;); console.log(hasGrape); // 输出: true // 现在我要检查篮子里是否有西瓜 const hasWatermelon = fruitBasket.includes(&#34;watermelon&#34;); console.log(hasWatermelon); // 输出: false 求幂运算符 求幂运算符： 这是一个新的算术运算符，用于计算一个数的幂
// 我要计算 2 的 3 次幂 const result = 2 ** 3; console.log(result); // 输出: 8 ES2017 Object.values / Object.entries const person = { name: &#34;Alice&#34;, age: 25, city: &#34;New York&#34;, }; const values = Object." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/articles/posts/04/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-27T22:28:35+08:00" />
<meta property="article:modified_time" content="2023-08-27T22:28:35+08:00" />

  
  <meta itemprop="name" content="ES2016到ES2023新特性">
<meta itemprop="description" content="ES2016 Array.prototype.includes() 这个方法用于检查数组是否包含特定元素，如果包含则返回 true，否则返回 false
// 我有一个水果篮子 const fruitBasket = [&#34;apple&#34;, &#34;banana&#34;, &#34;orange&#34;, &#34;grape&#34;]; // 我要检查篮子里是否有橙子 const hasOrange = fruitBasket.includes(&#34;orange&#34;); console.log(hasOrange); // 输出: true // 我还想知道篮子里是否有葡萄 const hasGrape = fruitBasket.includes(&#34;grape&#34;); console.log(hasGrape); // 输出: true // 现在我要检查篮子里是否有西瓜 const hasWatermelon = fruitBasket.includes(&#34;watermelon&#34;); console.log(hasWatermelon); // 输出: false 求幂运算符 求幂运算符： 这是一个新的算术运算符，用于计算一个数的幂
// 我要计算 2 的 3 次幂 const result = 2 ** 3; console.log(result); // 输出: 8 ES2017 Object.values / Object.entries const person = { name: &#34;Alice&#34;, age: 25, city: &#34;New York&#34;, }; const values = Object."><meta itemprop="datePublished" content="2023-08-27T22:28:35+08:00" />
<meta itemprop="dateModified" content="2023-08-27T22:28:35+08:00" />
<meta itemprop="wordCount" content="1005">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ES2016到ES2023新特性"/>
<meta name="twitter:description" content="ES2016 Array.prototype.includes() 这个方法用于检查数组是否包含特定元素，如果包含则返回 true，否则返回 false
// 我有一个水果篮子 const fruitBasket = [&#34;apple&#34;, &#34;banana&#34;, &#34;orange&#34;, &#34;grape&#34;]; // 我要检查篮子里是否有橙子 const hasOrange = fruitBasket.includes(&#34;orange&#34;); console.log(hasOrange); // 输出: true // 我还想知道篮子里是否有葡萄 const hasGrape = fruitBasket.includes(&#34;grape&#34;); console.log(hasGrape); // 输出: true // 现在我要检查篮子里是否有西瓜 const hasWatermelon = fruitBasket.includes(&#34;watermelon&#34;); console.log(hasWatermelon); // 输出: false 求幂运算符 求幂运算符： 这是一个新的算术运算符，用于计算一个数的幂
// 我要计算 2 的 3 次幂 const result = 2 ** 3; console.log(result); // 输出: 8 ES2017 Object.values / Object.entries const person = { name: &#34;Alice&#34;, age: 25, city: &#34;New York&#34;, }; const values = Object."/>

  
  
</head>
  <body class="text-black duration-200 ease-out dark:text-white">
    
    

    
    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 dark:prose-invert"
      id="main"
    >
      

<article>
  <header class="mb-10">
    <h1 class="!my-0 pb-2.5">
      ES2016到ES2023新特性
    </h1>

    
    <div class="text-sm opacity-60">
      
      <time>Aug 27, 2023</time>
      
      
      <span class="mx-1">&middot;</span>
      <span>Yin灏</span>
    </div>
    
  </header>

  <section><h3 id="es2016">ES2016</h3>
<ul>
<li>Array.prototype.includes()</li>
</ul>
<blockquote>
<p>这个方法用于检查数组是否包含特定元素，如果包含则返回 true，否则返回 false</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 我有一个水果篮子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fruitBasket</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;apple&#34;</span>, <span style="color:#e6db74">&#34;banana&#34;</span>, <span style="color:#e6db74">&#34;orange&#34;</span>, <span style="color:#e6db74">&#34;grape&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 我要检查篮子里是否有橙子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasOrange</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fruitBasket</span>.<span style="color:#a6e22e">includes</span>(<span style="color:#e6db74">&#34;orange&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">hasOrange</span>); <span style="color:#75715e">// 输出: true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 我还想知道篮子里是否有葡萄
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasGrape</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fruitBasket</span>.<span style="color:#a6e22e">includes</span>(<span style="color:#e6db74">&#34;grape&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">hasGrape</span>); <span style="color:#75715e">// 输出: true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 现在我要检查篮子里是否有西瓜
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasWatermelon</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fruitBasket</span>.<span style="color:#a6e22e">includes</span>(<span style="color:#e6db74">&#34;watermelon&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">hasWatermelon</span>); <span style="color:#75715e">// 输出: false
</span></span></span></code></pre></div><ul>
<li>求幂运算符</li>
</ul>
<p>求幂运算符： 这是一个新的算术运算符，用于计算一个数的幂</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 我要计算 2 的 3 次幂
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">result</span>); <span style="color:#75715e">// 输出: 8
</span></span></span></code></pre></div><h3 id="es2017">ES2017</h3>
<ul>
<li>Object.values / Object.entries</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Alice&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">25</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">city</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;New York&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">values</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">values</span>(<span style="color:#a6e22e">person</span>); <span style="color:#75715e">// 得到：[&#39;Alice&#39;, 25, &#39;New York&#39;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">entries</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">entries</span>(<span style="color:#a6e22e">person</span>); <span style="color:#75715e">// 得到：[[&#39;name&#39;, &#39;Alice&#39;], [&#39;age&#39;, 25], [&#39;city&#39;, &#39;New York&#39;]]
</span></span></span></code></pre></div><ul>
<li>字符串补全</li>
</ul>
<p>字符串补全是一种操作，可以在一个字符串的末尾添加一些额外的字符，使得字符串的长度达到特定的目标长度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;a&#34;</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#34;1&#34;</span>)); <span style="color:#75715e">// 1111a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;a&#34;</span>.<span style="color:#a6e22e">padEnd</span>(<span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#34;2&#34;</span>)); <span style="color:#75715e">// a2222
</span></span></span></code></pre></div><ul>
<li>Async/await</li>
</ul>
<p>Async/await 是 JavaScript 中处理异步操作的一种方式，它使得在代码中处理异步任务更加直观和易读。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">simulateFetchingData</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Data fetched&#34;</span>);
</span></span><span style="display:flex;"><span>    }, <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fetchData</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Fetching data...&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">simulateFetchingData</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>); <span style="color:#75715e">// 输出: &#39;Data fetched&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fetchData</span>(); <span style="color:#75715e">// 会在一秒后输出: &#39;Data fetched&#39;
</span></span></span></code></pre></div><ul>
<li>Object.getOwnPropertyDescriptors()</li>
</ul>
<p>用于获取一个对象的所有属性的详细信息，包括属性的特性（例如可写、可枚举、可配置）以及属性的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">item</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Widget&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">color</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Blue&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">descriptors</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">getOwnPropertyDescriptors</span>(<span style="color:#a6e22e">item</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">descriptors</span>);
</span></span></code></pre></div><ul>
<li>参数列表支持尾逗号</li>
</ul>
<p>函数参数列表最后一个参数后面允许有一个逗号，这在以后添加更多参数时更方便。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">inviteFriends</span>(<span style="color:#a6e22e">friend1</span>, <span style="color:#a6e22e">friend2</span>, <span style="color:#a6e22e">friend3</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Inviting:&#34;</span>, <span style="color:#a6e22e">friend1</span>, <span style="color:#a6e22e">friend2</span>, <span style="color:#a6e22e">friend3</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">inviteFriends</span>(<span style="color:#e6db74">&#34;Alice&#34;</span>, <span style="color:#e6db74">&#34;Bob&#34;</span>, <span style="color:#e6db74">&#34;Charlie&#34;</span>); <span style="color:#75715e">// 输出: Inviting: Alice Bob Charlie
</span></span></span></code></pre></div><h3 id="es2018">ES2018</h3>
<ul>
<li>for-await-of 异步迭代</li>
</ul>
<p>异步迭代在 Node.js 中用的会多些，使用  for-await-of  遍历异步数据。例如使用 MongoDB 查询数据返回值默认为一个游标对象，避免了一次性把数据读入应用内存</p>
<p>想象你有一组需要分步完成的任务，比如读取多个文件，这些任务都是异步的。for-await-of 就像是一个一个完成这些任务，等一个任务完成后再进行下一个。</p>
<ul>
<li>Promise.finally</li>
</ul>
<p>Promise.finally 是在 Promise 结束（不管是成功还是失败）后，无论如何都会执行的代码块。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fetchData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 模拟异步操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Data fetched&#34;</span>);
</span></span><span style="display:flex;"><span>  }, <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fetchData</span>
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">data</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>))
</span></span><span style="display:flex;"><span>  .<span style="color:#66d9ef">catch</span>((<span style="color:#a6e22e">error</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#a6e22e">error</span>))
</span></span><span style="display:flex;"><span>  .<span style="color:#66d9ef">finally</span>(() =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Promise finished&#34;</span>));
</span></span></code></pre></div><ul>
<li>Rest / Spread 属性</li>
</ul>
<p>这些属性让你可以更方便地处理函数参数和对象数组的拷贝。</p>
<p>想象你要组织一场聚会，需要把朋友们的名字一个一个列出来。Rest 属性就像是把这些名字都捡起来放进一个列表，而 Spread 属性就像是把这个列表里的名字一个一个散落出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// Rest 属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">inviteFriends</span>(<span style="color:#a6e22e">host</span>, ...<span style="color:#a6e22e">guests</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">host</span><span style="color:#e6db74">}</span><span style="color:#e6db74">邀请了</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">guests</span>.<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;, &#34;</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">参加聚会`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">inviteFriends</span>(<span style="color:#e6db74">&#34;Alice&#34;</span>, <span style="color:#e6db74">&#34;Bob&#34;</span>, <span style="color:#e6db74">&#34;Charlie&#34;</span>, <span style="color:#e6db74">&#34;David&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Spread 属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oldFriends</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;John&#34;</span>, <span style="color:#e6db74">&#34;Jane&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">newFriends</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Mike&#34;</span>, <span style="color:#e6db74">&#34;Emily&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">allFriends</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">oldFriends</span>, ...<span style="color:#a6e22e">newFriends</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">allFriends</span>); <span style="color:#75715e">// 输出: [&#39;John&#39;, &#39;Jane&#39;, &#39;Mike&#39;, &#39;Emily&#39;]
</span></span></span></code></pre></div><h3 id="es2019">ES2019</h3>
<ul>
<li>可选的 catch 参数</li>
</ul>
<p>允许在 <code>catch</code> 块中省略异常参数，使得在不需要异常信息时代码更简洁。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 一些可能会发生问题的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 不需要异常参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;出错了&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Symbol.prototype.description</li>
</ul>
<p>这是一个新的方法，用于返回 Symbol 的可读描述，方便开发者理解 Symbol 的用途。</p>
<p>想象你有很多特殊的印章，每个印章代表不同的事情。description 就像是告诉你每个印章代表的是什么，让你能更好地理解这些印章。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">mySymbol</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#34;这是一个特殊的标记&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">mySymbol</span>.<span style="color:#a6e22e">description</span>); <span style="color:#75715e">// 输出: &#39;这是一个特殊的标记&#39;
</span></span></span></code></pre></div><ul>
<li>函数的 toString() 方法</li>
</ul>
<p>一个函数对象的方法，用于将函数的源代码转化成字符串。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sayHello</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Hello!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">functionString</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">sayHello</span>.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">functionString</span>); <span style="color:#75715e">// 输出函数的源代码字符串
</span></span></span></code></pre></div><ul>
<li>Object.fromEntries()</li>
</ul>
<p>一个用于将键值对列表转换成对象的方法。</p>
<p>想象你有一些标签和对应的价值，现在你想把它们整理成一个清单。Object.fromEntries() 就像是帮你把这些标签和价值整理成一个清单。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">entries</span> <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>  [<span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#e6db74">&#34;Alice&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#e6db74">&#34;age&#34;</span>, <span style="color:#ae81ff">30</span>],
</span></span><span style="display:flex;"><span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">fromEntries</span>(<span style="color:#a6e22e">entries</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>); <span style="color:#75715e">// 输出: { name: &#39;Alice&#39;, age: 30 }
</span></span></span></code></pre></div><ul>
<li>消除前后空格</li>
</ul>
<p>一种字符串处理方法，用于去除字符串开头和结尾的空格。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">messyText</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;   这里有很多空格   &#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">cleanText</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">messyText</span>.<span style="color:#a6e22e">trim</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">cleanText</span>); <span style="color:#75715e">// 输出: &#39;这里有很多空格&#39;
</span></span></span></code></pre></div><ul>
<li>数组 flat()、flatMap()</li>
</ul>
<p>数组的两个方法，用于将多维数组拉平为一维数组，以及在拉平的同时对数组元素进行操作。Infinity 是 flat 对数组深度展开，flatMap 则只能展开一层。</p>
<p>想象你有一些叠在一起的盒子，里面还有更小的盒子。flat() 就像是把所有的盒子都打开，把里面的东西拿出来放在一起。而 flatMap() 就像是在拿出东西的同时，还可以对它们做些处理。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">nestedArray</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, [<span style="color:#ae81ff">2</span>, [<span style="color:#ae81ff">3</span>, [<span style="color:#ae81ff">4</span>]]]];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">flattenedArray</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nestedArray</span>.<span style="color:#a6e22e">flat</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">flattenedArray</span>); <span style="color:#75715e">// 输出: [1, 2, [3, [4]]]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">flattened</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nestedArray</span>.<span style="color:#a6e22e">flat</span>(<span style="color:#66d9ef">Infinity</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">flattenedArray</span>); <span style="color:#75715e">// 输出: [1, 2, 3, 4]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">doubledArray</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nestedArray</span>.<span style="color:#a6e22e">flatMap</span>((<span style="color:#a6e22e">value</span>) =&gt; <span style="color:#a6e22e">value</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">doubledArray</span>); <span style="color:#75715e">// 输出: [2, 4, 6, [4]]
</span></span></span></code></pre></div><h3 id="es2020">ES2020</h3>
<ul>
<li>MatchAll 匹配所有</li>
</ul>
<p>字符串的新方法，可以通过正则表达式来查找字符串中的所有匹配项。</p>
<p>想象你有一篇文章，想找出所有包含某个特定单词的地方。matchAll 就像是帮你在文章中找到所有这样的地方</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello world, hello universe&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">regex</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">/hello/gi</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">match</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">matchAll</span>(<span style="color:#a6e22e">regex</span>)) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">match</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>模块新特性</li>
</ul>
<p>import 动态导入 动态导入意思是当你需要该模块时才会进行加载，返回的是一个 Promise​ 对象。只有在 ES Modules 模块规范下才支持。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// index-a.mjs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">hello</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`hello JavaScript`</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// index-b.mjs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span>(<span style="color:#e6db74">&#34;./index-a.mjs&#34;</span>).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">module</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">module</span>.<span style="color:#66d9ef">default</span>.<span style="color:#a6e22e">hello</span>(); <span style="color:#75715e">// hello JavaScript
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>});
</span></span></code></pre></div><p>import.meta​ 指当前模块的元数据。一个广泛支持的属性是 import.meta.url，以字符串形式输出当前模块的文件路径。</p>
<ul>
<li>Promise.allSettled</li>
</ul>
<p>这是 Promise 的一个新方法，可以等待多个 Promise 都完成（无论成功还是失败）后再继续。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promises</span> <span style="color:#f92672">=</span> [Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Success!&#34;</span>), Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#e6db74">&#34;Error!&#34;</span>)];
</span></span><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">allSettled</span>(<span style="color:#a6e22e">promises</span>).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">results</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">results</span>));
</span></span></code></pre></div><ul>
<li>全局对象</li>
</ul>
<p>JavaScript 可以运行在不同的环境，浏览器为 window、Node.js 为 global。为了能够统一全局环境变量，引入了 globalThis。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>window <span style="color:#f92672">===</span> <span style="color:#a6e22e">globalThis</span>; <span style="color:#75715e">// 浏览器环境
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">global</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">globalThis</span>; <span style="color:#75715e">// Node.js 环境
</span></span></span></code></pre></div><ul>
<li>for-in 机制</li>
</ul>
<p>这是对 <code>for-in</code> 循环的更新，用于更好地遍历对象的可枚举属性。 想象你要看一个箱子里有什么东西，但有些东西可能隐藏得很深。<code>for-in</code> 机制就像是帮你把箱子里所有东西都拿出来看一遍。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">a</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">b</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">c</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">obj</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">obj</span>[<span style="color:#a6e22e">key</span>]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>可选链</li>
</ul>
<p>这是一个新的语法，用于在访问对象的属性时，避免因为属性不存在而导致错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Alice&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">contact</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">phone</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;123-456-7890&#34;</span>,
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">phoneNumber</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">person</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">contact</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">phone</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">phoneNumber</span>); <span style="color:#75715e">// 输出: &#39;123-456-7890&#39;
</span></span></span></code></pre></div><ul>
<li>空值合并</li>
</ul>
<p>这是一种新的语法，用于给变量赋值时，如果变量的值为 null 或 undefined，就使用默认值。</p>
<p>想象你要吃冰淇淋，但是不知道哪种口味有，所以你要确保有一种口味可以选。空值合并就像是在选择口味时，如果没有你喜欢的，就选择默认的口味。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">favoriteIceCream</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">iceCreamChoice</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">favoriteIceCream</span> <span style="color:#f92672">??</span> <span style="color:#e6db74">&#34;Vanilla&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">iceCreamChoice</span>); <span style="color:#75715e">// 输出: &#39;Vanilla&#39;
</span></span></span></code></pre></div><h3 id="es2021">ES2021</h3>
<ul>
<li>String.prototype.replaceAll</li>
</ul>
<p>字符串的一个新方法，用于替换所有匹配的子字符串。</p>
<p>想象你在纸上写了一句话，但是有一些词你想换成其他词。replaceAll 就像是帮你把所有要换的词都换掉。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">originalText</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello world, hello universe&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">newText</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">originalText</span>.<span style="color:#a6e22e">replaceAll</span>(<span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;hi&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">newText</span>); <span style="color:#75715e">// 输出: &#39;Hi world, hi universe&#39;
</span></span></span></code></pre></div><ul>
<li>Promise.any</li>
</ul>
<p><code>Promise.any</code> 是 <code>Promise</code> 的一个新方法，用于在一组 Promise 中，只要有一个成功就返回，不必等待所有 Promise 都结束。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promises</span> <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>  Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#e6db74">&#34;Error 1&#34;</span>),
</span></span><span style="display:flex;"><span>  Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Success!&#34;</span>),
</span></span><span style="display:flex;"><span>  Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#e6db74">&#34;Error 2&#34;</span>),
</span></span><span style="display:flex;"><span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">any</span>(<span style="color:#a6e22e">promises</span>)
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">result</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">result</span>))
</span></span><span style="display:flex;"><span>  .<span style="color:#66d9ef">catch</span>((<span style="color:#a6e22e">errors</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#a6e22e">errors</span>));
</span></span></code></pre></div><ul>
<li>数字分隔符</li>
</ul>
<p>分隔符是一种在数字中插入下划线，以便更易读的语法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">largeNumber</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1_000_000</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">largeNumber</span>); <span style="color:#75715e">// 输出: 1000000
</span></span></span></code></pre></div><ul>
<li>逻辑赋值运算符</li>
</ul>
<p>结合了逻辑运算符 &amp;&amp;、||、??​ 和逻辑表达式 =</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// &#34;Or Or Equals&#34; (or, the Mallet operator :wink:)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span> <span style="color:#f92672">||=</span> <span style="color:#a6e22e">b</span>; <span style="color:#75715e">// a || (a = b);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#34;And And Equals&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span> <span style="color:#f92672">&amp;&amp;=</span> <span style="color:#a6e22e">b</span>; <span style="color:#75715e">// a &amp;&amp; (a = b);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#34;QQ Equals&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span> <span style="color:#f92672">??=</span> <span style="color:#a6e22e">b</span>; <span style="color:#75715e">// a ?? (a = b);
</span></span></span></code></pre></div><ul>
<li>WeakRefs</li>
</ul>
<p>WeakRefs 是一种新的对象引用类型，用于创建对对象的弱引用，不会影响对象的垃圾回收。</p>
<p>想象你有一个备忘录，但是只在你需要的时候才能看到。WeakRefs 就像是对对象的一种轻量级引用，不会让对象被保持得太久。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">data</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Some data&#34;</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">weakRef</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WeakRef</span>(<span style="color:#a6e22e">obj</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 只有当 obj 还存在时，weakRef 才能获取到它
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">retrievedObj</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">weakRef</span>.<span style="color:#a6e22e">deref</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">retrievedObj</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">data</span>); <span style="color:#75715e">// 输出: &#39;Some data&#39;
</span></span></span></code></pre></div><h3 id="es2022">ES2022</h3>
<ul>
<li>类私有属性</li>
</ul>
<p>这是 JavaScript 中类的一个新特性，允许在类内部声明私有属性，仅在类的内部可访问。</p>
<p>想象你有一本笔记本，里面有些笔记是只有你能看到的。类私有属性就像是在类里面写下一些只有类自己能看到的东西。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Alice&#34;</span>; <span style="color:#75715e">// 私有属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">sayHello</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Hello, my name is </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">sayHello</span>(); <span style="color:#75715e">// 输出: &#39;Hello, my name is Alice&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>.<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">name</span>); <span style="color:#75715e">// 无法访问私有属性
</span></span></span></code></pre></div><ul>
<li>私有字段检查</li>
</ul>
<p>一种新的访问控制，允许类的私有属性在外部被访问时触发特定的操作。</p>
<p>想象你的门上装有警报，如果有人试图进入你的房间，会发出声音。私有字段检查就像是在访问私有属性时触发警报。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BankAccount</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">balance</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>; <span style="color:#75715e">// 私有属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">checkAccess</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Access to balance checked&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">balance</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">checkAccess</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">balance</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">account</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">BankAccount</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">account</span>.<span style="color:#a6e22e">balance</span>); <span style="color:#75715e">// 输出: &#39;Access to balance checked&#39; 和账户余额
</span></span></span></code></pre></div><ul>
<li>顶层 await</li>
</ul>
<p>允许在模块顶层使用 await。</p>
<p>想象你在工作，需要等一份文件完成才能继续。顶层 await 就像是你在等这份文件，但不需要停下其他的工作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 在模块顶层使用 await
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetchData</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>);
</span></span></code></pre></div><ul>
<li>.At 方法返回指定索引的元素</li>
</ul>
<p>想象你有一个大盒子，里面有很多东西。.at 方法就像是帮你从盒子中取出特定位置的东西。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arr</span>.<span style="color:#a6e22e">at</span>(<span style="color:#ae81ff">2</span>)); <span style="color:#75715e">// 输出: 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">at</span>(<span style="color:#ae81ff">1</span>)); <span style="color:#75715e">// 输出: &#39;e&#39;
</span></span></span></code></pre></div><ul>
<li>Object.hasOwn()</li>
</ul>
<p>一个全局函数，用于检查对象是否具有指定的自有属性。</p>
<p>想象你有一张名单，上面写着一些名字。Object.hasOwn() 就像是帮你查看名单上是否有某个名字。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Alice&#34;</span> };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Object.<span style="color:#a6e22e">hasOwn</span>(<span style="color:#a6e22e">person</span>, <span style="color:#e6db74">&#34;name&#34;</span>)); <span style="color:#75715e">// 输出: true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Object.<span style="color:#a6e22e">hasOwn</span>(<span style="color:#a6e22e">person</span>, <span style="color:#e6db74">&#34;age&#34;</span>)); <span style="color:#75715e">// 输出: false
</span></span></span></code></pre></div><ul>
<li>异常链</li>
</ul>
<p>一种更好地处理异常信息的方式，允许你在异常中包含更多信息。</p>
<p>想象你有一串蛋糕，但其中一个蛋糕有问题。异常链就像是在蛋糕上贴上标签，告诉你哪个蛋糕有问题，以及为什么有问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 一些可能出错的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">detailedError</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;详细错误信息&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">detailedError</span>.<span style="color:#a6e22e">originalError</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">error</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">throw</span> <span style="color:#a6e22e">detailedError</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>类静态块</li>
</ul>
<p>类的一个新特性，允许在类内部定义一块在类被初始化时执行的代码。</p>
<p>想象你在搭建一个房子，房子刚建好时，你想做一些特定的准备工作。类静态块就像是在房子刚建好时，执行一些初始化工作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;类初始化中...&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;实例化对象&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MyClass</span>();
</span></span></code></pre></div><h3 id="es2023">ES2023</h3>
<ul>
<li>Array 支持从尾部查找</li>
</ul>
<p>新增两个方法： .findLast()、.findLastIndex()​  从数组的最后一个元素开始查找，可以同  find()、findIndex()  做一个对比。</p>
<p>想象你有一条长长的队伍，人们站成一列。你可以从前面开始数，也可以从后面开始数。数组支持从尾部查找就像是你从队伍尾部开始数人。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> [{ <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span> }, { <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span> }, { <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span> }, { <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span> }];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// find vs findLast
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arr</span>.<span style="color:#a6e22e">find</span>(<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">1</span>)); <span style="color:#75715e">// { value: 1 }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arr</span>.<span style="color:#a6e22e">findLast</span>(<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">1</span>)); <span style="color:#75715e">// { value: 3 }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// findIndex vs findLastIndex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arr</span>.<span style="color:#a6e22e">findIndex</span>(<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">1</span>)); <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arr</span>.<span style="color:#a6e22e">findLastIndex</span>(<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">1</span>)); <span style="color:#75715e">// 2
</span></span></span></code></pre></div><ul>
<li>Hashbang 语法</li>
</ul>
<p>Hashbang 语法是一种在 URL 中使用 #! 符号，用于标记 Web 应用中的前端路由。</p>
<p>想象你有一本书，但书中有很多章节。你可以用不同的书签快速翻到你想读的章节。Hashbang 语法就像是在 URL 中放了一个特殊的书签，让你能迅速定位到网页的某个部分。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// URL 中的 Hashbang
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">https</span><span style="color:#f92672">:</span><span style="color:#75715e">//example.com/#!/page1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">https</span><span style="color:#f92672">:</span><span style="color:#75715e">//example.com/#!/page2
</span></span></span></code></pre></div></section>

  
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a class="flex w-1/2 items-center p-6 pr-3 no-underline" href="/articles/posts/05/"
      ><span class="mr-1.5">←</span><span>抽象工厂模式</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="/articles/posts/03/"
      ><span>工厂方法模式</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
  style="position: relative; z-index: 10;display: none;"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="/articles/">灏天阁</a>
  </div>
  <a class="link" href="https://yinchuanbo.github.io/" rel="noopener" target="_blank"
    >Powered by YinHao</a
  >️ ▷
</footer>


    <div class="img__mask" style="display: none;">
      <img src="" alt="">
      <span class="close_btn"></span>
    </div>

    <script>
      const imgs = document.images;
      const imgMask = document.querySelector('.img__mask')
      const closeBtn = document.querySelector('.close_btn')
      for (let i = 0; i < imgs.length; i++) {
        const element = imgs[i];
        element.onclick = () => {
          const src = element.src;
          imgMask.style.display = 'flex';
          imgMask.querySelector('img').src = src;
        }
      }
      closeBtn.onclick = () => {
        imgMask.style.display = 'none';
      }
    </script>
  </body>
</html>
