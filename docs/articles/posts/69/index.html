<!DOCTYPE html>






























<html
  class="not-ready text-sm lg:text-base"
  style="--bg: "
  lang="en"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>错误处理技巧 - 灏天阁</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="拦截错误 try/catch 语句 一般来说，JavaScript 中会以 try/catch 来拦截错误，且常常会搭配 finally 来减少重复的程序代码：
try { // 可能出错的程序代码 } catch (error) { // 处理错误 } finally { // 此处必定执行 } 需要注意的是，在 finally 内使用 return 或 throw 会覆写掉 try/catch 内原本的操作：
function foo() { try { throw new Error(&#34;Hello World!&#34;); } catch (error) { throw error; } finally { return &#34;finally&#34;; } } console.log(foo()); // finally function bar() { try { return &#34;try&#34;; } finally { throw new Error(&#34;finally&#34;); } } console." />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="/articles/main.min.css" />

  

  
  
  
    
  
  <link
    rel="preload"
    as="image"
    href="/articles/theme.png"
  />

  
  
  
  <link rel="preload" as="image" href="/imgs/logo.png" />
  
  

  

  
  <link rel="icon" href="/img/ico.ico" />
  <link rel="apple-touch-icon" href="/articles/apple-touch-icon.png" />
  
  <meta name="generator" content="Hugo 0.108.0">

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="错误处理技巧" />
<meta property="og:description" content="拦截错误 try/catch 语句 一般来说，JavaScript 中会以 try/catch 来拦截错误，且常常会搭配 finally 来减少重复的程序代码：
try { // 可能出错的程序代码 } catch (error) { // 处理错误 } finally { // 此处必定执行 } 需要注意的是，在 finally 内使用 return 或 throw 会覆写掉 try/catch 内原本的操作：
function foo() { try { throw new Error(&#34;Hello World!&#34;); } catch (error) { throw error; } finally { return &#34;finally&#34;; } } console.log(foo()); // finally function bar() { try { return &#34;try&#34;; } finally { throw new Error(&#34;finally&#34;); } } console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/articles/posts/69/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-07T22:03:53+08:00" />
<meta property="article:modified_time" content="2023-10-07T22:03:53+08:00" />

  
  <meta itemprop="name" content="错误处理技巧">
<meta itemprop="description" content="拦截错误 try/catch 语句 一般来说，JavaScript 中会以 try/catch 来拦截错误，且常常会搭配 finally 来减少重复的程序代码：
try { // 可能出错的程序代码 } catch (error) { // 处理错误 } finally { // 此处必定执行 } 需要注意的是，在 finally 内使用 return 或 throw 会覆写掉 try/catch 内原本的操作：
function foo() { try { throw new Error(&#34;Hello World!&#34;); } catch (error) { throw error; } finally { return &#34;finally&#34;; } } console.log(foo()); // finally function bar() { try { return &#34;try&#34;; } finally { throw new Error(&#34;finally&#34;); } } console."><meta itemprop="datePublished" content="2023-10-07T22:03:53+08:00" />
<meta itemprop="dateModified" content="2023-10-07T22:03:53+08:00" />
<meta itemprop="wordCount" content="456">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="错误处理技巧"/>
<meta name="twitter:description" content="拦截错误 try/catch 语句 一般来说，JavaScript 中会以 try/catch 来拦截错误，且常常会搭配 finally 来减少重复的程序代码：
try { // 可能出错的程序代码 } catch (error) { // 处理错误 } finally { // 此处必定执行 } 需要注意的是，在 finally 内使用 return 或 throw 会覆写掉 try/catch 内原本的操作：
function foo() { try { throw new Error(&#34;Hello World!&#34;); } catch (error) { throw error; } finally { return &#34;finally&#34;; } } console.log(foo()); // finally function bar() { try { return &#34;try&#34;; } finally { throw new Error(&#34;finally&#34;); } } console."/>

  
  
</head>
  <body class="text-black duration-200 ease-out dark:text-white">
    
    

    
    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 dark:prose-invert"
      id="main"
    >
      

<article>
  <header class="mb-10">
    <h1 class="!my-0 pb-2.5">
      错误处理技巧
    </h1>

    
    <div class="text-sm opacity-60">
      
      <time>Oct 7, 2023</time>
      
      
      <span class="mx-1">&middot;</span>
      <span>Yin灏</span>
    </div>
    
  </header>

  <section><h2 id="拦截错误">拦截错误</h2>
<h3 id="trycatch-语句">try/catch 语句</h3>
<p>一般来说，JavaScript 中会以 try/catch 来拦截错误，且常常会搭配 finally 来减少重复的程序代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 可能出错的程序代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 处理错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 此处必定执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>需要注意的是，在 <strong>finally</strong> 内使用 return 或 throw 会<strong>覆写</strong>掉 try/catch 内原本的操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">foo</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;Hello World!&#34;</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#a6e22e">error</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;finally&#34;</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">foo</span>()); <span style="color:#75715e">// finally
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">bar</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;try&#34;</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;finally&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">bar</span>()); <span style="color:#75715e">// Uncaught Error: finally
</span></span></span></code></pre></div><h3 id="异步错误拦截">异步错误拦截</h3>
<p>try/catch 只能拦截同步的错误，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>  Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#e6db74">&#34;Promise rejection&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;Timeout error&#34;</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#34;err&#34;</span>, <span style="color:#a6e22e">error</span>); <span style="color:#75715e">// 没有拦截到错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>若要拦截错误，则需要加入额外的程序代码，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#e6db74">&#34;Promise rejection&#34;</span>)
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">data</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;OK&#34;</span>))
</span></span><span style="display:flex;"><span>  .<span style="color:#66d9ef">catch</span>((<span style="color:#a6e22e">reason</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Rejection handled.&#34;</span>);
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#66d9ef">finally</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Finally&#34;</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;Timeout error&#34;</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Error handled.&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>此外，将 Callback 语句转化为 Promise 也是常见的用法，这么做的好处是可以把错误从 Callback 中取出来：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;Timeout error!&#34;</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">promise</span>.<span style="color:#66d9ef">catch</span>((<span style="color:#a6e22e">error</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">handleError</span>(<span style="color:#a6e22e">error</span>); <span style="color:#75715e">// 处理错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>});
</span></span></code></pre></div><h3 id="错误拦截时机">错误拦截时机</h3>
<p>try/catch 应该用于无法控制的错误，例如：</p>
<ul>
<li>
<p>无法避免的错误：如 JSON.parse，执行函数时无法保证是否会出错，需要使用 try/catch 来处理错误，确保程序代码不会中断执行。</p>
</li>
<li>
<p>定制化错误：使用第三方软件包时，可能出现软件包自定义的错误提示信息，或者非预期的错误，由于无法改变软件包的行为，可以使用 try/catch 拦截错误，再定制错误提示信息或处理错误。</p>
</li>
</ul>
<ol>
<li>避免不必要的拦截</li>
</ol>
<p>如果明确知道程序代码在哪些情况会出错，就不应该使用 try/catch，请看以下范例：</p>
<ul>
<li>知道当变量 str 不是字符串类型时会出错，应做好事前检查，主动解释并抛出错误。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 做好事前检查，主动解释并抛出错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">str</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#34;string&#34;</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;str must be a string.&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">toLowerCase</span>();
</span></span></code></pre></div><ul>
<li>知道此段程序代码可能会出错，因此使用 try/catch 来拦截错误，然而这么做并没有什么帮助。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 没有意义的 try/catch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">toLowerCase</span>();
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">throw</span> <span style="color:#a6e22e">error</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li>避免过早拦截</li>
</ol>
<p>只有在知道该如何处理错误时，才能够拦截错误。</p>
<p>如下：在 say 函数中，以 try/catch 程序块中包含 logOrError 函数来拦截可能会出现的错误，虽然可以在出错时避免程序中断，但 say 作为一个底层共享函数，无法得知网页应用的逻辑以及用户当前的应用场景，也无法正确处理错误，此外，如果拦截了错误，却不进行处理，对外层函数而言就如同没有发生错误，通常会提升 Debug 的难度：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logOrError</span>(<span style="color:#a6e22e">message</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.5</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#a6e22e">message</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">message</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">say</span>(<span style="color:#a6e22e">message</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">logOrError</span>(<span style="color:#a6e22e">message</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#34;Something went wrong.&#34;</span>); <span style="color:#75715e">// 过早拦截错误且打印出无用的信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sayHi</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">say</span>(<span style="color:#e6db74">&#34;hi&#34;</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#34;Failed to say hi. Please try again.&#34;</span>); <span style="color:#75715e">// 较轻微的错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">mustSayHi</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">say</span>(<span style="color:#e6db74">&#34;hi&#34;</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#34;Fatal error!&#34;</span>); <span style="color:#75715e">// 遭遇重大错误，必须重新刷新页面
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    window.<span style="color:#a6e22e">location</span>.<span style="color:#a6e22e">reload</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>想要避免上述问题，可以删除 try/catch 语句，交由其他函数（如 sayHi、mustSayHi）来处理错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">say</span>(<span style="color:#a6e22e">message</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">logOrError</span>(<span style="color:#a6e22e">message</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>或者在 say 函数中进行基本的错误处理，再抛出错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">say</span>(<span style="color:#a6e22e">message</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">logOrError</span>(<span style="color:#a6e22e">message</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#a6e22e">error</span>); <span style="color:#75715e">// 必要时可以先行处理错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">`say(): Failed to log </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span><span style="color:#e6db74">}</span><span style="color:#e6db74">.`</span>); <span style="color:#75715e">// 更详细的错误提示信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="错误事件">错误事件</h3>
<p>即使尽可能做好错误处理，还是有可能出现没有拦截到的错误。</p>
<p>没有被拦截到的错误会在 window 上触发 error 或 <code>unhandledrejection(Promise)</code> 事件。</p>
<p>拦截错误事件可以视为包了一层全局的 try/catch 语句，不过一般而言，若有正确的错误处理方式，则不应该出现该事件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">handleUncaughtError</span>(<span style="color:#a6e22e">event</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">event</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">preventDefault</span>(); <span style="color:#75715e">// 避免默认操作，如打印出错误提示信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>window.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#34;error&#34;</span>, <span style="color:#a6e22e">handleUncaughtError</span>);
</span></span><span style="display:flex;"><span>window.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#34;unhandledrejection&#34;</span>, <span style="color:#a6e22e">handleUncaughtError</span>);
</span></span></code></pre></div><h2 id="抛出错误">抛出错误</h2>
<p>只要程序代码出现无法正确执行的情况，就应该使用 throw 语句来主动抛出错误</p>
<p>通过自定义错误类别可以协助区分错误类型，并根据不同类型进行不同的错误处理，</p>
<p>如下，利用 TrustedError 表示已知错误，并用 ApiError 表示 API 相关错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TrustedError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">message</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">super</span>(<span style="color:#a6e22e">message</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span>.<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ApiError</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">TrustedError</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">status</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">super</span>(<span style="color:#a6e22e">message</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">status</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>遇到 API 错误时，抛出自定义的错误（如 ApiError），在拦截时能根据错误类别进行相应的处理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ApiError</span>(<span style="color:#e6db74">&#34;Path not found.&#34;</span>, <span style="color:#ae81ff">404</span>);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">error</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">ApiError</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">error</span>.<span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">error</span>.<span style="color:#a6e22e">message</span><span style="color:#e6db74">}</span><span style="color:#e6db74">. (Status </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">error</span>.<span style="color:#a6e22e">status</span><span style="color:#e6db74">}</span><span style="color:#e6db74">)`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ApiError: Path not found. (Status 404)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">error</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">TrustedError</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">error</span>.<span style="color:#a6e22e">message</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">handleUnexpectedError</span>(<span style="color:#a6e22e">error</span>); <span style="color:#75715e">// 处理非预期的错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></section>

  
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a class="flex w-1/2 items-center p-6 pr-3 no-underline" href="/articles/posts/70/"
      ><span class="mr-1.5">←</span><span>Console信息</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="/articles/posts/68/"
      ><span>浏览器渲染性能分析技巧</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
  style="position: relative; z-index: 10;display: none;"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="/articles/">灏天阁</a>
  </div>
  <a class="link" href="https://yinchuanbo.github.io/" rel="noopener" target="_blank"
    >Powered by YinHao</a
  >️ ▷
</footer>


    <div class="img__mask" style="display: none;">
      <img src="" alt="">
      <span class="close_btn"></span>
    </div>

    <script>
      const imgs = document.images;
      const imgMask = document.querySelector('.img__mask')
      const closeBtn = document.querySelector('.close_btn')
      for (let i = 0; i < imgs.length; i++) {
        const element = imgs[i];
        element.onclick = () => {
          const src = element.src;
          imgMask.style.display = 'flex';
          imgMask.querySelector('img').src = src;
        }
      }
      closeBtn.onclick = () => {
        imgMask.style.display = 'none';
      }
    </script>
  </body>
</html>
