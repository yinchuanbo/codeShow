<!DOCTYPE html>
<html lang="en">
  <head>
    <title>现代 CSS 解决方案:CSS 数学函数</title>
    <meta charset="utf-8">
    <meta name="description" content="This is a page">
    <meta name="keywords" content="page, sample">
    <meta name="author" content="None">
    <link rel="icon" sizes="any" mask href="../assets/images/ico4.svg" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <link rel="stylesheet" href="../assets/css/articles.css">
</head>
<body>
  <!--<div class="article__wrapper_left">
    <div class="article__wrapper_left-mulu">目录</div>
    <ul class="articles__list"><li class="">
          <a href="/articles/26.html">
            reset.css 知多少
          </a>
        </li><li class="">
          <a href="/articles/27.html">
            模板方法模式
          </a>
        </li><li class="">
          <a href="/articles/28.html">
            VSCODE 快捷键
          </a>
        </li><li class="">
          <a href="/articles/29.html">
            观察者模式
          </a>
        </li><li class="">
          <a href="/articles/30.html">
            状态模式
          </a>
        </li><li class="">
          <a href="/articles/31.html">
            策略模式
          </a>
        </li><li class="">
          <a href="/articles/32.html">
            职责链模式
          </a>
        </li><li class="">
          <a href="/articles/33.html">
            命令模式
          </a>
        </li><li class="">
          <a href="/articles/34.html">
            中介者模式
          </a>
        </li><li class="">
          <a href="/articles/35.html">
            迭代器模式
          </a>
        </li></ul>
  </div>-->
  <div class="article__wrapper_sidebar">
    <a href="/" target="_blank"><svg t="1714001835347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4298" width="48" height="48"><path d="M147.904 304.128l301.866667-179.541333a128 128 0 0 1 131.712 0.512l295.466666 178.88A128 128 0 0 1 938.666667 413.482667V810.666667a128 128 0 0 1-128 128H213.333333a128 128 0 0 1-128-128V414.144a128 128 0 0 1 62.570667-110.016z m43.626667 73.344A42.666667 42.666667 0 0 0 170.666667 414.144V810.666667a42.666667 42.666667 0 0 0 42.666666 42.666666h597.333334a42.666667 42.666667 0 0 0 42.666666-42.666666V413.482667a42.666667 42.666667 0 0 0-20.565333-36.501334l-295.466667-178.88a42.666667 42.666667 0 0 0-43.925333-0.170666l-301.866667 179.541333z" fill="#8a919f" p-id="4299"></path><path d="M405.333333 469.333333h213.333334a42.666667 42.666667 0 1 1 0 85.333334H405.333333a42.666667 42.666667 0 1 1 0-85.333334z m0 85.333334a42.666667 42.666667 0 1 0 0-85.333334h213.333334a42.666667 42.666667 0 1 0 0 85.333334H405.333333z" fill="#8a919f" p-id="4300"></path></svg></a>
    <a href="/tools/" target="_blank"><svg t="1714002003458" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6911" width="48" height="48"><path d="M817.87 556.31h-63.58v-66.24A42.27 42.27 0 0 0 712 447.8h-84.81a42.27 42.27 0 0 0-42.27 42.27v66.24H436.57v-66.24a42.27 42.27 0 0 0-42.27-42.27h-84.83a42.27 42.27 0 0 0-42.27 42.27v66.24h-61.83A22.39 22.39 0 0 0 183 578.7a22.39 22.39 0 0 0 22.39 22.39h61.81v65.55a42.27 42.27 0 0 0 42.27 42.27h84.83a42.27 42.27 0 0 0 42.27-42.27v-65.55h148.36v65.55a42.27 42.27 0 0 0 42.27 42.27H712a42.27 42.27 0 0 0 42.27-42.27v-65.55h63.58a22.39 22.39 0 0 0 22.39-22.39 22.39 22.39 0 0 0-22.37-22.39z m-438.64 95.26h-54.69V505.14h54.69z m317.72 0h-54.69V505.14H697z" p-id="6912" fill="#8a919f"></path><path d="M823 202.58h-90.81v-63.09a71.88 71.88 0 0 0-71.88-71.88H363.19a71.88 71.88 0 0 0-71.88 71.88v63.08h-90.12A137.17 137.17 0 0 0 64 339.75v479a137.17 137.17 0 0 0 137.19 137.14H823a137.17 137.17 0 0 0 137.19-137.17v-479A137.17 137.17 0 0 0 823 202.58z m-474.36-54.1A23.52 23.52 0 0 1 372.17 125h279.16a23.52 23.52 0 0 1 23.52 23.52v54.1h-326.2z m554.23 673.31a76.76 76.76 0 0 1-76.76 76.76h-628a76.76 76.76 0 0 1-76.76-76.76V336.67a76.76 76.76 0 0 1 76.76-76.76h628a76.76 76.76 0 0 1 76.76 76.76z" p-id="6913" fill="#8a919f"></path></svg></a>
  </div>
  <div class="article__wrapper">
    <div class="article__wrapper__main">
      <div class="article__wrapper_header">
        <h1>现代 CSS 解决方案:CSS 数学函数</h1>
        <span class="articles__home_time">2023/09/02 · YinHao</span>
      </div>
      <p>在 CSS 中，其实存在各种各样的函数。具体分为：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions#transform_functions">Transform functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions#math_functions">Math functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions#filter_functions">Filter functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions#color_functions">Color functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions#image_functions">Image functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions#counter_functions">Counter functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions#font_functions">Font functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions#shape_functions">Shape functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions#reference_functions">Reference functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions#css_grid_functions">CSS grid functions</a></li>
</ul>
<p>本文，将具体介绍其中的 CSS 数学函数（Math functions）中，已经被浏览器大规模支持的 4 个：</p>
<ul>
<li>calc()</li>
<li>min()</li>
<li>max()</li>
<li>clamp()</li>
</ul>
<p>为什么说是被浏览器大规模支持的？因为除了这 4 个目前已经得到大规模支持的数学函数外，其实规范 <a href="https://drafts.csswg.org/css-values/#math">CSS Values and Units Module Level 4</a> 已经定义了诸如三角函数相关 <code>sin()</code>、<code>cos()</code>、<code>tan()</code> 等，指数函数相关 <code>pow()</code>、<code>sqrt()</code> 等等数学函数，只是目前都处于实验室阶段，还没有浏览器支持它们，需要给时间一点时间。</p>
<h2>Calc()</h2>
<p>calc() 此 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> 函数允许在声明 CSS 属性值时执行一些计算。</p>
<p>语法类似于</p>
<pre><code class="language-css">{
  width: calc(100% - 80px);
}
</code></pre>
<p>一些需要注意的点：</p>
<ul>
<li><code>+</code> 和 <code>-</code> 运算符的两边必须要有空白字符。比如，<code>calc(50% -8px)</code> 会被解析成为一个无效的表达式，必须写成<code>calc(8px + -50%)</code></li>
<li><code>*</code> 和 <code>/</code> 这两个运算符前后不需要空白字符，但如果考虑到统一性，仍然推荐加上空白符</li>
<li>用 0 作除数会使 HTML 解析器抛出异常</li>
<li>涉及自动布局和固定布局的表格中的表列、表列组、表行、表行组和表单元格的宽度和高度百分比的数学表达式，auto 可视为已指定。</li>
<li>calc() 函数支持嵌套，但支持的方式是：把被嵌套的 calc() 函数全当成普通的括号。（所以，函数内直接用括号就好了。）</li>
<li>calc() 支持与 CSS 变量混合使用</li>
</ul>
<p>看一个最常见的例子，页面结构如下：</p>
<pre><code class="language-html">&lt;div class=&quot;g-container&quot;&gt;
  &lt;div class=&quot;g-content&quot;&gt;Content&lt;/div&gt;
  &lt;div class=&quot;g-footer&quot;&gt;Footer&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>页面的 <code>g-footer</code> 高为 80px，我们希望不管页面多长，<code>g-content</code> 部分都可以占满剩余空间，像是这样：</p>
<p><img src="../assets/images/articles/25/01.png" alt=""></p>
<p>这种布局使用 flex 的弹性布局可以轻松实现，当然，也可以使用 <code>calc()</code> 实现：</p>
<pre><code class="language-css">.g-container {
  height: 100vh;
}
.g-content {
  height: calc(100vh - 80px);
}
.g-footer {
  height: 80px;
}
</code></pre>
<p>下面罗列一些 Calc() 的进阶技巧。</p>
<h3>Calc 中的加减法与乘除法的差异</h3>
<p>注意，calc() 中的加减法与乘除法的差异：</p>
<pre><code class="language-css">{
  font-size: calc(1rem + 10px);
  width: calc(100px + 10%);
}
</code></pre>
<p>可以看到，加减法两边的操作数都是需要单位的，而乘除法，需要一个无单位数，仅仅表示一个倍率：</p>
<pre><code class="language-css">{
  width: calc(100% / 7);
  animation-delay: calc(1s * 3);
}
</code></pre>
<h3>Calc 的嵌套</h3>
<p>calc() 函数是可以嵌套使用的，像是这样：</p>
<pre><code class="language-css">{
  width: calc(100vw - calc(100% - 64px));
}
</code></pre>
<p>此时，内部的 calc() 函数可以退化写成一个括号即可 ()，所以上述代码等价于：</p>
<pre><code class="language-css">{
  width: calc(100vw - (100% - 64px));
}
</code></pre>
<p><strong>也就是嵌套内的 calc()，calc 几个函数字符可以省略</strong>。</p>
<h3>Calc 内不同单位的混合运算</h3>
<p>calc() 支持不同单位的混合运算，对于长度，只要是属于长度相关的单位都可以进行混合运算，包含这些：</p>
<ul>
<li>px</li>
<li>%</li>
<li>em</li>
<li>rem</li>
<li>in</li>
<li>mm</li>
<li>cm</li>
<li>pt</li>
<li>pc</li>
<li>ex</li>
<li>ch</li>
<li>vh</li>
<li>vw</li>
<li>vmin</li>
<li>vmax</li>
</ul>
<p>这里有一个有意思的点，运算肯定是消耗性能的，早年间，有这样一段 CSS 代码，可以直接让 Chrome 浏览器崩溃 Crash：</p>
<pre><code class="language-html">&lt;div&gt;&lt;/div&gt;
</code></pre>
<p>CSS 样式如下：</p>
<pre><code class="language-css">div {
  --initial-level-0: calc(1vh + 1% + 1px + 1em + 1vw + 1cm);
  --level-1: calc(var(--initial-level-0) + var(--initial-level-0));
  --level-2: calc(var(--level-1) + var(--level-1));
  --level-3: calc(var(--level-2) + var(--level-2));
  --level-4: calc(var(--level-3) + var(--level-3));
  --level-5: calc(var(--level-4) + var(--level-4));
  --level-6: calc(var(--level-5) + var(--level-5));
  --level-7: calc(var(--level-6) + var(--level-6));
  --level-8: calc(var(--level-7) + var(--level-7));
  --level-9: calc(var(--level-8) + var(--level-8));
  --level-10: calc(var(--level-9) + var(--level-9));
  --level-11: calc(var(--level-10) + var(--level-10));
  --level-12: calc(var(--level-11) + var(--level-11));
  --level-13: calc(var(--level-12) + var(--level-12));
  --level-14: calc(var(--level-13) + var(--level-13));
  --level-15: calc(var(--level-14) + var(--level-14));
  --level-16: calc(var(--level-15) + var(--level-15));
  --level-17: calc(var(--level-16) + var(--level-16));
  --level-18: calc(var(--level-17) + var(--level-17));
  --level-19: calc(var(--level-18) + var(--level-18));
  --level-20: calc(var(--level-19) + var(--level-19));
  --level-21: calc(var(--level-20) + var(--level-20));
  --level-22: calc(var(--level-21) + var(--level-21));
  --level-23: calc(var(--level-22) + var(--level-22));
  --level-24: calc(var(--level-23) + var(--level-23));
  --level-25: calc(var(--level-24) + var(--level-24));
  --level-26: calc(var(--level-25) + var(--level-25));
  --level-27: calc(var(--level-26) + var(--level-26));
  --level-28: calc(var(--level-27) + var(--level-27));
  --level-29: calc(var(--level-28) + var(--level-28));
  --level-30: calc(var(--level-29) + var(--level-29));
  --level-final: calc(var(--level-30) + 1px);
  border-width: var(--level-final);
  border-style: solid;
}
</code></pre>
<p>可以看到，从 <code>--level-1</code> 到 <code>--level-30</code>，每次的运算量都是成倍的增长，最终到 <code>--level-final</code> 变量，展开将有 2^30 = <strong>1073741824</strong> 个 <code>--initial-level-0</code> 表达式的内容。</p>
<p>并且，每个 <code>--initial-level-0</code> 表达式的内容 -- <code>calc(1vh + 1% + 1px + 1em + 1vw + 1cm)</code>，在浏览器解析的时候，也已经足够复杂。</p>
<p>混合在一起，就导致了浏览器的 BOOM（Chrome 70 之前的版本），为了能看到效果，我们将上述样式赋给某个元素被 hover 的时候，得到如下效果：</p>
<p>![](../assets/images/articles/25/01.gif&quot;&gt;</p>
<p>当然，这个 BUG 目前已经被修复了，我们也可以通过这个小 DEMO 了解到，一是 calc 是可以进行不同单位的混合运算的，另外一个就是注意具体使用的时候如果计算量巨大，可能会导致性能上较大的消耗。</p>
<p>当然，<strong>不要</strong>将长度单位和非长度单位混合使用，像是这样：</p>
<pre><code class="language-css">{
  animation-delay: calc(1s + 1px);
}
</code></pre>
<h3>Calc 搭配 CSS 自定义变量使用</h3>
<p>calc() 函数非常重要的一个特性就是能够搭配 CSS 自定义以及 CSS <a href="https://github.com/Property">@Property</a> 变量一起使用。</p>
<p>最简单的一个 DEMO：</p>
<pre><code class="language-css">:root {
  --width: 10px;
}
div {
  width: calc(var(--width));
}
</code></pre>
<p>当然，这样看上去，根本看不出这样的写法的作用，好像没有什么意义。实际应用场景中，会比上述的 DEMO 要稍微复杂一些。</p>
<p>假设我们要实现这样一个 loading 动画效果，一开始只有 3 个球：</p>
<p>![](../assets/images/articles/25/02.gif&quot;&gt;</p>
<p>可能的写法是这样，我们给 3 个球都添加同一个旋转动画，然后分别控制他们的 <code>animation-delay</code>：</p>
<pre><code class="language-html">&lt;div class=&quot;g-container&quot;&gt;
  &lt;div class=&quot;g-item&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.item:nth-child(1) {
  animation: rotate 3s infinite linear;
}
.item:nth-child(2) {
  animation: rotate 3s infinite -1s linear;
}
.item:nth-child(3) {
  animation: rotate 3s infinite -2s linear;
}
</code></pre>
<p>如果有一天，这个动画需要扩展成 5 个球的话，像是这样：</p>
<p>![](../assets/images/articles/25/03.gif&quot;&gt;</p>
<p>我们就不得已，得去既添加 HTML，又修改 CSS。而如果借助 Calc 和 CSS 变量，这个场景就可以稍微简化一下。</p>
<p>假设只有 3 个球：</p>
<pre><code class="language-html">&lt;div class=&quot;g-container&quot;&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 0&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 1&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>我们通过 HTML 的 Style 标签，传入 <code>--delay</code> 变量，在 CSS 中直接使用它们：</p>
<pre><code class="language-css">.g-item {
  animation: rotate 3s infinite linear;
  animation-delay: calc(var(--delay) * -1s);
}
@keyframes rotate {
  to {
    transform: rotate(360deg);
  }
}
</code></pre>
<p>而当动画修改成 5 个球时，我们就不需要修改 CSS，直接修改 HTML 即可，像是这样：</p>
<pre><code class="language-html">&lt;div class=&quot;g-container&quot;&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 0&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 0.6&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 1.2&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 1.8&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 2.4&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>核心的 CSS 还是这一句，不需要做任何修改：</p>
<pre><code class="language-css">{
  animation-delay: calc(var(--delay) * -1s);
}
</code></pre>
<p>完整的 DEMO，你可以戳这里：<a href="https://codepen.io/Chokcoco/pen/OJzarJL">CodePen Demo -- Calc &amp; CSS Variable Demo</a></p>
<h3>calc 搭配自定义变量时候的默认值</h3>
<p>还是上述的 Loading 动画效果，如果我的 HTML 标签中，有一个标签忘记填充 <code>--delay</code> 的值了，那会发生什么？</p>
<p>像是这样：</p>
<pre><code class="language-html">&lt;div class=&quot;g-container&quot;&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 0&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 0.6&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 1.8&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-item&quot; style=&quot;--delay: 2.4&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">{
  animation-delay: calc(var(--delay) * -1s);
}
</code></pre>
<p>由于 HTML 标签没有传入 <code>--delay</code> 的值，并且在 CSS 中向上查找也没找到对应的值，此时，<code>animation-delay: calc(var(--delay) * -1s)</code> 这一句其实是无效的，相当于 <code>animation-delay: 0</code>，效果也就是少了个球的效果：</p>
<p><img src="../assets/images/articles/25/02.png" alt=""></p>
<p>所以，基于这种情况，可以利用 CSS 自定义变量 <code>var()</code> 的 fallback 机制：</p>
<pre><code class="language-css">{
  /* (--delay, 1) 中的 1 是个容错机制 */
  animation-delay: calc(var(--delay, 1) * -1s);
}
</code></pre>
<p>此时，如果没有读取到任何 <code>--delay</code> 值，就会使用默认的 1 与 <code>-1s</code> 进行运算。</p>
<h3>Calc 字符串拼接</h3>
<p>很多人在使用 CSS 的时候，会尝试字符串的拼接，像是这样：</p>
<pre><code class="language-html">&lt;div style=&quot;--url: 'bsBD1I.png'&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-css">:root {
  --urlA: &quot;url(https://s1.ax1x.com/2022/03/07/&quot;;
  --urlB: &quot;)&quot;;
}
div {
  width: 400px;
  height: 400px;
  background-image: calc(var(--urlA) + var(--url) + var(--urlB));
}
</code></pre>
<p>这里想利用 <code>calc(var(--urlA) + var(--url) + var(--urlB))</code> 拼出完整的在 <code>background-image</code> 中可使用的 URL <code>url(https://s1.ax1x.com/2022/03/07/bsBD1I.png)</code>。</p>
<p>然而，这是不被允许的（无法实现的）。<strong>calc 的没有字符串拼接的能力</strong>。</p>
<p>唯一可能完成字符串拼接的是在元素的伪元素的 <code>content</code> 属性中。但是也不是利用 calc。</p>
<p>来看这样一个例子，这是<strong>错误</strong>的：</p>
<pre><code class="language-css">:root {
  --stringA: &quot;123&quot;;
  --stringB: &quot;456&quot;;
  --stringC: &quot;789&quot;;
}

div::before {
  content: calc(var(--stringA) + var(--stringB) + var(--stringC));
}
</code></pre>
<p>此时，不需要 calc，直接使用自定义变量相加即可。</p>
<p>因此，<strong>正确</strong>的写法：</p>
<pre><code class="language-css">:root {
  --stringA: &quot;123&quot;;
  --stringB: &quot;456&quot;;
  --stringC: &quot;789&quot;;
}
div::before {
  content: var(--stringA) + var(--stringB) + var(--stringC);
}
</code></pre>
<blockquote>
<p><code>content: var(--stringA) + var(--stringB) + var(--stringC)</code> 中的加号可以省略。</p>
</blockquote>
<p>此时，内容可以正常展示：</p>
<p><img src="../assets/images/articles/25/03.png" alt=""></p>
<p>再强调一下，<strong>calc 的没有字符串拼接的能力</strong>，如下的使用方式都是无法被识别的错误语法：</p>
<pre><code class="language-css">.el::before {
  /* 不支持字符串拼接 */
  content: calc(&quot;My &quot; + &quot;counter&quot;);
}
.el::before {
  /* 更不支持字符串乘法 */
  content: calc(&quot;String Repeat 3 times&quot; * 3);
}
</code></pre>
<h2>min()、max()、clamp()</h2>
<p>min()、max()、clamp() 适合放在一起讲。它们的作用彼此之间有所关联。</p>
<ul>
<li>max()：从一个逗号分隔的表达式列表中选择最大（正方向）的值作为属性的值</li>
<li>min()：从一个逗号分隔的表达式列表中选择最小的值作为属性的值</li>
<li>clamp()：把一个值限制在一个上限和下限之间，当这个值超过最小值和最大值的范围时，在最小值和最大值之间选择一个值使用</li>
</ul>
<p>由于在现实中，有非常多元素的的属性不是一成不变的，而是会根据上下文、环境的变化而变化。</p>
<p>譬如这样一个布局：</p>
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.container {
  height: 100px;
  background: #000;
}
</code></pre>
<p>效果如下，<code>.container</code> 块它会随着屏幕的增大而增大，始终占据整个屏幕：</p>
<p><img src="../assets/images/articles/25/04.png" alt=""></p>
<p>对于一个响应式的项目，我们肯定不希望它的宽度会一直变大，而是当达到一定的阈值时，宽度从相对单位变成了绝对单位，这种情况就适用于 <code>min()</code>，简单改造下代码：</p>
<pre><code class="language-css">.container {
  width: min(100%, 500px);
  height: 100px;
  background: #000;
}
</code></pre>
<p>容器的宽度值会在 <code>width: 100%</code> 与 <code>width: 500px</code> 之间做选择，选取相对小的那个。</p>
<p>在屏幕宽度不足 500px 时候，也就表现为 <code>width: 100%</code>，反之，则表现为 <code>width: 500px</code>：</p>
<p>![](../assets/images/articles/25/04.gif&quot;&gt;</p>
<p>同理，在类似的场景，我们也可以使用 <code>max()</code> 从多个值中，选取相对更大的值。</p>
<h3>min()、max() 支持多个值的列表</h3>
<p>min()、max() 支持多个值的列表，譬如 <code>width: max(1px, 2px, 3px, 50px)</code>。</p>
<p>当然，对于上述表达：</p>
<p><code>width: max(1px, 2px, 3px, 50px)</code> 其实等于 <code>width: 50px</code>。因此，对于 min()、max() 的具体使用而言，最多应该只包含一个具体的绝对单位。否则，这样的像上述这种代码，虽然语法支持，但是任何情况下，计算值都是确定的，其实没有意义。</p>
<h3>配合 calc</h3>
<p>min()、max()、clamp() 都可以配合 calc 一起使用。</p>
<p>譬如：</p>
<pre><code class="language-css">div {
  width: max(50vw, calc(300px + 10%));
}
</code></pre>
<p>在这种情况下，calc 和相应包裹的括号可以省略，因此，上述代码又可以写成：</p>
<pre><code class="language-css">div {
  width: max(50vw, 300px + 10%);
}
</code></pre>
<h3>基于 max、min 模拟 clamp</h3>
<p>现在，有这样一种场景，如果，我们又需要限制最大值，也需要限制最小值，怎么办呢？</p>
<p>像是这样一个场景，**字体的大小，最小是 12px，随着屏幕的变大，逐渐变大，但是为了避免老人机现象（随着屏幕变大，无限制变大），我们还需要限制一个最大值 20px。</p>
<p>我们可以利用 vw 来实现给字体赋动态值，假设在移动端，设备宽度的 CSS 像素为 320px 时，页面的字体宽度最小为 12px，换算成 vw 即是 <code>320 / 100 = 3.2</code>，也就是 1vw 在 屏幕宽度为 320px 时候，表现为 3.2px，12px 约等于 3.75 vw。</p>
<p>同时，我们需要限制最大字体值为 20px，对应的 CSS 如下：</p>
<pre><code class="language-css">p {
  font-size: max(12px, min(3.75vw, 20px));
}
</code></pre>
<p>看看效果：</p>
<p><img src="../assets/images/articles/25/05.png" alt=""></p>
<p>通过 <code>max()</code>、<code>min()</code> 的配合使用，以及搭配一个相对单位 vw，我们成功的给字体设置了上下限，而在这个上下限之间实现了动态变化。</p>
<p>当然，上面核心的这一段 <code>max(12px, min(3.75vw, 20px))</code> 看上去有点绕，因此，CSS 推出了 <code>clamp()</code> 简化这个语法，下面两个写法是等价的：</p>
<pre><code class="language-css">p {
  font-size: max(12px, min(3.75vw, 20px));
  /* 等价于 */
  font-size: clamp(12px, 3.75vw, 20px);
}
</code></pre>
<h3>clamp()</h3>
<p><code>clamp()</code> 函数的作用是把一个值限制在一个上限和下限之间，当这个值超过最小值和最大值的范围时，在最小值和最大值之间选择一个值使用。它接收三个参数：最小值、首选值、最大值。</p>
<p>有意思的是，<code>clamp(MIN, VAL, MAX)</code> 其实就是表示 <code>max(MIN, min(VAL, MAX))</code>。</p>
<h2>使用 vw 配合 clamp 实现响应式布局</h2>
<p>我们继续上面的话题。</p>
<p>在不久的过去，移动端的适配方面，使用更多的 rem 适配方案，可能会借助一些现成的库，类似于 flexible.js、hotcss.js 等库。rem 方案比较大的一个问题在于需要一段 JavaScript 响应视口变化，重设根元素的 <code>font-size</code>，并且，使用 rem 多少有点 hack 的感觉。</p>
<p>在现在，在移动端适配，我们更为推崇的是 vw 纯 CSS 方案，与 rem 方案类似，它的本质也是页面的等比例缩放。它的一个问题在于，如果仅仅使用 vw，随着屏幕的不断变大或者缩小，内容元素将会一直变大变小下去，这也导致了在大屏幕下，许多元素看着实在太大了！</p>
<p>因此，我们需要一种能够控制最大、最小阈值的方式，像是这样：</p>
<p><img src="../assets/images/articles/25/05.png" alt=""></p>
<p>此时，clamp 就能非常好的派上用场，还是我们上述的例子，这一段代码 <code>font-size: clamp(12px, 3.75vw, 20px)</code>，就能将字体限制在 <code>12px - 20px</code> 的范围内。</p>
<p><strong>因此，对于移动端页面而言，所有涉及长度的单位，我们都可以使用 vw 进行设置。而诸如字体、内外边距、宽度等不应该完全等比例缩放的，采用 <code>clamp()</code> 控制最大最小阈值</strong>。</p>
<p>在 <a href="https://www.smashingmagazine.com/2022/01/modern-fluid-typography-css-clamp/">Modern Fluid Typography Using CSS Clamp</a> 一文中，对使用 clamp() 进行流式响应式布局还有更为深入的探讨，感兴趣的可以深入阅读。</p>
<p>总结一下，对于移动端页面，我们可以以 vw 配合 clamp() 的方式，​ 完成整个移动端布局的适配。它的优势在于：</p>
<ul>
<li><strong>没有额外 JavaScript 代码的引入，纯 CSS 解决方案</strong></li>
<li><strong>能够很好地控制边界阈值，合理的进行缩放展示</strong></li>
</ul>
<h3>反向响应式变化</h3>
<p>还有一个技巧，利用 <code>clamp()</code> 配合负值，我们也可以反向操作，得到一种屏幕越大，字体越小的反向响应式效果：</p>
<pre><code class="language-css">p {
  font-size: clamp(20px, -5vw + 96px, 60px);
}
</code></pre>
<p>看看效果：</p>
<p>![](../assets/images/articles/25/06.gif&quot;&gt;</p>
<p>这个技巧挺有意思的，由于 <code>-5vw + 96px</code> 的计算值会随着屏幕的变小而增大，实现了一种反向的字体响应式变化。</p>
<h3>总结</h3>
<p>总结一下，合理运用 min()、max()、clamp()，是构建现代响应式布局的重点，我们可以告别传统的需要 JavaScript 辅助的一些方案，基于 CSS 这些数学函数即可完成所有的诉求。</p>
<p>一些进阶阅读非常好的文章：</p>
<ul>
<li><a href="https://blog.logrocket.com/min-max-clamp-css-functions/">A guide to the min(), max(), and clamp() CSS functions</a></li>
<li><a href="https://www.smashingmagazine.com/2022/01/modern-fluid-typography-css-clamp/">Modern Fluid Typography Using CSS Clamp</a></li>
</ul>
 
    </div>
  </div>
  <div class="article__wrapper_footer">
    <a class="article__wrapper_footer-left " href="/articles/24.html"><svg t="1713708729970" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8437" width="48" height="48"><path d="M409.272947 512.57741l403.237243 403.237243a63.349415 63.349415 0 1 1-89.622481 89.622482L274.839224 557.324726a63.349415 63.349415 0 0 1 0-89.494632L722.951633 19.717685a63.349415 63.349415 0 1 1 89.494633 89.622482L409.336872 512.57741z" p-id="8438" fill="#8a8a8a"></path></svg></a>
    <a class="article__wrapper_footer-right " href="/articles/26.html"><svg t="1713708697355" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8093" width="48" height="48"><path d="M855.123 517.004c0 8.245-3.167 15.51-9.503 21.823L402.999 981.47c-6.336 6.336-13.625 9.477-21.869 9.477s-15.51-3.142-21.845-9.477L311.8 933.96c-6.336-6.336-9.502-13.6-9.502-21.845 0-8.222 3.167-15.51 9.502-21.845l373.29-373.29-373.293-373.267c-6.336-6.336-9.502-13.6-9.502-21.845s3.167-15.533 9.503-21.869l47.484-47.484c6.336-6.336 13.6-9.502 21.845-9.502s15.533 3.167 21.869 9.503l442.621 442.622c6.334 6.334 9.503 13.625 9.503 21.869z" fill="#8a8a8a" p-id="8094"></path></svg></a>
  </div>
  <a class="article__wrapper_index" href="/articles/"><svg t="1713708857338" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9656" width="48" height="48"><path d="M549.61981 133.022476l319.683047 203.605334A70.851048 70.851048 0 0 1 902.095238 396.361143v434.883047A70.89981 70.89981 0 0 1 831.146667 902.095238h-282.819048l0.024381-218.112h-71.826286v218.087619L192.853333 902.095238A70.89981 70.89981 0 0 1 121.904762 831.24419V390.241524c0-24.527238 12.678095-47.299048 33.54819-60.220953l318.659048-197.485714a70.972952 70.972952 0 0 1 75.50781 0.487619zM828.952381 828.952381V397.214476L511.488 195.047619 195.047619 391.119238V828.952381h211.309714v-216.551619h212.187429v216.527238L828.952381 828.952381z" p-id="9657" fill="#707070"></path></svg></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
  <script src="../assets/js/articles-detail.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</body>
</html>
    