<!DOCTYPE html>
<html lang="en">
  <head>
    <title>ES6到ES12常用新特性</title>
    <meta charset="utf-8">
    <meta name="description" content="This is a page">
    <meta name="keywords" content="page, sample">
    <meta name="author" content="None">
    <link rel="icon" sizes="any" mask href="../assets/images/ico4.svg" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <link rel="stylesheet" href="../assets/css/articles.css">
</head>
<body>
  <!--<div class="article__wrapper_left">
    <div class="article__wrapper_left-mulu">目录</div>
    <ul class="articles__list"><li class="">
          <a href="/articles/11.html">
            高效加载第三方JavaScript
          </a>
        </li><li class="">
          <a href="/articles/12.html">
            前端异常处理最佳实践
          </a>
        </li><li class="">
          <a href="/articles/13.html">
            JS错误监控篇
          </a>
        </li><li class="">
          <a href="/articles/14.html">
            前端异常监控解决方案研究
          </a>
        </li><li class="">
          <a href="/articles/15.html">
            原型模式
          </a>
        </li><li class="">
          <a href="/articles/16.html">
            单例模式
          </a>
        </li><li class="">
          <a href="/articles/17.html">
            CSS will-change
          </a>
        </li><li class="">
          <a href="/articles/18.html">
            外观模式
          </a>
        </li><li class="">
          <a href="/articles/19.html">
            适配器模式
          </a>
        </li><li class="">
          <a href="/articles/20.html">
            装饰者模式
          </a>
        </li></ul>
  </div>-->
  <div class="article__wrapper_sidebar">
    <a href="/articles/"><svg t="1714001835347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4298" width="48" height="48"><path d="M147.904 304.128l301.866667-179.541333a128 128 0 0 1 131.712 0.512l295.466666 178.88A128 128 0 0 1 938.666667 413.482667V810.666667a128 128 0 0 1-128 128H213.333333a128 128 0 0 1-128-128V414.144a128 128 0 0 1 62.570667-110.016z m43.626667 73.344A42.666667 42.666667 0 0 0 170.666667 414.144V810.666667a42.666667 42.666667 0 0 0 42.666666 42.666666h597.333334a42.666667 42.666667 0 0 0 42.666666-42.666666V413.482667a42.666667 42.666667 0 0 0-20.565333-36.501334l-295.466667-178.88a42.666667 42.666667 0 0 0-43.925333-0.170666l-301.866667 179.541333z" fill="currentColor" p-id="4299"></path><path d="M405.333333 469.333333h213.333334a42.666667 42.666667 0 1 1 0 85.333334H405.333333a42.666667 42.666667 0 1 1 0-85.333334z m0 85.333334a42.666667 42.666667 0 1 0 0-85.333334h213.333334a42.666667 42.666667 0 1 0 0 85.333334H405.333333z" fill="currentColor" p-id="4300"></path></svg></a>
    <a href="/tools/"><svg t="1714002003458" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6911" width="48" height="48"><path d="M817.87 556.31h-63.58v-66.24A42.27 42.27 0 0 0 712 447.8h-84.81a42.27 42.27 0 0 0-42.27 42.27v66.24H436.57v-66.24a42.27 42.27 0 0 0-42.27-42.27h-84.83a42.27 42.27 0 0 0-42.27 42.27v66.24h-61.83A22.39 22.39 0 0 0 183 578.7a22.39 22.39 0 0 0 22.39 22.39h61.81v65.55a42.27 42.27 0 0 0 42.27 42.27h84.83a42.27 42.27 0 0 0 42.27-42.27v-65.55h148.36v65.55a42.27 42.27 0 0 0 42.27 42.27H712a42.27 42.27 0 0 0 42.27-42.27v-65.55h63.58a22.39 22.39 0 0 0 22.39-22.39 22.39 22.39 0 0 0-22.37-22.39z m-438.64 95.26h-54.69V505.14h54.69z m317.72 0h-54.69V505.14H697z" p-id="6912" fill="currentColor"></path><path d="M823 202.58h-90.81v-63.09a71.88 71.88 0 0 0-71.88-71.88H363.19a71.88 71.88 0 0 0-71.88 71.88v63.08h-90.12A137.17 137.17 0 0 0 64 339.75v479a137.17 137.17 0 0 0 137.19 137.14H823a137.17 137.17 0 0 0 137.19-137.17v-479A137.17 137.17 0 0 0 823 202.58z m-474.36-54.1A23.52 23.52 0 0 1 372.17 125h279.16a23.52 23.52 0 0 1 23.52 23.52v54.1h-326.2z m554.23 673.31a76.76 76.76 0 0 1-76.76 76.76h-628a76.76 76.76 0 0 1-76.76-76.76V336.67a76.76 76.76 0 0 1 76.76-76.76h628a76.76 76.76 0 0 1 76.76 76.76z" p-id="6913" fill="currentColor"></path></svg></a>
  </div>
  <div class="article__wrapper">
    <div class="article__wrapper__main">
      <div class="article__wrapper_header">
        <h1>ES6到ES12常用新特性</h1>
        <span class="articles__home_time">2023/08/29 · YinHao</span>
      </div>
      <h1>ES 是什么？</h1>
<blockquote>
<p>ES 是 ECMAScript 的缩写，也就是 JavaScript 的标准化规范。ECMAScript 是一种由 Ecma 国际组织制定的脚本语言标准，它定义了 JavaScript 的语法、类型、操作符、对象和函数等基本组件。ES6（也称为 ES2015）是 ECMAScript 的第六个版本，引入了许多新的语言特性和改进，如箭头函数、模板字面量、解构赋值等。随后的版本（如 ES7、ES8 等）也引入了许多新的功能和语法糖，以进一步改进和扩展 JavaScript。</p>
</blockquote>
<h2>各版本特性总结</h2>
<table>
<thead>
<tr>
<th>版本</th>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ES6</td>
<td>let 和 const 关键字</td>
<td>引入了块级作用域声明变量的关键字 let 和常量声明变量的关键字 const</td>
</tr>
<tr>
<td>ES6</td>
<td>函数参数默认值</td>
<td>允许在函数定义时为参数设置默认值</td>
</tr>
<tr>
<td>ES6</td>
<td>箭头函数</td>
<td>使用箭头 (=&gt;) 定义函数，简化了函数的写法，并且自动绑定了当前作用域的 this</td>
</tr>
<tr>
<td>ES6</td>
<td>模板字符串</td>
<td>使用反引号 (`) 来定义字符串，可以在字符串中插入变量或表达式，并支持多行字符串</td>
</tr>
<tr>
<td>ES6</td>
<td>扩展操作符</td>
<td>使用扩展操作符 (...) 可以将数组或对象展开为单独的元素</td>
</tr>
<tr>
<td>ES6</td>
<td>解构赋值</td>
<td>可以从数组或对象中提取值并赋给变量</td>
</tr>
<tr>
<td>ES6</td>
<td>对象字面量简化</td>
<td>简化了对象的定义和属性的赋值方式</td>
</tr>
<tr>
<td>ES6</td>
<td>类</td>
<td>引入了类和继承的概念，使得 JavaScript 更像面向对象编程语言</td>
</tr>
<tr>
<td>ES6</td>
<td>模块化</td>
<td>支持使用 import 和 export 关键字进行模块化开发，可以方便地导入和导出模块</td>
</tr>
<tr>
<td>ES6</td>
<td>Promise</td>
<td>提供了一种更优雅的方式来处理异步操作，解决了回调地狱的问题</td>
</tr>
<tr>
<td>ES6</td>
<td>Symbol</td>
<td>引入了一种新的原始数据类型 Symbol，可以用来创建唯一的标识符</td>
</tr>
<tr>
<td>ES6</td>
<td>Map/WeakMap 和 Set/WeakSet 数据结构</td>
<td>提供了更灵活和高效的数据结构，Map 是一种键值对的集合，Set 是一种无重复值的集合，WeakMap 和 WeakSet 是弱引用版本，可以更好地处理内存和垃圾回收的问题</td>
</tr>
<tr>
<td>ES6</td>
<td>迭代器（Iterator）和 for...of</td>
<td>迭代器提供了一种遍历集合的方式，for...of 循环可以直接遍历可迭代对象</td>
</tr>
<tr>
<td>ES6</td>
<td>生成器（Generator）</td>
<td>可以生成多个值的函数，使用 function* 和 yield 关键字定义，可以暂停和恢复函数的执行</td>
</tr>
<tr>
<td>ES6</td>
<td>Proxy</td>
<td>提供了拦截和自定义操作的机制，可以代理对目标对象的访问和修改操作</td>
</tr>
<tr>
<td>ES6</td>
<td>Reflect</td>
<td>提供了一组静态方法来操作对象，比如获取对象的属性描述符、动态调用对象的方法等</td>
</tr>
<tr>
<td>ES6</td>
<td>数组对象扩展</td>
<td>引入了一些新的方法和属性，比如 Array.from()、Array.of()、Array.prototype.includes() 等，方便了数组的创建和操作</td>
</tr>
<tr>
<td>ES6</td>
<td>字符串对象扩展</td>
<td>引入了一些新的方法和属性，比如 String.prototype.startsWith()、String.prototype.endsWith()、String.prototype.includes() 等，方便了字符串的处理</td>
</tr>
<tr>
<td>ES6</td>
<td>Math 对象扩展</td>
<td>引入了一些新的方法和常量，比如 Math.trunc()、Math.sign()、Math.PI 等，提供了更多的数学计算功能</td>
</tr>
<tr>
<td>ES6</td>
<td>Object 对象扩展</td>
<td>引入了一些新的方法，比如 Object.assign()、Object.keys()、Object.values() 等，方便了对象的操作</td>
</tr>
<tr>
<td>ES6</td>
<td>正则对象扩展</td>
<td>引入了一些新的方法，比如 RegExp.prototype.flags、RegExp.prototype.sticky 等，增强了正则表达式的功能</td>
</tr>
<tr>
<td>ES7</td>
<td>Array.prototype.includes()方法</td>
<td>判断数组中是否包含指定的元素，返回布尔值</td>
</tr>
<tr>
<td>ES7</td>
<td>指数操作符 **</td>
<td>计算指数幂的运算符</td>
</tr>
<tr>
<td>ES8</td>
<td>async/await</td>
<td>提供了更简洁和可读性更好的异步编程方式</td>
</tr>
<tr>
<td>ES8</td>
<td>Object.entries()</td>
<td>返回对象自身可枚举属性的键值对数组</td>
</tr>
<tr>
<td>ES8</td>
<td>Object.values()</td>
<td>返回对象自身可枚举属性的值组成的数组</td>
</tr>
<tr>
<td>ES8</td>
<td>Object.getOwnPropertyDescriptors()</td>
<td>返回指定对象所有自身属性的描述符</td>
</tr>
<tr>
<td>ES8</td>
<td>padStart()和 padEnd()</td>
<td>在字符串的开头或结尾填充指定的字符，使字符串达到指定的长度</td>
</tr>
<tr>
<td>ES8</td>
<td>ShareArrayBuffer</td>
<td>一种新的共享内存对象，用于在多个线程之间共享数据，但因安全问题暂时在 Chrome、FireFox、Safari 中被禁用</td>
</tr>
<tr>
<td>ES9</td>
<td>for await...of</td>
<td>遍历异步可迭代对象的每个元素</td>
</tr>
<tr>
<td>ES9</td>
<td>Rest/Spread 属性</td>
<td>允许使用...语法来获取剩余的参数或将数组或对象展开为函数的参数</td>
</tr>
<tr>
<td>ES9</td>
<td>Promise.finally()</td>
<td>无论 Promise 对象的状态如何，都会执行的回调函数</td>
</tr>
<tr>
<td>ES9</td>
<td>正则表达式扩展</td>
<td>引入了一些新的功能，包括反向断言、命名捕获组、s 修饰符(dotAll 模式)、Unicode 属性转义等</td>
</tr>
<tr>
<td>ES10</td>
<td>数组扁平化方法</td>
<td>使用 flat() 方法将多维数组转换为一维数组</td>
</tr>
<tr>
<td>ES10</td>
<td>字符串去除开头和结尾的空格方法</td>
<td>使用 trimStart() 和 trimEnd() 方法去除字符串开头和结尾的空格</td>
</tr>
<tr>
<td>ES10</td>
<td>Object.fromEntries</td>
<td>将键值对数组转换为对象</td>
</tr>
<tr>
<td>ES10</td>
<td>Symbol.prototype.description</td>
<td>获取 Symbol 对象的描述</td>
</tr>
<tr>
<td>ES10</td>
<td>Function.prototype.toString()</td>
<td>返回函数的源代码字符串</td>
</tr>
<tr>
<td>ES10</td>
<td>catch 绑定</td>
<td>允许不使用参数绑定 catch 语句块中的错误对象</td>
</tr>
<tr>
<td>ES10</td>
<td>JSON.stringify() 增强</td>
<td>支持序列化 BigInt 类型的数据</td>
</tr>
<tr>
<td>ES11</td>
<td>globalThis</td>
<td>提供了一个标准的方式来获取全局对象，不再依赖于具体的环境</td>
</tr>
<tr>
<td>ES11</td>
<td>BigInt</td>
<td>引入了一种新的原始数据类型 BigInt，可以表示任意精度的整数</td>
</tr>
<tr>
<td>ES11</td>
<td>可选链操作符</td>
<td>允许在访问对象的属性时，如果属性不存在，不会报错，而是返回 undefined</td>
</tr>
<tr>
<td>ES11</td>
<td>空值合并操作符</td>
<td>允许在变量为 null 或 undefined 时，使用默认值</td>
</tr>
<tr>
<td>ES11</td>
<td>String.prototype.matchAll()</td>
<td>返回一个迭代器，包含了字符串中与正则表达式匹配的所有结果</td>
</tr>
<tr>
<td>ES11</td>
<td>import()</td>
<td>动态导入模块的方法</td>
</tr>
<tr>
<td>ES11</td>
<td>Promise.allSettled()</td>
<td>返回一个 Promise，等待所有 Promise 完成，并返回一个包含所有 Promise 结果的数组，不会抛出错误</td>
</tr>
<tr>
<td>ES12</td>
<td>数值分隔符</td>
<td>使用下划线 (_) 来分隔数值，提高数值的可读性</td>
</tr>
<tr>
<td>ES12</td>
<td>逻辑赋值运算符</td>
<td>引入了逻辑赋值运算符，简化了变量赋值的操作</td>
</tr>
<tr>
<td>ES12</td>
<td>String.prototype.replaceAll()</td>
<td>替换字符串中的所有匹配项</td>
</tr>
<tr>
<td>ES12</td>
<td>Promise.any()</td>
<td>返回一个 Promise，只要有一个 Promise 成功，就会返回该 Promise 的结果，不会等待其他 Promise 的完成</td>
</tr>
</tbody>
</table>
<p>以上只列举了每个版本的一些主要特性，还有其他一些较小的更新和改进没有在表格中列出。</p>
<h1>ES6</h1>
<blockquote>
<p>ES6 是 ECMAScript 2015 的简称，是 ECMAScript 的第六个版本。它在 2015 年发布，也被称为 ES2015。ES6 引入了许多新的语法和功能，大大改进了 JavaScript 的编程体验和开发效率。一些常见的 ES6 特性包括箭头函数、类和模块的支持、模板字符串、解构赋值、默认参数值、扩展运算符、Promise 等。ES6 的新增特性使得 JavaScript 在语法和功能上更加现代化和强大，成为前端开发中使用最广泛的 ECMAScript 版本之一。</p>
</blockquote>
<h2>let 和 const 关键字</h2>
<ul>
<li>let 关键字用于声明一个块级作用域的变量。与以前的 var 关键字不同，let 声明的变量只在其所在的块级作用域内有效，而不会被<strong>提升</strong>到函数作用域。这意味着在使用 let 声明的变量之前，必须先进行声明，否则会抛出 ReferenceError 错误。</li>
<li>const 关键字用于声明一个常量，其值在声明后不能再改变。const 声明的变量也是块级作用域的，与 let 类似，但其值是不可变的。</li>
</ul>
<pre><code class="language-js">if (true) {
  let x = 10; // 块级作用域变量
  const y = 20; // 块级作用域常量
  console.log(x); // 输出: 10
  console.log(y); // 输出: 20
  y = 10; //报错: Assignment to constant variable.
}

console.log(x); // 报错: x is not defined
console.log(y); // 报错: y is not defined
</code></pre>
<h2>函数参数默认值</h2>
<ul>
<li>在 ES6 中，我们可以在函数参数中设置默认值。这意味着如果调用函数时没有为参数提供值，它们将使用默认值。这对于简化函数调用和处理缺少参数的情况非常有用。</li>
</ul>
<pre><code class="language-js">function greet(name = &quot;World&quot;) {
  console.log(`Hello, ${name}!`);
}

greet(); // 输出：Hello, World!
greet(&quot;hhh&quot;); // 输出：Hello, hhh!
</code></pre>
<h2>箭头函数</h2>
<ul>
<li>箭头函数具有简洁的语法、清晰的上下文、继承外部作用域的 arguments 等特点，适合简化代码、避免 this 指向问题和明确的参数处理，但不适合用于构造函数和需要自己的 this 值的场景。</li>
</ul>
<pre><code class="language-js">// 箭头函数示例
const add = (a, b) =&gt; a + b;
console.log(add(2, 3)); // 输出: 5

// 函数表达式示例
const multiply = function (a, b) {
  return a * b;
};
console.log(multiply(2, 3)); // 输出: 6
</code></pre>
<h2>模板字符串</h2>
<ul>
<li>模板字符串是 ES6 中引入的一种新的字符串语法。它允许在字符串中插入变量或表达式，而不需要使用字符串拼接符号。模板字符串使用反引号``包围，并使用<code>${}</code>语法来插入变量或表达式。</li>
<li>在<code>${}</code>语法中，我们可以放置任何有效的 JavaScript 表达式，这些表达式的值将被插入到字符串中。</li>
</ul>
<pre><code class="language-js">const name = &quot;world&quot;;
console.log(`hello ${name}`); // 输出: hello world

//插入dom标签
const parent = document.querySelector(&quot;.parent&quot;);
const content = &quot;这是一个div标签&quot;;
const templateString = `&lt;div&gt;${content}&lt;/div&gt;`;
parent.innerHTML = templateString;
</code></pre>
<h2>扩展操作符</h2>
<ul>
<li>扩展操作符用于展开可迭代对象（如数组、字符串等），将其元素逐个展开，以便于在函数调用、数组字面量、对象字面量等地方使用。</li>
<li>在使用扩展操作符时，你需要在要展开的可迭代对象前面加上三个点（...）。</li>
</ul>
<ol>
<li>展开数组:</li>
</ol>
<pre><code class="language-js">const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]
</code></pre>
<ol start="2">
<li>传递参数给函数：</li>
</ol>
<pre><code class="language-js">function sum(a, b, c) {
  return a + b + c;
}

const numbers = [1, 2, 3];

const result = sum(...numbers); // 6
</code></pre>
<ol start="3">
<li>浅拷贝数组或对象：</li>
</ol>
<pre><code class="language-js">const arr1 = [1, 2, 3];
const arr2 = [...arr1]; // [1, 2, 3]

const obj1 = { name: &quot;Alice&quot;, age: 20 };
const obj2 = { ...obj1 }; // {name: 'Alice', age: 20}
</code></pre>
<h2>解构赋值</h2>
<ul>
<li>ES6 的解构赋值语法允许我们从数组或对象中提取值，并将它们赋给变量。这使得我们可以更简洁地进行变量赋值操作。</li>
<li>解构赋值可以用于数组和对象。下面是一些示例：</li>
</ul>
<ol>
<li>数组解构赋值：</li>
</ol>
<pre><code class="language-js">let numbers = [1, 2, 3];
let [a, b, c] = numbers;
console.log(a); // 输出 1
console.log(b); // 输出 2
console.log(c); // 输出 3
</code></pre>
<ol start="2">
<li>对象解构赋值：</li>
</ol>
<pre><code class="language-js">let person = { name: &quot;John&quot;, age: 20 };
let { name, age } = person;
console.log(name); // 输出 'John'
console.log(age); // 输出 20
</code></pre>
<p>除了基本的数组和对象解构赋值外，ES6 的解构赋值还提供了一些其他的操作。</p>
<ol>
<li>剩余项（Rest）操作符：可以使用...语法来捕获剩余的项，并将它们赋给一个数组。这在处理变长参数或动态长度的数组时非常有用。例如：</li>
</ol>
<pre><code class="language-js">let numbers = [1, 2, 3, 4, 5];
let [a, b, ...rest] = numbers;
console.log(a); // 输出 1
console.log(b); // 输出 2
console.log(rest); // 输出 [3, 4, 5]
</code></pre>
<ol start="2">
<li>解构赋值还支持默认值，当解构的值为 undefined 时，会使用默认值：</li>
</ol>
<pre><code class="language-js">let person = { name: &quot;John&quot; };
let { name, age = 18 } = person;
console.log(name); // 输出 'John'
console.log(age); // 输出 18
</code></pre>
<ol start="3">
<li>嵌套解构：可以在解构赋值中嵌套使用数组和对象的解构。例如：</li>
</ol>
<pre><code class="language-js">let numbers = [1, [2, 3], 4];
let [a, [b, c], d] = numbers;
console.log(a); // 输出 1
console.log(b); // 输出 2
console.log(c); // 输出 3
console.log(d); // 输出 4
</code></pre>
<ol start="4">
<li>对象属性别名：可以为解构赋值的变量设置别名，使用冒号来指定别名。例如：</li>
</ol>
<pre><code class="language-js">let person = { name: &quot;John&quot;, age: 20 };
let { name: fullName, age } = person;
console.log(fullName); // 输出 'John'
console.log(age); // 输出 20
</code></pre>
<ol start="5">
<li>解构赋值还可以在函数参数中使用，方便地提取函数参数中的值：</li>
</ol>
<pre><code class="language-js">function greet({ name, age }) {
  console.log(`Hello, ${name}! You are ${age} years old.`);
}

let person = { name: &quot;John&quot;, age: 20 };
greet(person); // 输出 'Hello, John! You are 20 years old.'
</code></pre>
<h2>对象字面量简化</h2>
<ul>
<li>ES6 引入了一种更简洁的方式来定义对象字面量，即 ES6 对象字面量语法。它提供了一种更方便的方法来定义和初始化对象属性。它是 ES6 中一个非常方便的特性，可以提高代码的可读性和可维护性。</li>
<li>在 ES6 之前，我们通常使用以下方式定义对象字面量：</li>
</ul>
<pre><code class="language-js">var name = &quot;hhh&quot;;
var age = 18;

var person = {
  name: name,
  age: age,
};
</code></pre>
<ul>
<li>在 ES6 中，我们可以使用更简洁的语法来定义对象字面量，还可以直接在对象字面量中定义方法，而不需要使用<code>function</code>关键字：</li>
</ul>
<pre><code class="language-js">const name = &quot;hhh&quot;;
const age = 18;

const person = {
  name,
  age,
  fun() {
    console.log(this.name, this.age);
  },
};
</code></pre>
<h2>类</h2>
<ul>
<li>在 ES5 中，我们没有类的概念，而是通过构造函数和原型链来实现对象：</li>
</ul>
<pre><code class="language-js">function Book(title, author) {
  this.title = title;
  this.author = author;
}

Book.prototype.getSummary = function () {
  return &quot;书名：&quot; + this.title + &quot;，作者：&quot; + this.author;
};

// 创建Book类的实例
var book1 = new Book(&quot;三体&quot;, &quot;刘慈欣&quot;);
console.log(book1.getSummary()); // 书名：三体，作者：刘慈欣
</code></pre>
<ul>
<li>ES6 引入了类（class）的概念，使得面向对象的编程变得更加直观和易于理解。类是一种蓝图或模板，用于创建具有相同属性和方法的对象。</li>
</ul>
<pre><code class="language-js">class Book {
  constructor(title, author) {
    this.title = title;
    this.author = author;
  }

  getSummary() {
    return `书名：${this.title} ,作者：${this.author} `;
  }
}

// 创建Book类的实例
const book1 = new Book(&quot;三体&quot;, &quot;刘慈欣&quot;);
console.log(book1.getSummary()); //书名：三体 ,作者：刘慈欣
</code></pre>
<h2>模块化</h2>
<ul>
<li>模块化是一种组织和管理 JavaScript 代码的方法，它将代码拆分为独立的模块，每个模块都有自己的作用域和功能。这种方法有助于提高代码的可维护性、可重用性和可扩展性。</li>
<li>在 ES6 之前，JavaScript 并没有原生的模块化支持。开发人员通常使用一些第三方库或模式来实现模块化，例如<code>CommonJS</code>和<code>AMD</code>。</li>
<li>然而，ES6 引入了原生的模块化系统，通过<code>import</code>和<code>export</code>关键字来实现。下面是一个示例：</li>
</ul>
<pre><code class="language-js">// utils.js
// 导出一个常量
export const PI = 3.14;
// 导出一个函数
export const area = (r) =&gt; PI * r ** 2;

// main.js
// 导入常量和函数
import { PI, area } from &quot;./utils.js&quot;;
console.log(PI, area(3)); //3.14 28.26
</code></pre>
<h2>Promise</h2>
<ul>
<li>Promise 是一个表示<strong>异步操作</strong>最终完成或失败的对象。</li>
<li>它可以有三种状态：
<ul>
<li><code>pending</code>（进行中）</li>
<li><code>resolved</code>（已完成）</li>
<li><code>rejected</code>（已失败）</li>
</ul>
</li>
<li>创建一个 Promise 对象：<code>new Promise((resolve, reject) =&gt; {})</code>
<ul>
<li><strong>resolve</strong>：将状态从<code>进行中</code>变为<code>完成</code>，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</li>
<li><strong>reject</strong>：将状态从<code>进行中</code>变为<code>失败</code>，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</li>
</ul>
</li>
<li>主要方法：
<ul>
<li><strong>then()</strong>：用于处理异步操作成功的情况</li>
<li><strong>catch()</strong>：用于处理异步操作失败的情况。</li>
<li><strong>Promise.all()</strong>：接收一个<strong>每个元素都是一个 Promise 对象</strong>的可迭代对象（如数组）作为参数，它会返回一个新的 Promise 对象，该 Promise 对象的状态取决于传入的所有 Promise 对象的状态（其中任何一个 Promise 对象状态为 rejected 状态，返回的 Promise 对象状态会立即变为 rejected），返回的 Promise 对象的结果是有序的，与传入的 Promise 对象的顺序相同。</li>
<li><strong>Promise.race()</strong>：和<code>Promise.all()</code>方法类似，但只要有一个 Promise 对象的状态变为 resolved 或 rejected，它就会返回该 Promise 对象的结果。</li>
<li><strong>Promise.resolve()</strong> ：将对象转为状态为<code>resolved</code>的 Promise 对象(等价于<code>new Promise(resolve =&gt; resolve())</code>)</li>
<li><strong>Promise.reject()</strong> ：将对象转为状态为<code>rejected</code>的 Promise 对象(等价于<code>new Promise((resolve, reject) =&gt; reject())</code>)</li>
</ul>
</li>
</ul>
<pre><code class="language-js">const myPromise = new Promise((resolve, reject) =&gt; {
  // 通过setTimeout模拟了一个耗时1秒的异步操作
  setTimeout(() =&gt; {
    const randomNumber = Math.random();
    if (randomNumber &gt; 0.5) {
      // 操作成功，调用resolve函数
      resolve(randomNumber);
    } else {
      // 操作失败，调用reject函数
      reject(new Error(&quot;操作失败&quot;));
    }
  }, 1000);
});

// 使用then方法处理Promise的结果
myPromise
  .then((result) =&gt; {
    console.log(&quot;操作成功:&quot;, result);
  })
  .catch((error) =&gt; {
    console.log(&quot;操作失败:&quot;, error);
  });
</code></pre>
<ul>
<li><code>Promise.all()</code>和<code>Promise.race()</code></li>
</ul>
<pre><code class="language-js">const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;Promise 1&quot;);
  }, 2000);
});

const promise2 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;Promise 2&quot;);
  }, 1000);
});

const promise3 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;Promise 3&quot;);
  }, 3000);
});

Promise.all([promise1, promise2, promise3])
  .then((results) =&gt; {
    console.log(results); // ['Promise 1', 'Promise 2', 'Promise 3']
  })
  .catch((error) =&gt; {
    console.error(error);
  });

Promise.race([promise1, promise2, promise3])
  .then((results) =&gt; {
    console.log(results); // Promise 2
  })
  .catch((error) =&gt; {
    console.error(error);
  });
</code></pre>
<ul>
<li><code>Promise.resolve()</code>和<code>Promise.reject()</code></li>
</ul>
<pre><code class="language-js">// 将一个值转化为 resolved 的 Promise 对象
const promise1 = Promise.resolve(42);
// 将一个值转化为 rejected 的 Promise 对象
const promise2 = Promise.reject(42);

promise1.then((result) =&gt; {
  console.log(result); // 输出：42
});

promise2.catch((error) =&gt; {
  console.log(error); // 输出：42
});
</code></pre>
<h2>Symbol</h2>
<ul>
<li>在 ES6 之前对象属性名都是字符串，这容易造成属性名的冲突。ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一。</li>
<li>Symbol 是一种独一无二且不可修改的数据类型，可以用作对象属性的唯一标识符。它被设计用于创建对象属性的私有成员或者用作常量。</li>
</ul>
<p>使用<code>Symbol()</code>函数可以创建一个新的 Symbol。每次调用<code>Symbol()</code>函数都会返回一个全新且不相等的 Symbol。</p>
<pre><code class="language-js">const mySymbol1 = Symbol();
const mySymbol2 = Symbol(&quot;hhh&quot;);
console.log(typeof mySymbol1); // symbol
console.log(mySymbol2.toString()); // Symbol(hhh)
console.log(mySymbol2 == Symbol(&quot;hhh&quot;)); // false
</code></pre>
<p>Symbol 可以作为对象的属性名来定义对象的私有成员。</p>
<pre><code class="language-js">const obj = {};

const privateMember = Symbol();
obj[privateMember] = &quot;私有成员&quot;;

console.log(obj[privateMember]); // &quot;私有成员&quot;
</code></pre>
<p>可以通过<code>Object.getOwnPropertySymbols()</code>方法获取对象的所有 Symbol 属性。</p>
<pre><code class="language-js">const symbols = Object.getOwnPropertySymbols(obj);
console.log(symbols); // [Symbol()]
console.log(obj[symbols[0]]); // &quot;私有成员&quot;
</code></pre>
<h2>Map/WeakMap 和 Set/WeakSet 数据结构</h2>
<h3>Map</h3>
<ul>
<li>Map 是一种键值对的集合(<strong>Hash 结构</strong>)，它类似于对象，但有一些不同之处。Map 的键可以是任意类型的值，包括对象和函数，而对象只能使用字符串作为键。此外，Map 的键值对是有序的，插入顺序决定了键值对的顺序。</li>
<li>方法
<ul>
<li><strong>get()</strong> ：返回键值对</li>
<li><strong>set()</strong> ：添加键值对，返回实例</li>
<li><strong>delete()</strong> ：删除键值对，返回布尔值</li>
<li><strong>has()</strong> ：检查键值对，返回布尔值</li>
<li><strong>clear()</strong> ：清除所有成员</li>
<li><strong>keys()</strong> ：返回以键为遍历器的对象</li>
<li><strong>values()</strong> ：返回以值为遍历器的对象</li>
<li><strong>entries()</strong> ：返回以键和值为遍历器的对象</li>
<li><strong>forEach()</strong> ：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 创建一个空的Map
let map = new Map();

// 添加键值对
map.set(&quot;name&quot;, &quot;John&quot;);
map.set(&quot;age&quot;, 30);

// 获取值
console.log(map.get(&quot;name&quot;)); // John

// 检查是否包含某个键
console.log(map.has(&quot;age&quot;)); // true

// 删除键值对
map.delete(&quot;age&quot;);

//返回长度
console.log(map.size); // 1
</code></pre>
<h3>WeakMap</h3>
<ul>
<li>WeakMap 也是一种键值对的集合，但是<strong>只接受对象</strong>作为键，不接受其他类型的数据。WeakMap 中的键是弱引用的，这意味着如果键对象没有其他引用，它会被垃圾回收机制回收，并且对应的键值对也会从 WeakMap 中被自动移除。</li>
<li>应用
<ul>
<li><strong>储存 DOM 节点</strong>：DOM 节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li><strong>部署私有属性</strong>：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li>
</ul>
</li>
<li>方法
<ul>
<li><strong>get()</strong> ：返回键值对</li>
<li><strong>set()</strong> ：添加键值对，返回实例</li>
<li><strong>delete()</strong> ：删除键值对，返回布尔值</li>
<li><strong>has()</strong> ：检查键值对，返回布尔值</li>
</ul>
</li>
</ul>
<h3>Set</h3>
<ul>
<li>Set 是一种不重复值的集合，类似于数组，但是它的值是唯一的，不会重复。Set 可以存储任意类型的值，包括原始类型和对象。</li>
<li>方法
<ul>
<li><strong>add()</strong> ：添加值，返回实例</li>
<li><strong>delete()</strong> ：删除值，返回布尔值</li>
<li><strong>has()</strong> ：检查值，返回布尔值</li>
<li><strong>clear()</strong> ：清除所有成员</li>
<li><strong>keys()</strong> ：返回以属性值为遍历器的对象</li>
<li><strong>values()</strong> ：返回以属性值为遍历器的对象</li>
<li><strong>entries()</strong> ：返回以属性值和属性值为遍历器的对象</li>
<li><strong>forEach()</strong> ：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 创建一个空的Set
let set = new Set();

// 添加值
set.add(1);
set.add(2);
set.add(2);
set.add(3);

// 检查是否包含某个值
console.log(set.has(2)); // true

// 删除值
set.delete(3);

//返回实例成员总数
console.log(set.size); // 2
</code></pre>
<h3>WeakSet</h3>
<ul>
<li>WeakSet 是一种弱引用集合，它只能存储对象类型的值，并且这些对象是弱引用的。这意味着如果一个对象在 WeakSet 中没有任何其他引用，那么这个对象将会被垃圾回收。由于 WeakSet 的成员是弱引用，因此无法迭代，也无法获取其中的大小或者清空它。</li>
<li>应用
<ul>
<li><strong>储存 DOM 节点</strong>：DOM 节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li><strong>临时存放一组对象或存放跟对象绑定的信息</strong>：只要这些对象在外部消失，它在<code>WeakSet结构</code>中的引用就会自动被垃圾回收</li>
</ul>
</li>
<li>方法
<ul>
<li><strong>add()</strong> ：添加值，返回实例</li>
<li><strong>delete()</strong> ：删除值，返回布尔值</li>
<li><strong>has()</strong> ：检查值，返回布尔值</li>
</ul>
</li>
</ul>
<h2>迭代器（Iterator）和 for...of</h2>
<h3>迭代器（Iterator）</h3>
<ul>
<li>迭代器（Iterator）是一种迭代的机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要内部有 Iterator 接口，就可以完成依次迭代操作。</li>
<li>默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“<strong>可遍历的</strong>”。</li>
<li>原生具备 Iterator 接口的数据结构如下：
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
</li>
<li>迭代器对象方法：
<ul>
<li><strong>next()</strong> ：下一步操作，返回<code>{ value,done }</code>(必须部署)</li>
<li><strong>return()</strong> ：<code>for-of</code>提前退出调用，返回<code>{ done: true }</code></li>
<li><strong>throw()</strong> ：不使用，配合<code>Generator函数</code>使用</li>
</ul>
</li>
</ul>
<pre><code class="language-js">let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
let iter = arr[Symbol.iterator]();

iter.next(); // { value: 'a', done: false }
iter.next(); // { value: 'b', done: false }
iter.next(); // { value: 'c', done: false }
iter.next(); // { value: undefined, done: true }
</code></pre>
<h3>for...of 循环</h3>
<ul>
<li><code>for...of</code>循环用于遍历可迭代对象（例如数组、字符串、Set、Map 等），它会迭代对象中的每个元素并执行指定的代码块。</li>
</ul>
<p>使用<code>for...of</code>循环遍历数组：</p>
<pre><code class="language-js">let arr = [1, 2, 3, 4];

for (let element of arr) {
  console.log(element);
}
// 输出：
// 1
// 2
// 3
// 4
</code></pre>
<p>使用<code>for...of</code>循环遍历字符串：</p>
<pre><code class="language-js">let str = &quot;Hello&quot;;

for (let char of str) {
  console.log(char);
}
// 输出：
// H
// e
// l
// l
// o
</code></pre>
<p><code>for...of</code>循环遍历 Set 和 Map 的元素：</p>
<pre><code class="language-js">let set = new Set([1, 2, 3]);

for (let value of set) {
  console.log(value);
}
// 输出：
// 1
// 2
// 3

let map = new Map([
  [&quot;name&quot;, &quot;John&quot;],
  [&quot;age&quot;, 30],
]);

for (let [key, value] of map) {
  console.log(key, value);
}
// 输出：
// name John
// age 30
</code></pre>
<h2>生成器（Generator）</h2>
<ul>
<li>Generator 函数在语法上，可以把它理解成一个状态机，内部封装了多个内部状态。</li>
<li>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</li>
<li>形式上，Generator 函数是一个普通函数，但是有两个特征：
<ul>
<li><code>function</code>关键字与函数名之间有一个星号；</li>
<li>函数体内部使用<code>yield</code>表达式，定义不同的内部状态</li>
</ul>
</li>
</ul>
<pre><code class="language-js">function* helloWorldGenerator() {
  yield &quot;hello&quot;;
  yield &quot;world&quot;;
  return &quot;ending&quot;;
}
var hw = helloWorldGenerator();
console.log(hw.next()); // { value: 'hello', done: false }
console.log(hw.next()); // { value: 'world', done: false }
console.log(hw.next()); // { value: 'ending', done: true }
console.log(hw.next()); // { value: undefined, done: true }
</code></pre>
<h2>Proxy</h2>
<ul>
<li><code>Proxy</code> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“<strong>元编程</strong>”（meta programming），即对编程语言进行编程。</li>
<li><code>Proxy</code> 可以理解成，在目标对象之前架设一层“<strong>拦截</strong>”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<code>Proxy</code> 这个词的原意是代理，用在这里表示由它来“<strong>代理</strong>”某些操作，可以译为“<strong>代理器</strong>”。</li>
<li>使用：<code>const proxy = new Proxy(target, handler)</code>其中<strong>target</strong>是拦截的目标对象，<strong>handler</strong>是定制拦截行为</li>
<li>常见的拦截方式
<ul>
<li><strong>get(target, propKey, receiver)</strong> ：用于拦截某个属性的读取操作</li>
<li><strong>set(target, propKey, value, receiver)</strong> ：用来拦截某个属性的赋值操作，返回布尔值</li>
<li><strong>has(target, propKey)</strong> ：拦截对象属性检查<code>k in obj</code>，返回布尔值</li>
<li><strong>deleteProperty(target, propKey)</strong> ：拦截对象属性删除<code>delete obj[k]</code>，返回布尔值</li>
<li><strong>defineProperty(target, propKey, propDesc)</strong> ：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔值</li>
<li><strong>ownKeys(target)</strong> ：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>，返回数组</li>
<li><strong>apply(target, object, args)</strong> ：拦截 Proxy 实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></li>
</ul>
</li>
</ul>
<h2>Reflect</h2>
<ul>
<li>在 ES5 及之前的版本中，对于对象的操作通常是通过<code>Object</code>的方法来完成，比如<code>Object.defineProperty()</code>、<code>Object.create()</code>等。这些方法在使用上存在一些不一致和不直观的地方，比如使用<code>Object.defineProperty()</code>来定义属性时，如果属性已经存在，会抛出错误，而<code>Reflect.defineProperty()</code>则会返回<code>false</code>表示定义失败。</li>
<li>es6 引入的<code>Reflect</code>是一个内置的对象，它提供了一组静态方法，用于操作对象。<code>Reflect</code>的方法和一些<code>Object</code>的方法具有相似的功能，但是使用<code>Reflect</code>方法可以更加简洁和直观；使用<code>Reflect</code>方法进行操作时，返回值可以告诉我们操作是否成功，而不是通过抛出错误来表示操作失败。</li>
<li><code>Reflect</code>对象常用方法：
<ul>
<li><strong>construct(target, argumentsList)</strong>：用于创建一个类的实例对象。</li>
<li><strong>get(target, propKey, receiver)</strong>：获取对象的属性值。</li>
<li><strong>set(target, propKey, value, receiver)</strong>：设置对象的属性值。</li>
<li><strong>has(target, propKey)</strong>：判断对象是否具有某个属性。</li>
<li><strong>deleteProperty(target, propKey)</strong>：删除对象的属性。</li>
<li><strong>apply(function, thisArg, args)</strong>：调用一个函数，并传入指定的参数。</li>
<li><strong>defineProperty(target, propKey, attributes)</strong>：定义对象的属性。</li>
</ul>
</li>
<li>利用<code>Reflect</code>和<code>Proxy</code>写一个观察者模式</li>
</ul>
<pre><code class="language-js">class Observable {
  constructor() {
    this.data = {}; // 存储数据
    this.observers = new Set(); // 存储观察者
  }

  addObserver(observer) {
    this.observers.add(observer); // 添加观察者到observers集合中
  }

  removeObserver(observer) {
    this.observers.delete(observer); // 从observers集合中删除观察者
  }

  notifyObservers() {
    for (let observer of this.observers) {
      observer.update(this.data); // 通知观察者更新数据
    }
  }

  setData(key, value) {
    Reflect.set(this.data, key, value); // 使用Reflect设置数据
    this.notifyObservers(); // 通知观察者更新数据
  }
}

class Observer {
  constructor(name) {
    this.name = name; // 观察者名称
  }

  update(data) {
    console.log(`${this.name} received data:`, data); // 观察者接收到数据并输出
  }
}

// 创建可观察对象
const subject = new Observable();

// 创建观察者对象
const observer1 = new Observer(&quot;Observer 1&quot;);
const observer2 = new Observer(&quot;Observer 2&quot;);

// 将观察者对象添加到主题对象中
subject.addObserver(observer1);
subject.addObserver(observer2);

// 设置数据并通知观察者
subject.setData(&quot;name&quot;, &quot;Jack&quot;);
subject.setData(&quot;age&quot;, 25);

// 输出结果：
// Observer 1 received data: { name: 'Jack' }
// Observer 2 received data: { name: 'Jack' }
// Observer 1 received data: { name: 'Jack', age: 25 }
// Observer 2 received data: { name: 'Jack', age: 25 }
</code></pre>
<h2>数组对象扩展</h2>
<ol>
<li><code>Array.prototype.from()</code>: 将类数组对象或可迭代对象转换为数组。</li>
</ol>
<pre><code class="language-js">const arrayLike = { 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3 };
const array = Array.from(arrayLike);
console.log(array); // ['a', 'b', 'c']
</code></pre>
<ol start="2">
<li><code>Array.prototype.of()</code>: 根据传入的参数创建一个新数组。</li>
</ol>
<pre><code class="language-js">const array = Array.of(1, 2, 3);
console.log(array); // [1, 2, 3]
</code></pre>
<ol start="3">
<li><code>Array.prototype.find()</code>: 返回数组中满足条件的第一个元素。</li>
</ol>
<pre><code class="language-js">const array = [1, 2, 3, 4, 5];
const found = array.find((element) =&gt; element &gt; 3);
console.log(found); // 4
</code></pre>
<ol start="4">
<li><code>Array.prototype.findIndex()</code>: 返回数组中满足条件的第一个元素的索引。</li>
</ol>
<pre><code class="language-js">const array = [1, 2, 3, 4, 5];
const index = array.findIndex((element) =&gt; element &gt; 3);
console.log(index); // 3
</code></pre>
<ol start="5">
<li><code>Array.prototype.fill()</code>: 用指定的值填充数组。</li>
</ol>
<pre><code class="language-js">const array = [1, 2, 3, 4, 5];
array.fill(0, 1, 3);
console.log(array); // [1, 0, 0, 4, 5]
</code></pre>
<ol start="6">
<li><code>Array.prototype.copyWithin()</code>：用于将数组中的一部分元素复制到指定位置，覆盖原有的元素。</li>
</ol>
<pre><code class="language-js">const arr = [1, 2, 3, 4, 5];
arr.copyWithin(0, 3); // 将索引为3及其之后的元素复制到索引为0的位置
console.log(arr); // 输出：[4, 5, 3, 4, 5]
</code></pre>
<ol start="7">
<li><code>Array.prototype.keys()</code>：返回一个包含数组中每个索引的新 Array Iterator 对象。</li>
</ol>
<pre><code class="language-js">const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
const iterator = arr.keys();
for (const key of iterator) {
  console.log(key); // 输出：0, 1, 2
}
</code></pre>
<ol start="8">
<li><code>Array.prototype.values()</code>：该方法返回一个包含数组中每个元素的新 Array Iterator 对象。</li>
</ol>
<pre><code class="language-js">const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
const iterator = arr.values();
for (const value of iterator) {
  console.log(value); // 输出：'a', 'b', 'c'
}
</code></pre>
<ol start="9">
<li><code>Array.prototype.entries()</code>：返回一个包含数组中每个索引和对应元素的新 Array Iterator 对象。</li>
</ol>
<pre><code class="language-js">const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
const iterator = arr.entries();
for (const [index, value] of iterator) {
  console.log(index, value); // 输出：0 'a', 1 'b', 2 'c'
}
</code></pre>
<ol start="10">
<li><strong>数组空位</strong>：ES6 中对待数组空位的方式有所改变。空位指的是数组中某个位置没有任何值，例如<code>[1, , 3]</code>中的第二个元素是个空位。在 ES6 之前，对待数组空位的方式是跳过它们，不进行任何操作。但在 ES6 中，空位被视为 undefined 的值。例如，使用 ES6 的数组方法时，空位会被当作 undefined 处理。</li>
</ol>
<h2>字符串对象扩展</h2>
<ol>
<li><code>String.prototype.includes()</code>：判断字符串是否包含指定的字符，返回布尔值。</li>
</ol>
<pre><code class="language-js">const str = &quot;Hello, world!&quot;;
console.log(str.includes(&quot;world&quot;)); // 输出：true
console.log(str.includes(&quot;foo&quot;)); // 输出：false
</code></pre>
<ol start="2">
<li><code>String.prototype.startsWith()</code>：判断字符串是否以指定的字符开始，返回布尔值。</li>
</ol>
<pre><code class="language-js">const str = &quot;Hello, world!&quot;;
console.log(str.startsWith(&quot;Hello&quot;)); // 输出：true
console.log(str.startsWith(&quot;foo&quot;)); // 输出：false
</code></pre>
<ol start="3">
<li><code>String.prototype.endsWith()</code>：判断字符串是否以指定的字符结束，返回布尔值。</li>
</ol>
<pre><code class="language-js">const str = &quot;Hello, world!&quot;;
console.log(str.endsWith(&quot;world!&quot;)); // 输出：true
console.log(str.endsWith(&quot;foo&quot;)); // 输出：false
</code></pre>
<ol start="4">
<li><code>String.prototype.repeat()</code>：将字符串重复指定次数，返回新的字符串。</li>
</ol>
<pre><code class="language-js">const str = &quot;Hello, world!&quot;;
console.log(str.repeat(3)); // 输出：Hello, world!Hello, world!Hello, world!
</code></pre>
<ol start="5">
<li><code>String.prototype.fromCodePoint()</code>:根据给定的码点创建一个字符串。它可以将一个或多个码点转换为对应的字符。</li>
</ol>
<pre><code class="language-js">console.log(String.fromCodePoint(65)); // 输出：A
console.log(String.fromCodePoint(97, 98, 99)); // 输出：abc
</code></pre>
<ol start="6">
<li><code>String.prototype.raw()</code>:用于获取一个模板字符串的原始字符串形式，忽略其中的转义字符。</li>
</ol>
<pre><code class="language-js">const path = &quot;C:\\Users\\hhh\\Documents\\file.txt&quot;;
console.log(String.raw`The file is located at ${path}`); // 输出：The file is located at C:\Users\hhh\Documents\file.txt
</code></pre>
<ol start="7">
<li><code>String.prototype.codePointAt()</code>:用于返回指定位置的字符的码点。</li>
</ol>
<pre><code class="language-js">const str = &quot;abc&quot;;
console.log(str.codePointAt(0)); // 输出：97
console.log(str.codePointAt(1)); // 输出：98
console.log(str.codePointAt(2)); // 输出：99
</code></pre>
<ol start="8">
<li><code>String.prototype.normalize()</code>:用于将字符串的 <code>Unicode</code> 标准化形式。它主要用于处理 <code>Unicode</code> 字符串的不同表示方式。</li>
</ol>
<pre><code class="language-js">const str = &quot;c\u0327&quot;;
console.log(str.normalize()); // 输出：ç
</code></pre>
<h2>Math 对象扩展</h2>
<ul>
<li><code>二进制表示法</code> : <code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li>
<li><code>二进制表示法</code> : <code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li>
<li><code>八进制表示法</code> : <code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li>
<li><code>Number.EPSILON</code> : 数值最小精度</li>
<li><code>Number.MIN_SAFE_INTEGER</code> : 最小安全数值(<code>-2^53</code>)</li>
<li><code>Number.MAX_SAFE_INTEGER</code> : 最大安全数值(<code>2^53</code>)</li>
<li><code>Number.parseInt()</code> : 返回转换值的整数部分</li>
<li><code>Number.parseFloat()</code> : 返回转换值的浮点数部分</li>
<li><code>Number.isFinite()</code> : 是否为有限数值</li>
<li><code>Number.isNaN()</code> : 是否为 NaN</li>
<li><code>Number.isInteger()</code> : 是否为整数</li>
<li><code>Number.isSafeInteger()</code> : 是否在数值安全范围内</li>
<li><code>Math.trunc()</code> : 返回数值整数部分</li>
<li><code>Math.sign()</code> : 返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</li>
<li><code>Math.cbrt()</code> : 返回数值立方根</li>
<li><code>Math.clz32()</code> : 返回数值的 32 位无符号整数形式</li>
<li><code>Math.imul()</code> : 返回两个数值相乘</li>
<li><code>Math.fround()</code> : 返回数值的 32 位单精度浮点数形式</li>
<li><code>Math.hypot()</code> : 返回所有数值平方和的平方根</li>
<li><code>Math.expm1()</code> : 返回<code>e^n - 1</code></li>
<li><code>Math.log1p()</code> : 返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</li>
<li><code>Math.log10()</code> : 返回以 10 为底的 n 的对数</li>
<li><code>Math.log2()</code> : 返回以 2 为底的 n 的对数</li>
<li><code>Math.sinh()</code> : 返回 n 的双曲正弦</li>
<li><code>Math.cosh()</code> : 返回 n 的双曲余弦</li>
<li><code>Math.tanh()</code> : 返回 n 的双曲正切</li>
<li><code>Math.asinh()</code> : 返回 n 的反双曲正弦</li>
<li><code>Math.acosh()</code> : 返回 n 的反双曲余弦</li>
<li><code>Math.atanh()</code> : 返回 n 的反双曲正切</li>
</ul>
<h2>Object 对象扩展</h2>
<ol>
<li><code>Object.is(value1, value2)</code>: 用于比较两个值是否相同。与&quot;===&quot;操作符的行为类似，但有两个区别：一是 Object.is(NaN, NaN)返回 true，而&quot;===&quot;操作符返回 false；二是 Object.is(+0, -0)返回 false，而&quot;===&quot;操作符返回 true。</li>
</ol>
<pre><code class="language-js">console.log(Object.is(1, 1)); // true
console.log(Object.is(NaN, NaN)); // true
console.log(Object.is(+0, -0)); // false
</code></pre>
<ol start="2">
<li><code>Object.assign(target, ...sources)</code>: 将一个或多个源对象的属性复制到目标对象中。它返回目标对象。如果多个源对象具有相同的属性，则后面的对象的属性将覆盖前面的对象的属性。</li>
</ol>
<pre><code class="language-js">const target = { a: 1, b: 2 };
const source = { b: 3, c: 4 };
const result = Object.assign(target, source);
console.log(result); // { a: 1, b: 3, c: 4 }
</code></pre>
<ol start="3">
<li><code>Object.getPrototypeOf(obj)</code>: 用于获取对象的原型。它返回指定对象的原型。</li>
</ol>
<pre><code class="language-js">const obj = {};
const prototype = Object.getPrototypeOf(obj);
console.log(prototype); // {}
</code></pre>
<ol start="4">
<li><code>Object.setPrototypeOf(obj, prototype)</code>: 用于设置对象的原型。它将指定对象的原型设置为另一个对象或 null。</li>
</ol>
<pre><code class="language-js">const obj = {};
const prototype = { a: 1 };
Object.setPrototypeOf(obj, prototype);
console.log(obj.a); // 1
</code></pre>
<ol start="5">
<li><code>__proto__方法</code>：用于获取或设置对象的原型。</li>
</ol>
<h2>正则对象扩展</h2>
<ol>
<li><code>RegExp构造函数的扩展</code>：在 ES6 之前，RegExp 构造函数不允许使用第二个参数添加修饰符。在 ES6 中，如果<code>RegExp</code>构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</li>
</ol>
<pre><code class="language-js">console.log(new RegExp(/abc/gi, &quot;i&quot;).flags); // &quot;i&quot;
</code></pre>
<ol start="2">
<li><code>Flags属性</code>：用于返回正则表达式的修饰符。</li>
</ol>
<pre><code class="language-js">const regex = /abc/gi;
console.log(regex.flags); // &quot;gi&quot;
</code></pre>
<ol start="3">
<li><code>u修饰符</code>：用于处理大于<code>\uFFFF</code>的 Unicode 字符。</li>
</ol>
<pre><code class="language-js">console.log(/^\S$/.test(&quot;𠮷&quot;)); // false
console.log(/^\S$/u.test(&quot;𠮷&quot;)); // true
</code></pre>
<ol start="4">
<li><code>y修饰符</code>：也称为“粘连”修饰符，用于指定只从目标字符串的当前位置开始匹配。</li>
</ol>
<pre><code class="language-js">const regex = /abc/y;
console.log(regex.exec(&quot;abcabc&quot;)); // [ 'abc', index: 0, input: 'abcabc', groups: undefined ]
console.log(regex.exec(&quot;abcabc&quot;)); // [ 'abc', index: 3, input: 'abcabc', groups: undefined ] 因为第二次匹配从上一次匹配的结束位置开始
console.log(regex.exec(&quot;abcabc&quot;)); // null
</code></pre>
<ol start="5">
<li><code>RegExp.prototype.sticky</code>  表示是否有<code>y</code>修饰符</li>
<li><code>RegExp.prototype.unicode</code>  表示是否有<code>u</code>修饰符</li>
</ol>
<pre><code class="language-js">console.log(/hello\d/y.sticky); //true
console.log(/hello\d/u.unicode); //true
</code></pre>
<ol start="7">
<li><strong>正则方法调用变更</strong>：字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></li>
</ol>
<h1>ES7</h1>
<blockquote>
<p>ES7，也称为 ECMAScript 2016，是 ECMAScript 的第 7 个版本。它于 2016 年发布，引入了一些新的语言特性和改进。</p>
</blockquote>
<h2>Array.prototype.includes()方法</h2>
<ul>
<li>includes()方法用于判断一个数组是否包含某个指定的元素，并返回布尔值。</li>
</ul>
<pre><code class="language-js">let arr = [1, 2, 3, 4, 6];
console.log(arr.includes(5)); //false
console.log(arr.includes(6)); //true
</code></pre>
<h2>指数操作符</h2>
<ul>
<li>ES7 引入了指数运算符，用于计算一个数的指数，<code>**</code>具有与  <code>Math.pow(..)</code>等效的计算结果。</li>
</ul>
<pre><code class="language-js">console.log(2 ** 3); //8
</code></pre>
<h1>ES8</h1>
<blockquote>
<p>ES8，也称为 ECMAScript 2017，是 ECMAScript（JavaScript）的第八个版本。它于 2017 年 6 月发布，并在 ES6（ES2015）的基础上引入了一些新特性和语法改进。</p>
</blockquote>
<h2>async/await</h2>
<ul>
<li>ES8 引入了<code>async/await</code>语法，它是一种更简洁、更易于理解和编写异步代码的方式。它建立在<code>Promise</code>的基础上，通过使用<code>async</code>关键字来定义一个异步函数，以及使用<code>await</code>关键字来等待一个<code>Promise</code>对象的解决。</li>
<li>使用<code>async</code>关键字定义的函数会返回一个<code>Promise</code>对象，而在函数体内使用<code>await</code>关键字可以暂停函数的执行，直到等待的<code>Promise</code>对象解决为止。这样可以使得异步代码的执行顺序更加线性，避免了回调地狱。</li>
<li>当使用<code>Promise</code>时，链式调用太多的话代码通常会变得比较冗长和嵌套：</li>
</ul>
<pre><code class="language-js">// 定义一个延迟函数，接受一个毫秒数作为参数
function delay(ms) {
  // 返回一个新的Promise对象，该对象在指定的毫秒数后解决
  return new Promise((resolve) =&gt; setTimeout(resolve, ms));
}

// 延迟1秒后执行的操作
delay(1000)
  .then(() =&gt; {
    console.log(&quot;After 1 second&quot;); // 输出&quot;After 1 second&quot;
    return delay(2000); // 返回一个延迟2秒的Promise对象
  })
  .then(() =&gt; {
    console.log(&quot;After 2 seconds&quot;); // 输出&quot;After 2 seconds&quot;
    return &quot;Finished&quot;; // 返回一个字符串&quot;Finished&quot;
  })
  .then((result) =&gt; {
    console.log(result); // 输出&quot;Finished&quot;
  })
  .catch((error) =&gt; {
    console.error(error); // 输出捕获到的错误信息（如果有）
  });
</code></pre>
<ul>
<li>相比之下，使用<code>async/await</code>可以使代码更加线性和易于理解，以一种更接近同步代码的方式编写异步操作：</li>
</ul>
<pre><code class="language-js">// 定义一个延迟函数，接受一个毫秒数作为参数
function delay(ms) {
  // 返回一个新的Promise对象，该对象在指定的毫秒数后解决
  return new Promise((resolve) =&gt; setTimeout(resolve, ms));
}

// 定义一个异步函数example
async function example() {
  console.log(&quot;Start&quot;); // 输出&quot;Start&quot;
  await delay(1000); // 等待1秒钟
  console.log(&quot;After 1 second&quot;); // 输出&quot;After 1 second&quot;
  await delay(2000); // 等待2秒钟
  console.log(&quot;After 2 seconds&quot;); // 输出&quot;After 2 seconds&quot;
  return &quot;Finished&quot;; // 返回一个字符串&quot;Finished&quot;
}

// 定义一个异步函数runExample，用于执行example函数
async function runExample() {
  try {
    const result = await example(); // 等待example函数完成并获取结果
    console.log(result); // 输出example函数的返回值
  } catch (error) {
    console.error(error); // 输出捕获到的错误信息（如果有）
  }
}

runExample(); // 执行runExample函数，开始执行异步操作
</code></pre>
<h2>Object.entries()</h2>
<ul>
<li><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组</li>
</ul>
<pre><code class="language-js">let obj = { a: 1, b: 2 };
for (let [key, value] of Object.entries(obj)) {
  console.log(`${key}: ${value}`);
}
//输出
// a: 1
// b: 2
</code></pre>
<h2>Object.values()</h2>
<ul>
<li><code>Object.values()</code>方法返回一个给定对象自身可枚举属性值的数组</li>
</ul>
<pre><code class="language-js">let obj = { a: 1, b: 2 };
console.log(Object.values(obj)); //[ 1, 2 ]
</code></pre>
<h2>Object.getOwnPropertyDescriptors()</h2>
<ul>
<li><code>Object.getOwnPropertyDescriptors()</code>  方法用来获取一个对象的所有自身属性的描述符</li>
</ul>
<pre><code class="language-js">let obj = { a: 1, b: 2 };
console.log(Object.getOwnPropertyDescriptors(obj));
//输出
// {
//     a: { value: 1, writable: true, enumerable: true, configurable: true },
//     b: { value: 2, writable: true, enumerable: true, configurable: true }
// }
</code></pre>
<h2>padStart()和 padEnd()</h2>
<ul>
<li><code>padStart()</code>方法可以在字符串的开头添加指定的字符，直到字符串达到指定的长度。如果字符串的长度已经达到或超过了指定的长度，则不会进行任何填充。</li>
</ul>
<pre><code class="language-js">let phoneNumber = &quot;18912345677&quot;; // 电话号码
let paddedPhoneNumber = phoneNumber.slice(-4).padStart(11, &quot;*&quot;); // 将电话号码填充到11位，使用*进行填充，并且只保留后四位数
console.log(paddedPhoneNumber); // *******5677
</code></pre>
<ul>
<li><code>padEnd()</code>方法与<code>padStart()</code>方法类似，不同之处在于它在字符串的结尾添加指定的字符，直到字符串达到指定的长度。</li>
</ul>
<pre><code class="language-js">const text = &quot;Hello&quot;;
console.log(text.padEnd(8, &quot;!&quot;)); // 输出：'Hello!!!'
</code></pre>
<h2>ShareArrayBuffer（因安全问题，暂时在 Chrome，FireFox，Safari 中被禁用）</h2>
<ul>
<li>用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</li>
</ul>
<h1>ES9</h1>
<blockquote>
<p>ES9 是 ECMAScript 的第 9 个版本，也被称为 ES2018。它于 2018 年 6 月发布，引入了一些新的特性和语法改进。</p>
</blockquote>
<h2>for await...of</h2>
<ul>
<li><code>for await...of</code>  是 ES9 中引入的一种语法，用于遍历异步迭代器的元素。它的语法类似于传统的  <code>for...of</code>  循环，但可以在异步操作完成后继续迭代下一个元素。</li>
<li>利用 Generator 函数实现一个异步迭代器对象，然后用<code>for await...of</code>遍历这个异步迭代器的元素：</li>
</ul>
<pre><code class="language-js">async function* asyncGenerator() {
  yield Promise.resolve(1);
  yield Promise.resolve(2);
  yield Promise.resolve(3);
}

(async () =&gt; {
  for await (const num of asyncGenerator()) {
    console.log(num);
  }
})();
</code></pre>
<h2>Rest/Spread 属性</h2>
<ul>
<li><code>Rest/Spread</code> 属性语法是对扩展运算符的一种扩展。<code>Rest/Spread</code> 属性允许我们在对象字面量中使用扩展运算符（<code>...</code>）来获取对象的剩余属性或将属性扩展到另一个对象中。</li>
<li><code>Rest</code> 属性用于从对象中提取剩余的属性，并将它们作为新的对象返回。这样可以方便地从一个对象中提取所需的属性，而不必一个一个地进行赋值。：</li>
</ul>
<pre><code class="language-js">const { name, age, ...rest } = {
  name: &quot;hhh&quot;,
  age: 18,
  sex: &quot;男&quot;,
  city: &quot;上海&quot;,
};
console.log(name); // &quot;hhh&quot;
console.log(age); // 18
console.log(rest); // { sex: '男', city: '上海 }
</code></pre>
<ul>
<li><code>Spread</code> 属性用于将一个对象的属性扩展到另一个对象中。这样可以方便地合并两个对象的属性，而不必一个一个地进行赋值。</li>
</ul>
<pre><code class="language-js">const obj1 = { name: &quot;hhh&quot;, age: 18 };
const obj2 = { sex: &quot;男&quot;, city: &quot;上海&quot; };
const mergedObj = { ...obj1, ...obj2 };
console.log(mergedObj); // { name: 'hhh', age: 18, sex: '男', city: '上海' }
</code></pre>
<h2>Promise.finally()</h2>
<ul>
<li>在<code>Promise</code>结束的时候，不管是结果是<code>resolved</code>还是<code>rejected</code>，都会调用<code>finally</code>中的方法， <code>finally</code>中的回调函数不接受任何参数</li>
</ul>
<pre><code class="language-js">const promise = new Promise((resolve, reject) =&gt; {
  // 异步操作
  // resolve(value); // 或 reject(reason);
});

promise
  .then((result) =&gt; {
    // 处理成功的情况
  })
  .catch((error) =&gt; {
    // 处理失败的情况
  })
  .finally(() =&gt; {
    // 无论成功或失败都会执行的回调函数
  });
</code></pre>
<h2>正则表达式扩展</h2>
<h3>反向断言</h3>
<ul>
<li>反向断言使用<code>(?&lt;=pattern)</code>的语法来定义，其中<code>pattern</code>是一个子表达式，表示需要存在的模式。它可以用于匹配前面是某种模式的字符串。</li>
</ul>
<pre><code class="language-js">const regex = /(?&lt;=\$)\d+/;
const match = regex.exec(&quot;The price is $99&quot;);
console.log(match[0]); // 输出：99
</code></pre>
<ul>
<li>反向否定断言是一种用于匹配在某种模式之后不存在的字符的方法。它使用<code>(?!pattern)</code>的语法来表示。这个模式会匹配一个位置，这个位置后面的字符不能匹配给定的模式。</li>
</ul>
<pre><code class="language-js">const str = &quot;a123bbcd667&quot;;
const regex = /(?&lt;![a-z])\d+/g;
const matches = str.match(regex);
console.log(matches); // 输出: [ '23', '67' ]
</code></pre>
<h3>命名捕获组</h3>
<ul>
<li>命名捕获组允许我们给正则表达式的子表达式（也称为分组）命名，并且可以通过名称来引用它们的匹配结果。</li>
<li>命名捕获组可以通过在子表达式前面加上<code>?&lt;name&gt;</code>的语法来实现。</li>
</ul>
<pre><code class="language-js">const regex = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/;
const match = regex.exec(&quot;2023-08-28&quot;);

console.log(match.groups.year); // 输出：2023
console.log(match.groups.month); // 输出：08
console.log(match.groups.day); // 输出：28
</code></pre>
<h3>s 修饰符(dotAll 模式)</h3>
<ul>
<li>在默认情况下，正则表达式中的点字符（.）匹配除换行符（\n）之外的任何字符。但是，使用 dotAll 模式后，点字符将匹配包括换行符在内的任何字符。</li>
</ul>
<pre><code class="language-js">const regex = /a.b/s;
const str = &quot;a\nb&quot;;
console.log(regex.test(str)); // 输出 true
</code></pre>
<h3>Unicode 属性转义</h3>
<ul>
<li>Unicode 属性转义用于匹配具有特定属性的字符。这些转义的形式分别是  <code>\p{...}</code>  和  <code>\P{...}</code>。<code>\p{...}</code>  是一个 Unicode 属性转义，用于匹配具有指定属性的字符。它的语法是  <code>\p{Property=Value}</code>，其中  <code>Property</code>  是 Unicode 属性的名称，<code>Value</code>  是该属性的取值。通过使用这个转义，可以在正则表达式中匹配具有特定属性的字符。</li>
</ul>
<pre><code class="language-js">const reEmoji = /\p{Emoji}/u;
console.log(reEmoji.test(&quot;🥰😊😍&quot;)); // 输出 true
</code></pre>
<h1>ES10</h1>
<blockquote>
<p>ES10 是 ECMAScript 的第 10 个版本，也被称为 ES2019。它于 2019 年 6 月发布，引入了一些新的特性和语法改进。</p>
</blockquote>
<h2>数组扁平化方法</h2>
<ul>
<li><code>Array.prototype.flat()</code>方法会按照一个可指定的深度遍历递归数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</li>
</ul>
<pre><code class="language-js">const arr = [
  [1, 2],
  [3, [4, 5]],
];
console.log(arr.flat(1)); // 输出: [1, 2, 3, [4, 5]]

const deeplyNestedArr = [[1, [2, [3, [4, [5]]]]]];
console.log(deeplyNestedArr.flat(Infinity)); // 输出: [1, 2, 3, 4, 5]
</code></pre>
<ul>
<li><code>Array.prototype.flatMap()</code>方法结合了  <code>map()</code>  和  <code>flat()</code>  两个方法的功能。它首先对数组的每个元素执行一个映射函数，然后将结果扁平化为一维数组。</li>
</ul>
<pre><code class="language-js">const arr = [1, 2, 3, 4, 5];
console.log(arr.flatMap((num) =&gt; [num * num])); // 输出: [1, 4, 9, 16, 25]

const words = [&quot;Hello&quot;, &quot;World&quot;];
console.log(words.flatMap((word) =&gt; word.split(&quot;&quot;))); // 输出: [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;W&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;]
</code></pre>
<h2>字符串去除开头和结尾的空格方法</h2>
<ul>
<li><code>String.prototype.trimStart()</code>  方法去除字符串开头的空白字符，返回一个新的字符串，原始字符串不受影响。空白字符包括空格、制表符、换行符等。</li>
</ul>
<pre><code class="language-js">const str = &quot;   Hello, world!   &quot;;
console.log(str.trimStart()); // &quot;Hello, world!   &quot;
</code></pre>
<ul>
<li><code>String.prototype.trimEnd()</code>  方法去除字符串结尾的空白字符，返回一个新的字符串，原始字符串不受影响。</li>
</ul>
<pre><code class="language-js">const str = &quot;   Hello, world!   &quot;;
console.log(str.trimEnd()); // &quot;   Hello, world!&quot;
</code></pre>
<h2>Object.fromEntries</h2>
<ul>
<li><code>Object.fromEntries()</code>用于将一个包含键值对的可迭代对象（如 Array，Map 等对象）转换为一个新的对象。</li>
</ul>
<pre><code class="language-js">const entries = [
  [&quot;name&quot;, &quot;hhh&quot;],
  [&quot;age&quot;, 25],
  [&quot;city&quot;, &quot;上海&quot;],
];
const obj = Object.fromEntries(entries);
console.log(obj); // { name: 'hhh', age: 25, city: '上海' }
</code></pre>
<h2>Symbol.prototype.description</h2>
<ul>
<li><code>Symbol.prototype.description</code>用于获取 Symbol 的描述信息。</li>
</ul>
<pre><code class="language-js">console.log(Symbol(&quot;myDescription&quot;).description); //myDescription
</code></pre>
<h2>Function.prototype.toString()</h2>
<ul>
<li>之前的版本中，该方法来自  <code>Object.prototype.toString()</code>，得到的字符串是去掉空白符号的。</li>
<li>但在 ES10 中，得到的字符串会保留空格和注释，如果函数是内置方法的，或者是通过  <code>bind()</code>  方法创建的，<code>Function.prototype.toString()</code>  方法将返回一个标记为  <code>[native code]</code>  的字符串。</li>
</ul>
<pre><code class="language-js">function sum(a, b) {
  return a + b;
}

console.log(sum.toString());
// &quot;function sum(a, b) {
// 		return a + b;
//  }&quot;
let newSum = sum.bind();
console.log(newSum.toString()); // &quot;function () { [native code] }&quot;
console.log(Math.abs.toString()); // &quot;function abs() { [native code] }&quot;
</code></pre>
<h2>catch 绑定</h2>
<ul>
<li>在 ES10 中，允许在 <code>catch</code> 语句中绑定错误对象，而不需要通过 <code>catch</code> 语句的参数来引用它。</li>
<li>在 ES10 之前，<code>catch</code> 语句通常如下所示：</li>
</ul>
<pre><code class="language-js">try {
  // 一些可能抛出错误的代码
} catch (error) {
  // 处理错误的代码
}
</code></pre>
<p>在 ES10 中，可以使用 <code>catch</code> 绑定来进行错误处理，如下所示：</p>
<pre><code class="language-js">try {
  // 一些可能抛出错误的代码
} catch {
  // 处理错误的代码
}
</code></pre>
<h2>JSON.stringify()  增强</h2>
<ul>
<li>在 ES10 中，<code>JSON.stringify()</code> 方法修复了之前版本中对于一些超出范围的 Unicode 字符的展示错误的问题。</li>
<li>在修复之前，当遇到超出 U+FFFF 的 Unicode 字符时，<code>JSON.stringify()</code> 方法会将其转义为一个由两个代理字符组成的字符串，而不是正确的 Unicode 字符。</li>
<li>修复后，<code>JSON.stringify()</code> 方法会正确地展示这些超出范围的 Unicode 字符。这个修复使得对于 Unicode 字符的处理更加准确和方便。</li>
</ul>
<pre><code class="language-js">console.log(JSON.stringify(&quot;🥰&quot;)); // &quot;🥰&quot;
</code></pre>
<h1>ES11</h1>
<blockquote>
<p>ES11 是 ECMAScript 的第 11 个版本，也被称为 ES2020。它于 2020 年 6 月发布，引入了一些新的特性和语法改进。</p>
</blockquote>
<h2>globalThis</h2>
<ul>
<li>在之前的 JavaScript 版本中，全局对象的名称是不一致的，比如在浏览器中是  <code>window</code>，在 Node.js 中是  <code>global</code>。这导致了在跨平台开发时需要针对不同的环境使用不同的全局对象。</li>
<li>为了解决这个问题，ES11 引入了  <code>globalThis</code>，它是一个统一的全局对象。无论在浏览器还是 Node.js 中，都可以使用  <code>globalThis</code>  来访问全局对象。这样，你就不需要根据不同的环境来手动切换全局对象的名称了。</li>
</ul>
<h2>BigInt</h2>
<ul>
<li>在之前的版本中，整数的范围受到限制，超过 2^53 或小于 -2^53 的整数会丢失精度。而 BigInt 类型通过添加后缀  <code>n</code>  或调用构造函数  <code>BigInt()</code>  来表示超出这个范围的整数，并且可以进行算术运算。</li>
<li>要注意的是：
<ul>
<li><code>BigInt</code>在<code>Math</code>对象中的方法不可用；</li>
<li><code>BigInt</code>与<code>Number</code>实例不能混合运算，需要转换为相同类型；</li>
<li><code>BigInt</code>在转换为<code>Number</code>时可能会丢失精度；</li>
<li>使用<code>BigInt</code>进行带小数的运算会向下取整；</li>
<li><code>BigInt</code>和<code>Number</code>不是严格相等，但是宽松相等。</li>
</ul>
</li>
</ul>
<pre><code class="language-js">const maxSafeInteger = BigInt(Number.MAX_SAFE_INTEGER);
const bigNumber = BigInt(&quot;123456789012345678901234567890&quot;);

console.log(maxSafeInteger); // 9007199254740991n
console.log(bigNumber); // 123456789012345678901234567890n

const sum = maxSafeInteger + bigNumber;
console.log(sum); // 123456789012345678901234576981n

console.log(2n &gt; 2, 2n &gt; 1); // false true
console.log(0n === 0, 0n == 0); // false true
</code></pre>
<h2>可选链操作符</h2>
<ul>
<li>可选链操作符（Optional Chaining Operator）用于简化访问嵌套对象属性或方法时的安全性检查。通过<code>?.</code>来判断属性或方法是否存在，如果存在则访问，如果不存在则返回 undefined，避免了在访问链中出现的类型错误或未定义错误。</li>
<li>在 ES11 之前，如果要访问嵌套对象属性或方法时，我们需要手动进行安全性检查，以避免出现错误：</li>
</ul>
<pre><code class="language-js">// 在ES11之前的代码
if (obj &amp;&amp; obj.prop &amp;&amp; obj.prop.method) {
  // 访问obj.prop.method
}
</code></pre>
<ul>
<li>使用可选链操作符，可以简化上述代码，避免了多次的检查和重复的代码。</li>
</ul>
<pre><code class="language-js">// 使用可选链操作符
if (obj?.prop?.method) {
  // 访问obj.prop.method
}
</code></pre>
<h2>空值合并操作符</h2>
<ul>
<li>空值合并操作符（Nullish Coalescing Operator）用于在给定的一组值中选择一个非空（非 null 和非 undefined）的值。</li>
<li>在以前的版本中，我们通常使用逻辑或运算符（||）来实现类似的功能。但是逻辑或运算符有一个问题，它会将假值（例如空字符串''、数字 0、布尔值 false 等）也视为“空”，从而导致错误的结果。</li>
<li>而空值合并操作符（??）只在左侧的值为 null 或 undefined 时才会选择右侧的值，对于其他的假值不会触发选择右侧的值。</li>
<li>注意：不可以将  <code>??</code>  与 AND（<code>&amp;&amp;</code>）OR（<code>||</code>）混用，会报错。</li>
</ul>
<pre><code class="language-js">// 在ES11之前的代码
const value = x || defaultValue;

// 使用空值合并操作符
const value = x ?? defaultValue;
</code></pre>
<h2>String.prototype.matchAll()</h2>
<ul>
<li><code>String.prototype.matchAll()</code> 返回一个包含所有匹配正则表达式的迭代器对象。迭代器对象可以通过 <code>for...of</code> 循环或者 <code>Array.from()</code> 方法转换为数组，并且每个元素都是一个包含匹配结果的数组。</li>
</ul>
<pre><code class="language-js">const str = &quot;Hello, world!&quot;;
const regex = /[a-z]/gi;
const matches = str.matchAll(regex);

for (const match of matches) {
  console.log(match);
}
//输出
// [ 'H', index: 0, input: 'Hello, world!', groups: undefined ]
// [ 'e', index: 1, input: 'Hello, world!', groups: undefined ]
// [ 'l', index: 2, input: 'Hello, world!', groups: undefined ]
// [ 'l', index: 3, input: 'Hello, world!', groups: undefined ]
// [ 'o', index: 4, input: 'Hello, world!', groups: undefined ]
// [ 'w', index: 7, input: 'Hello, world!', groups: undefined ]
// [ 'o', index: 8, input: 'Hello, world!', groups: undefined ]
// [ 'r', index: 9, input: 'Hello, world!', groups: undefined ]
// [ 'l', index: 10, input: 'Hello, world!', groups: undefined ]
// [ 'd', index: 11, input: 'Hello, world!', groups: undefined ]
</code></pre>
<h2>import()</h2>
<ul>
<li>ES11 中引入了 <code>import()</code> 函数，它是一个动态导入模块的方法。在以前的 ES6 模块系统中，所有的导入语句都必须在代码的头部静态编译，不能根据运行时的条件来导入不同的模块。而 <code>import()</code> 函数允许在代码运行时根据需要动态地加载模块。</li>
<li><code>import()</code> 函数返回一个<code>Promise</code>，该 <code>Promise</code> 在模块加载完成后被解析为一个包含模块的默认导出的对象。这使得我们可以在需要的时候延迟加载模块，从而提高应用程序的性能和响应速度。</li>
</ul>
<pre><code class="language-js">import(&quot;./module.js&quot;)
  .then((module) =&gt; {
    // 使用模块中的内容
    module.default();
  })
  .catch((error) =&gt; {
    // 处理加载模块失败的情况
    console.error(&quot;模块加载失败&quot;, error);
  });
</code></pre>
<h2>Promise.allSettled()</h2>
<ul>
<li><code>Promise.allSettled()</code> 方法接收一个由 <code>Promise</code> 对象组成的可迭代对象（比如数组），并返回一个新的 <code>Promise</code> 对象。这个新的 <code>Promise</code> 对象在所有传入的 <code>Promise</code> 对象都已经被解决（<code>settled</code>）后才会被解决。</li>
<li>与 <code>Promise.all()</code> 不同的是，即使其中的某个 <code>Promise</code> 被拒绝（<code>rejected</code>），<code>Promise.allSettled()</code> 仍会等待所有 <code>Promise</code> 对象都被解决，然后返回一个包含每个 <code>Promise</code> 对象结果的数组。这使得我们能够获取所有 <code>Promise</code> 对象的状态，而不必担心其中某个 <code>Promise</code> 对象的拒绝（<code>rejected</code>）会中断整个操作。</li>
</ul>
<pre><code class="language-js">const promises = [
  Promise.resolve(&quot;Resolved&quot;),
  Promise.reject(&quot;Rejected&quot;),
  Promise.resolve(&quot;Resolved&quot;),
];

Promise.allSettled(promises).then((results) =&gt; {
  results.forEach((result) =&gt; {
    if (result.status === &quot;fulfilled&quot;) {
      console.log(`Promise resolved: ${result.value}`);
    } else if (result.status === &quot;rejected&quot;) {
      console.log(`Promise rejected: ${result.reason}`);
    }
  });
});
</code></pre>
<h1>ES12</h1>
<blockquote>
<p>ES12，也被称为 ES2021，于 2021 年 6 月发布。ES12 引入了一些新的特性和改进，以提升 JavaScript 语言的功能和性能。</p>
</blockquote>
<h2>数值分隔符</h2>
<ul>
<li>数值分隔符（Numeric Separators）允许在数字中使用下划线 <code>_</code> 进行分隔，以提高数字的可读性。数值分隔符在 JavaScript 中是可选的，它们不会影响数字的值或计算结果。</li>
<li>使用数值分隔符，可以将长数字分成更易读的部分:</li>
</ul>
<pre><code class="language-js">const billion = 1_000_000_000;
console.log(billion); // 输出 1000000000
</code></pre>
<ul>
<li>数值分隔符可以在整数和浮点数中使用，但不能在数字的开头或结尾使用，也不能在小数点前后使用。</li>
</ul>
<pre><code class="language-js">const number = 1_234.567_89;
console.log(number); // 输出 1234.56789
</code></pre>
<h2>逻辑赋值运算符</h2>
<ul>
<li>逻辑赋值运算符（Logical Assignment Operators）是一种简化常见逻辑操作和赋值的合并运算符。</li>
<li>ES12 中引入了三个逻辑赋值运算符：</li>
</ul>
<ol>
<li><code>||=</code>：逻辑或赋值运算符。如果左侧的操作数为假（例如，<code>undefined</code>、<code>null</code>、false 或 0），则将右侧的操作数赋值给左侧的变量。</li>
</ol>
<pre><code class="language-js">let x = 0;
x ||= 5;
console.log(x); // 输出 5，因为 x 是假值，所以将 5 赋值给 x
</code></pre>
<ol start="2">
<li><code>&amp;&amp;=</code>：逻辑与赋值运算符。如果左侧的操作数为真（例如，非空字符串、非零数字或对象），则将右侧的操作数赋值给左侧的变量。</li>
</ol>
<pre><code class="language-js">let y = 10;
y &amp;&amp;= 7;
console.log(y); // 输出 7，因为 y 是真值，所以将 7 赋值给 y
</code></pre>
<ol start="3">
<li><code>??=</code>：空值合并赋值运算符。如果左侧的操作数为 <code>null</code> 或 <code>undefined</code>，则将右侧的操作数赋值给左侧的变量。</li>
</ol>
<pre><code class="language-js">let z = null;
z ??= 3;
console.log(z); // 输出 3，因为 z 是空值，所以将 3 赋值给 z
</code></pre>
<h2>String.prototype.replaceAll()</h2>
<ul>
<li><code>String.prototype.replaceAll()</code>方法，该方法可以用指定的字符串替换字符串中的所有匹配项。在之前的版本中，我们只能使用正则表达式配合<code>replace()</code>方法来实现替换所有匹配项的操作。</li>
<li>使用 <code>replaceAll()</code> 方法非常简便，只需要传入两个参数：第一个参数是要替换的字符串或正则表达式(<strong>必须是全局的</strong>)，第二个参数是替换后的字符串。方法会返回一个新的字符串，其中所有匹配项都被替换为指定的字符串。</li>
</ul>
<pre><code class="language-js">console.log(&quot;Hello, world!&quot;.replaceAll(&quot;o&quot;, &quot;x&quot;)); // &quot;Hellx, wxrld!&quot;
console.log(&quot;Hello, world!&quot;.replaceAll(/l/g, &quot;x&quot;)); // &quot;Hexxo, worxd!&quot;
</code></pre>
<h2>Promise.any()</h2>
<ul>
<li><code>Promise.any()</code> 方法接收一个 <code>Promise</code> 对象的可迭代参数（如数组），并返回一个新的 <code>Promise</code> 对象。</li>
<li>这个新的 <code>Promise</code> 对象将在其中的任何一个 <code>Promise</code> 对象变为 <code>fulfilled</code>（已完成）状态时解析，并以该 <code>Promise</code> 对象的解析值作为其解析值。如果可迭代参数中的所有 <code>Promise</code> 对象都变为 <code>rejected</code>（已拒绝）状态，则返回的 <code>Promise</code> 对象将会被拒绝，并以一个 <code>AggregateError</code> 实例作为拒绝值。</li>
</ul>
<pre><code class="language-js">const promise1 = Promise.resolve(1);
const promise2 = Promise.reject(2);
const promise3 = Promise.resolve(1);

Promise.any([promise1, promise2, promise3])
  .then((value) =&gt; {
    console.log(value); // 1
  })
  .catch((error) =&gt; {
    // 全部请求失败时才会执行这里的代码
    console.log(error);
  });
</code></pre>
 
    </div>
  </div>
  <div class="article__wrapper_footer">
    <a class="article__wrapper_footer-left " href="/articles/09.html"><svg t="1713708729970" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8437" width="48" height="48"><path d="M409.272947 512.57741l403.237243 403.237243a63.349415 63.349415 0 1 1-89.622481 89.622482L274.839224 557.324726a63.349415 63.349415 0 0 1 0-89.494632L722.951633 19.717685a63.349415 63.349415 0 1 1 89.494633 89.622482L409.336872 512.57741z" p-id="8438" fill="currentColor"></path></svg></a>
    <a class="article__wrapper_footer-right " href="/articles/11.html"><svg t="1713708697355" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8093" width="48" height="48"><path d="M855.123 517.004c0 8.245-3.167 15.51-9.503 21.823L402.999 981.47c-6.336 6.336-13.625 9.477-21.869 9.477s-15.51-3.142-21.845-9.477L311.8 933.96c-6.336-6.336-9.502-13.6-9.502-21.845 0-8.222 3.167-15.51 9.502-21.845l373.29-373.29-373.293-373.267c-6.336-6.336-9.502-13.6-9.502-21.845s3.167-15.533 9.503-21.869l47.484-47.484c6.336-6.336 13.6-9.502 21.845-9.502s15.533 3.167 21.869 9.503l442.621 442.622c6.334 6.334 9.503 13.625 9.503 21.869z" fill="currentColor" p-id="8094"></path></svg></a>
  </div>
  <a class="article__wrapper_index" href="/articles/"><svg t="1713708857338" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9656" width="48" height="48"><path d="M549.61981 133.022476l319.683047 203.605334A70.851048 70.851048 0 0 1 902.095238 396.361143v434.883047A70.89981 70.89981 0 0 1 831.146667 902.095238h-282.819048l0.024381-218.112h-71.826286v218.087619L192.853333 902.095238A70.89981 70.89981 0 0 1 121.904762 831.24419V390.241524c0-24.527238 12.678095-47.299048 33.54819-60.220953l318.659048-197.485714a70.972952 70.972952 0 0 1 75.50781 0.487619zM828.952381 828.952381V397.214476L511.488 195.047619 195.047619 391.119238V828.952381h211.309714v-216.551619h212.187429v216.527238L828.952381 828.952381z" p-id="9657" fill="#707070"></path></svg></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
  <script src="../assets/js/articles-detail.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</body>
</html>
    