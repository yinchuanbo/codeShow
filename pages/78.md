---
title: "比较运算"
date: 2023-10-19T20:34:10+07:00
---

## 等值检测

等值检测的目的是判断两个变量是否相等，

| 名称       | 运算符 | 说明                                                 |
| ---------- | ------ | ---------------------------------------------------- |
| 相等       | ==     | 比较两个表达式，看是否相等                           |
| 不等       | !=     | 比较两个表达式，看是否不相等                         |
| 严格相等   | ===    | 比较两个表达式，看值是否相等并具有相同的数据类型     |
| 不严格相等 | !==    | 比较两个表达式，看是否具有不相等的值或不同的数据类型 |

对于等值检测来说，最简单和最有效的方法当然是比较两个变量引用（所指向的内存地址），但这并不准确，因为我们显然会在两个不同的内存地址上存放同样的数据，例如两个相同的字符串。

因此比较引用虽然高效，但在很多时候却需要比较两个变量的值。

- **等值检测中“相等”的运算原则**

| 类型                     | 运算规则                                                           |
| ------------------------ | ------------------------------------------------------------------ |
| 值类型与引用类型进行比较 | 将引用类型的数据转换为与值类型数据相同的数据，再进行“数据等值”比较 |
| 两个值类型进行比较       | 转换成相同数据类型的值进行“数据等值”比较                           |
| 两个引用类型进行比较     | 比较引用（内存地址）                                               |

上述规则中所谓的 “数据等值” 仅指对 “值类型” 的比较而言，表明比较是变量所指向的存储单元中的数据（通常指 “内存数据”）

在三种值类型（数值、布尔值、字符串）中，如果两个被比较的值类型不用，那么：

1. 有任何一个是数字时，会将另一个转换为数字进行比较

2. 有任何一个数布尔值时，它将被转换为数字进行比较（并且由于上一个规则的存在，所以另一个数据也将被转换为数字），

3. 有任何一个是对象（或函数）时，将调用该对象的 `valueOf()` 方法将其转换为数据进行比较，且在多数情况下该值数据作为数字值处理

4. 按照特定规则返回比较结果，例如 undefined 与 null 值总是相等的。

```js
undefined === undefined; // true
null === null; // true
```

可见，Js 总是尽量用**数字值**比较来实现等值检测，

这主要是因为 Js 内部的数据存储格式适合这一操作，同样的原因（即出于内部存储的格式的限制），字符串检测通常会存在非常大的开销。

严格来说，必须对字符串中的每一个字符串进行比较，才能判断两个字符串是否相等，

```js
var str1 = "abc" + "def";
console.log(typeof str1); // string
var str2 = "abcd" + "ef";
console.log(typeof str2); // string
console.log(str1 === str2); // 这个运算需要进行 6 次字符比较，才能得到结果值 true
```

- **等值检测中“严格相等”的运算原则**

| 类型                     | 运算规则                                                                            |
| ------------------------ | ----------------------------------------------------------------------------------- |
| 值类型与引用类型进行比较 | 必然 “不严格相等”                                                                   |
| 两个值类型进行比较       | 如果数据类型不同，则必然 “不严格相等”，否则，按等值检测中 “相等” 的运算规则进行比较 |
| 两个引用类型进行比较     | 比较引用（地址）                                                                    |

```js
var obj,
  str = "abcdef";
var obj1 = new String(str);
var obj2 = (obj = new String(str));
// 比较
console.log(obj1 == obj2); // false
console.log(obj1 === obj2); // false
console.log(obj == obj2); // true
console.log(obj === obj2); // true
```

在等值检测运算中存在一些特例，包括：

```js
// 1.NaN 不等于自身
NaN == NaN; // false
NaN === NaN; // false
NaN != NaN; // true
NaN !== NaN; // true
// 2.符号可以转换为 true，但不等值于 true
Boolean(Symbol()); // true
!Symbol(); // false
Symbol() == true; // false
Symbol() === true; // false
// 3.即使字面量相同的引用类型，也不是严格相等的
{} === {}; // false
/./ === /./; // false
function() {} === funciton() {}; // false
```

## 序列检测

- **Js 中可进行序列检测的数据类型**

| 可比较序列的类型 | 序列值                                                                                         |
| ---------------- | ---------------------------------------------------------------------------------------------- |
| boolean          | 0 ~ 1                                                                                          |
| string           | 当等值检测中有任何一个数据是符号时，该符号无须进行任何数据转换，因为它总是不等值于任何其他数据 |
| number           | NEGATIVE_INFINITY ~ POSITIVE_INFINITY                                                          |

序列检测的含义在于比较变量在序列中的大小，

- **序列检测的运算规则**

| 类型                     | 运算负责                                                             |
| ------------------------ | -------------------------------------------------------------------- |
| 两个值类型进行比较       | 直接比较数据在序列中的大小                                           |
| 值类型与引用类型进行比较 | 将引用类型的数据转换为与值类型数据相同的数据，再进行 “序列大小” 比较 |
| 两个引用类型进行比较     | 无意义，总是返回 false                                               |

```js
var o1 = {};
var o2 = {};
var str = "123";
var num = 1;
var b0 = false;
var b1 = true;
var ref = new String();

// 1.值类型的比较
console.log(b1 < num); // false
console.log(b1 <= num); // true
console.log(b1 > b0); // true

// 2.值类型与引用类型的比较
// 空字符串被转换为 0
console.log(num > ref); // true

// 3.两个对象比较时总是返回 false
console.log(o1 > o2 || o1 < o2 || o1 == o2);
```

- 当两个操作数都是字符串时，使用 `>、>=、<、<=` 表示字符串序列检测

- 当任意一个操作数是非字符串时，会将字符串转换为数值来参与运算

下例说明：

```js
var s1 = "abc";
var s2 = "ab";
var s3 = "101";

var b = true;
var i = 100;

// 1.两个操作数为字符串，将比较 `每个字符` 的序列值，
console.log(s1 > s2);

// 2. 在将字符串 s3 转换为数值时得到 101
console.log(s3 > i); // 101 > 100 true

// 3. 在将字符串 s1 转换为数值时得到 NaN，
// 变量 b 的布尔值为 true，转换为数值 1 参与运算
console.log(s1 > b || s1 < b || s1 == b); // false

// 4.两个 NaN 的比较，NaN 不等值也不大于或小于自身，所以下面的三个比较都为 false
console.log(s1 > NaN || s1 < NaN || s1 == NaN);
```
